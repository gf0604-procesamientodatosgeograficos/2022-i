# Operaciones con datos de atributos

## Resumen
Se les llama atributos a los elementos de datos no espaciales o geométricos de un conjunto de datos geoespaciales. Estos datos pueden ser de tipos numéricos o textuales, entre otros. Un conjunto de datos vectoriales puede tener asociados varios campos de atributos, mientras que un conjunto de datos raster tiene solamente uno.

Las operaciones con atributos en datos vectoriales incluyen creación de subconjuntos, agregación y cruce de datos. Estas operaciones pueden ejecutarse con funciones del paquete base de R o con las de paquetes de Tidyverse. Por su parte, las operaciones con atributos en datos raster incluyen creación de subconjuntos y resumen de información.

## Trabajo previo

### Lecturas
Lovelace, R., Nowosad, J., & Münchow, J. (2019). *Geocomputation with R* (capítulo 3). CRC Press. https://geocompr.robinlovelace.net/

## Preparativos

### Carga de paquetes

```{r carga-paquetes, message=FALSE}
# Carga de paquetes

library(stringi) # manejo de hileras de texto
library(readr) # lectura de archivos CSV
library(readxl) # lectura de archivos XLS
library(dplyr) # transformación de datos
library(DT) # tablas interactivas
library(sf) # manejo de datos vectoriales
library(terra) # manejo de datos raster
library(leaflet) # mapas interactivos
```

### Conjuntos de datos para ejemplos

#### Provincias de Costa Rica
Es un [archivo GeoJSON con los polígonos de las provincias de Costa Rica](datos/ign/delimitacion-territorial-administrativa/provincias.geojson). Este archivo proviene de un [geoservicio de tipo Web Feature Service (WFS)](http://geos.snitcr.go.cr/be/IGN_5/wfs) publicado por el Instituto Geográfico Nacional (IGN). Se transforma a WGS84 para posteriormente desplegarlo más fácilmente en `leaflet`.

```{r lectura-provincias}
# Lectura, transformación y visualización de datos geoespaciales de provincias

# Lectura
provincias <-
  st_read(
    dsn = "datos/ign/delimitacion-territorial-administrativa/provincias.geojson",
    quiet = TRUE
  ) %>%
  st_transform(4326) # transformación a WGS84

# Transformación
provincias <-
  provincias %>%
  st_transform(5367) %>%
  st_simplify(dTolerance = 100) %>% # simplificación de geometrías
  st_transform(4326)

# Visualización en un mapa
plot(
  provincias$geometry,
  extent = st_bbox(c(xmin = -86.0, xmax = -82.3, ymin = 8.0, ymax = 11.3)),
  main = "Provincias de Costa Rica",
  axes = TRUE,
  graticule = TRUE
)
```

#### Cantones de Costa Rica
Es un [archivo GeoJSON con los polígonos de los cantones de Costa Rica](datos/ign/delimitacion-territorial-administrativa/cantones.geojson). Este archivo proviene de un [geoservicio de tipo Web Feature Service (WFS)](http://geos.snitcr.go.cr/be/IGN_5/wfs) publicado por el Instituto Geográfico Nacional (IGN). Se transforma a WGS84 para posteriormente desplegarlo más fácilmente en `leaflet`.

```{r lectura-cantones}
# Lectura, transformación y visualización de datos geoespaciales de cantones

# Lectura
cantones <-
  st_read(
    dsn = "datos/ign/delimitacion-territorial-administrativa/cantones.geojson",
    quiet = TRUE
  ) %>%
  st_transform(4326) # transformación a WGS84

# Transformación
cantones <-
  cantones %>%
  st_transform(5367) %>%
  st_simplify(dTolerance = 100) %>% # simplificación de geometrías
  st_transform(4326)

# Visualización en un mapa
plot(
  cantones$geometry,
  extent = st_bbox(c(xmin = -86.0, xmax = -82.3, ymin = 8.0, ymax = 11.3)),
  main = "Cantones de Costa Rica",
  axes = TRUE,
  graticule = TRUE
)
```

#### Distritos de Costa Rica
Es un [archivo GeoJSON con los polígonos de los distritos de Costa Rica](datos/ign/delimitacion-territorial-administrativa/distritos.geojson). Este archivo proviene de un [geoservicio de tipo Web Feature Service (WFS)](http://geos.snitcr.go.cr/be/IGN_5/wfs) publicado por el Instituto Geográfico Nacional (IGN). Se transforma a WGS84 para posteriormente desplegarlo más fácilmente en `leaflet`.

```{r lectura-distritos}
# Lectura, transformación y visualización de datos geoespaciales de distritos

# Lectura
distritos <-
  st_read(
    dsn = "datos/ign/delimitacion-territorial-administrativa/distritos.geojson",
    quiet = TRUE
  ) %>%
  st_transform(4326) # transformación a WGS84

# Transformación
distritos <-
  distritos %>%
  st_transform(5367) %>%
  st_simplify(dTolerance = 100) %>% # simplificación de geometrías
  st_transform(4326)

# Visualización en un mapa
plot(
  distritos$geometry,
  extent = st_bbox(c(xmin = -86.0, xmax = -82.3, ymin = 8.0, ymax = 11.3)),
  main = "Distritos de Costa Rica",
  axes = TRUE,
  graticule = TRUE
)
```

#### Casos positivos acumulados de covid en cantones de Costa Rica
Es un [archivo CSV con el acumulado de casos positivos de covid-19 en cada cantón](datos/ministerio-salud/covid/05_30_22_CSV_POSITIVOS.csv). Es publicado regularmente por el Ministerio de Salud en el sitio web [Situación Nacional COVID-19](https://geovision.uned.ac.cr/oges/).

```{r lectura-covid-positivos, message=FALSE, warning=FALSE}
# Lectura, transformación y visualización de casos positivos acumulados de covid-19 en cantones de Costa Rica

# Lectura
covid_positivos <-
  read_delim(file = "datos/ministerio-salud/covid/05_30_22_CSV_POSITIVOS.csv",
             locale = locale(encoding = "WINDOWS-1252"), # para desplegar correctamente acentos y otros caracteres
             col_select = c("cod_canton", "canton", "30/05/2022"))

# Transformación
covid_positivos <-
  covid_positivos %>%
  rename(positivos = '30/05/2022') # renombramiento de columna

# Visualización en una tabla
covid_positivos %>%
  arrange(desc(positivos)) %>%
  datatable(options = list(
    pageLength = 10,
    language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')
  ))
```

#### Delitos ocurridos en Costa Rica en el año 2021
Es un [archivo XLS con registros de delitos](datos/oij/estadisticas-policiales/estadisticaspoliciales2021.xls). Es publicado regularmente por el Organismo de Investigación Judicial (OIJ) en el sitio web [Datos abiertos del OIJ](https://sitiooij.poder-judicial.go.cr/index.php/ayuda/servicios-policiales/servicios-a-organizaciones/indice-de-transparencia-del-sector-publico-costarricense/datos-abiertos).

```{r lectura-delitos, message=FALSE, warning=FALSE}
# Lectura, transformación y visualización de delitos

# Lectura
delitos <-
  read_xls(path = "datos/oij/estadisticas-policiales/estadisticaspoliciales2021.xls")

# Visualización en una tabla
delitos %>%
  select(Delito, Fecha, Victima, Provincia, Canton, Distrito) %>%
  datatable(options = list(
    pageLength = 10,
    language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')
  ))
```

## Introducción
Se les llama atributos a los elementos de datos no espaciales o geométricos de un conjunto de datos geográficos. Estos datos pueden ser de tipos numéricos o textuales, entre otros. Un conjunto de datos vectoriales puede tener asociados varios campos de atributos, mientras que un conjunto de datos raster tiene solamente uno.

## Datos vectoriales
Las operaciones con atributos en datos vectoriales incluyen:

- Creación de subconjuntos (*subsetting*).  
- Agregación de datos (*aggregation*).  
- Unión de datos (*joining*). 

Seguidamente, se explicará como maneja estas operaciones el paquete `sf`.

## Manejo de datos de atributos con el paquete sf
Como se mencionó en capítulos anteriores, el paquete `sf` define una clase, llamada `sf`, la cual extiende la clase `data.frame` del paquete base de R. Los objetos de la clase `sf` tienen una fila (o *feature*) por cada observación y una columna por cada atributo. También tienen una columna especial para almacenar las geometrías (puntos, líneas, polígonos, etc.), la cual generalmente se denomina `geometry` o `geom`. Esto permite que sf utilice métodos (i.e. funciones) de la clase `data.frame`, tales como `plot()` y `summary()`, entre otros.

Además de `data.frame`, `sf` es compatible con clases como las del paquete [tibble](https://tibble.tidyverse.org/), las cuales pueden manipularse mediante los métodos de `dplyr`. Esto que permite un manejo *tidy* (i.e. ordenado, organizado) de los datos geoespaciales, de acuerdo con el enfoque de [Tidyverse](https://www.tidyverse.org/).

En la secciones siguientes, se explicará el manejo de datos de atributos tanto mediante funciones y operaciones del paquete base de R, como mediante Tidyverse.

### Funciones básicas para manejo de data frames y objetos sf
Las siguientes son algunas de las funciones disponibles para obtener información básica de un objeto sf.

```{r sf-funciones-basicas}
# Funciones básicas para manejo de objetos tipo data.frame y sf

# Clase de cantones
class(cantones)

# Dimensiones (cantidad de filas y de columnas)
dim(cantones)

# Cantidad de filas (i.e. observaciones)
nrow(cantones)

# Cantidad de columnas (i.e. variables)
ncol(cantones)

# Nombres de las columnas
names(cantones)

# Estructura del conjunto de datos
glimpse(cantones)
```

La función `st_drop_geometry()` remueve la columna de geometría de un objeto `sf`. Puede ser útil cuando, por ejemplo, solo se necesita trabajar con los atributos o cuando la columna con la geometría consume demasiados recursos del computador.

```{r st_drop_geometry}
# Ejemplos de uso de st_drop_geometry()

# Remoción de la columna de geometría
cantones_df <- st_drop_geometry(cantones)

# Nombres de las columnas (nótese que ya no está la columna de geometría)
names(cantones_df)

# Clase de df_cantones (nótese como no se muestra ya la clase sf)
class(cantones_df)

# Tamaño del conjunto de datos original (tipo sf)
print(object.size(cantones), units="Kb")

# Tamaño del conjunto de datos sin geometrías (tipo data.frame)
print(object.size(cantones_df), units="Kb")
```

Para algunas operaciones, también es posible ocultar la columna de geometría de un conjunto de datos (sin borrarla) mediante el argumento `drop = TRUE`.

```{r sf-drop}
# Ejemplos de uso del argumento drop

# Sin drop = TRUE
cantones[1:10, c("canton", "area")]

# Con drop = TRUE
cantones[1:10, c("canton", "area"), drop = TRUE]
```

### Creación de subconjuntos
Frecuentemente, es necesario extrer subconjuntos del conjunto de datos original, para facilidad de manejo y para atender requerimientos específicos de un análisis. En esta sección, se explican las diferentes opciones para creación de subconjuntos, tanto con el paquete base de R como con `dplyr`. En resumen, estas son las opciones:

- Con el paquete base:
  - La notación de `[]` y `$`
  - La función `subset()`
- Con el paquete `dplyr`:
  - La función `select()`
  - La función `slice()`
  - La función `filter()`

#### Notaciones y funciones del paquete base

##### La notación de `[]` y `$`
La notación de paréntesis cuadrados (`[]`) y el signo de dólar (`$`) permite crear subconjuntos con base en la posición de filas y de columnas, por medio de nombres de columnas y a través de la especificación de condiciones (i.e. expresiones lógicas).

```{r subconjuntos-notacion-base, message=FALSE, warning=FALSE, results='hide'}
# Ejemplos de uso de la notación []

# Subconjunto especificado por posiciones de filas
cantones[1:10, ]

# Subconjunto especificado por posiciones de columnas
cantones[, 8:10]

# Subconjunto especificado por nombres de columnas
cantones[, c("canton", "area", "provincia")]
```

Especificación mediante una condición (i.e. expresión lógica):

```{r subconjuntos-expresion-logica}
# Ejemplos de uso de la notación $

# Cantones de la provincia de Cartago
cantones[cantones$provincia == "Cartago", c("canton", "provincia"), drop = TRUE]
```

##### La función subset()
La función [subset()](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/subset) también retorna un subconjunto cuyos registros cumplen una condición.

```{r subset}
# Ejemplos de uso de subset()

# Cantones con área >= 2000 km2
subset(cantones[, c("canton", "area"), drop = TRUE],
       area >= 2000)
```

Los operadores lógicos y de comparación que pueden utilizarse en las condiciones de la función `subset()`, y en expresiones lógicas en general, se listan en la siguiente tabla:

```{r operadores-logicos, echo=FALSE}
knitr::kable(data.frame(
  c("==",      "!=",          ">, <",                 ">=, <=",                               "&, |, !"),
  c(
    "igual a",
    "distinto de",
    "mayor que, menor que",
    "mayor o igual que, menor o igual que",
    "Operadores lógicos: y, o, no"
  )
),
col.names = c("Operador", "Descripción"))
```

#### Métodos del paquete dplyr
Las funciones del paquete base de R son confiables y ampliamente usadas. Sin embargo, el enfoque más moderno de `dplyr` permite flujos de trabajo más intuitivos y es más rápido, debido a que se apoya en código escrito en el lenguaje C++. Esto es útil, por ejemplo, cuando se trabaja con conjuntos de datos grandes (_big data_) y cuando se necesita integración con bases de datos. Los principales métodos de `dplyr` para creación de subconjuntos son `select()`, `slice()` y `filter()`.

##### El método select()
`dplyr::select()` permite seleccionar y renombrar columnas de un conjunto de datos.

```{r dplyr-select}
# Ejemplos de uso de dplyr::select()

# Selección de columnas
cantones %>%
  dplyr::select(canton, provincia) # se especifica el nombre del paquete para evitar un conflicto con raster::select

# Selección y cambio de nombre de columnas
cantones %>%
  dplyr::select(canton, area_km2 = area, provincia)
```

##### El método slice()
`slice()` es el equivalente de `select()` para filas. Crea un subconjunto con base en las posiciones de las filas.

```{r slice, results='hide'}
# Ejemplos de uso de slice()

# Subconjunto especificado mediante un rango de filas
cantones %>%
  slice(1:10)
```

##### El método filter()
`filter()` es el equivalente en `dplyr` de la función `subset()` del paquete `base`. Retorna los registros que cumplen con una condición.

```{r filter}
# Androides de "La Guerra de las Galaxias"
starwars %>%
  filter(species == "Droid")
```

##### El operador pipe (%>%)
Los métodos del paquete `dplyr` (y otros) suelen ser utilizados conjuntamente con el [operador _pipe_ (%>%)](http://r4ds.had.co.nz/pipes.html), el cual posibilita el "encadenamiento" (*chaining*) de funciones: la salida de la función previa se convierte en el primer argumento de la siguiente función. En el siguiente ejemplo, el conjunto de datos [starwars](https://dplyr.tidyverse.org/reference/starwars.html) se pasa como entrada al método `filter()`, para filtrar los personajes humanos. Seguidamente, el resultado se pasa a `select()`, para seleccionar las columnas  `name`, `homeworld` y `species`. Finalmente, `slice()` reduce el resultado a las 10 primeras filas.

```{r funciones-encadenamiento}
# Encadenamiento de funciones mediante pipes (%>%)

starwars %>%
  filter(species == "Human") %>%
  dplyr::select(name, homeworld, species) %>%
  slice(1:10)
```

Una alternativa al uso de *pipes* es el "anidamiento" (*nesting*) de las funciones:

```{r funciones-anidamiento}
# Anidamiento de funciones
slice(
  dplyr::select(
    filter(
      starwars,
      species=="Human"
    ),
    name, homeworld, species
  ),
  1:10
)
```

**Ejercicio: mediante las funciones `select()` y `filter()` de `dplyr`, cree un nuevo objeto `sf` que contenga los cantones de Puntarenas y Guanacaste con área mayor o igual a 2000 km2. Incluya las columnas de provincia, cantón y área.**

### Agregación de datos
Las operaciones de agregación realizan cálculos (suma, promedio, etc.) a partir de la agrupación de valores de variables. En esta sección, se explican funciones de agregación contenidas en los paquetes  `stats`, `sf` y `dplyr`, las cuales son:

- Del paquete stats:
  - La función `aggregate()`
- Del paquete sf:
  - El método `aggregate()`  
- Del paquete dplyr:
  - El método `summarize()`
  
#### La función aggregate() de stats
La función `aggregate()` del paquete [stats](https://rdrr.io/r/#stats) aplica una función de agregación (ej. suma, promedio, mínimo, máximo) sobre una columna. El resultado es un objeto de tipo `data.frame`.

```{r aggregate-stats}
# Ejemplos de uso de stats::agregate()

# Suma de áreas de cantones por provincia
aggregate(
  data = cantones, 
  area ~ provincia, 
  FUN = sum, 
  na.rm = TRUE
)
```

#### El método aggregate() de sf
`aggregate()` es una [función genérica](https://adv-r.hadley.nz/s3.html#s3-methods), lo que significa que puede comportarse de manera diferente, dependiendo de los valores de entrada. El paquete `sf` también provee una versión de [aggregate()](https://r-spatial.github.io/sf/reference/aggregate.sf.html), la cual se activa cuando recibe un objeto  `sf`` y se usa el argumento  `by`. El resultado es un objeto de tipo `sf`.

```{r aggregate-sf}
# Ejemplos de uso de sf::agregate()

# Suma de áreas de cantones por provincia
aggregate(
  cantones["area"], 
  by = list(cantones$provincia), 
  FUN = sum, 
  na.rm = TRUE
)
```

#### El método `summarise()` de dplyr
`summarise()` es el equivalente de `aggregate()` en el paquete `dplyr`. Suele utilizarse conjuntamente con `group_by()`, que especifica la variable a agrupar.

```{r summarise}
# Ejemplos de uso de de summarise()

# Suma de áreas de cantones por provincia
cantones %>%
  group_by(provincia) %>%
  summarise(area_km2 = sum(area, na.rm = TRUE))
```

`summarize()` permite renombrar las variables, como se muestra seguidamente.

```{r summarize-renombramiento}
# Ejemplo de renombramiento de variables con summarise()

# Suma total de las áreas de cantones
cantones %>%
  summarize(area_km2 = sum(area, na.rm = TRUE),
            cantidad_cantones = n())
```

El siguiente ejemplo utiliza otras funciones del paquete `dplyr` para encontrar las tres provincias más grandes y sus respectivas áreas, con base en los datos disponibles en la capa de cantones.

```{r agregacion-ejemplo-dplyr}
# Área y cantidad de cantones de las tres provincias más grandes
cantones %>%
  st_drop_geometry() %>%  
  dplyr::select(area, provincia) %>%
  group_by(provincia) %>%
  summarise(area = sum(area, na.rm = TRUE),
            cantidad_cantones = n()) %>%
  arrange(desc(area)) %>%
  top_n(n = 3, wt = area)
```

**Ejercicio: mediante ```summarize()```, y otras funciones de dplyr, despliegue el área y la cantidad de cantones de las dos provincias más pequeñas.**

### Unión de datos
La combinación de datos ubicados en diferentes fuentes es una tarea común en análisis de información. Este tipo de operaciones se realizan con base en atributos que son comunes en los conjuntos de datos que se desea "unir" (*join*). El paquete `dplyr` proporciona varios [métodos para realizar uniones de datos](https://dplyr.tidyverse.org/reference/mutate-joins.html), entre los que se encuentran:

- `left_join()`: mantiene todas las filas del conjunto de datos del lado izquierdo y les agrega las columnas del conjunto de datos del lado derecho, en las filas en las que hay coincidencia.
- `inner_join()`: incluye las filas que coinciden en ambos conjuntos de datos.
- `right_join()`: mantiene todas las filas del conjunto de datos del lado derecho y agrega las columnas del conjunto de datos del lado izquierdo, en las filas en las que hay coincidencia.
- `full_join()`: incluye todas las filas de ambos conjuntos de datos.

Todos los tipos de *joins* requieren de una o varias columnas que sean comunes a ambos conjuntos de datos, llamadas *join keys*, en inglés. Esas columnas se especifican con el argumento `by`. Por ejemplo, `by = codigo`, si la columna común se llama `codigo` en ambos conjuntos de datos. Si tienen diferentes nombres, se utiliza un vector (ej. `by = c("codigo_1" = "codigo_2")`, en donde `codigo_1` es el nombre de la columna en el conjunto de datos de la izquierda y `codigo_2` en el de la derecha. Si hay columnas con nombres iguales en ambos conjuntos de datos, `by` utiliza esos nombres por defecto.

#### Ejemplos

##### Casos positivos acumulados de covid en cantones
En este caso, se unen los datos geoespaciales de cantones con los datos de casos positivos acumulados de covid-19 en los cantones de Costa Rica. La columna común (*join key*) se llama `cod_canton` en ambos conjuntos de datos y contiene el código de cantón asignado por el IGN.

```{r join-cantones-covid-positivos}
# Unión de los datos geoespaciales de cantones con los de casos positivos de covid. 
# Ambas tablas comparten la columna "cod_canton".
cantones_covid_positivos <-
  cantones %>%
  left_join(
    dplyr::select(covid_positivos, cod_canton, positivos), # el select() es para no llevar columnas innecesarias a la unión
    by = "cod_canton", # campo común para realizar la unión
    copy = FALSE, # para no copiar todos los campos del data frame derecho en el data frame izquierdo
    keep = FALSE # # para no copiar el campo de unión
  )
```

Con el data frame resultante del `join`, se generan [mapas de coropletas](https://es.wikipedia.org/wiki/Mapa_coropl%C3%A9tico) que muestran la cantidad de casos positivos de covid en los cantones. Para estos mapas, se crea un paleta de colores.

```{r colores-cantones-covid-positivos}
# Paleta de colores para los mapas
colores_cantones_covid_positivos <-
  colorNumeric(palette = "Reds",
               domain = cantones_covid_positivos$positivos,
               na.color = "transparent")
```

El resultado se muestra en un mapa generado con `plot()`.

```{r plot-cantones-covid-positivos}
# Visualización en un mapa generado con plot()
plot(
  cantones_covid_positivos["positivos"],
  extent = st_bbox(c(xmin = -86.0, xmax = -82.3, ymin = 8.0, ymax = 11.3)),
  col = colores_cantones_covid_positivos(cantones_covid_positivos$positivos),
  main = "Casos positivos acumulados de covid en cantones de Costa Rica",
  axes = TRUE,
  graticule = TRUE
)
```

Y en un mapa generado con `leaflet()`.

```{r leaflet-cantones-covid-positivos}
# Visualización en un mapa generado con leaflet()
leaflet() %>%
  setView(# centro y nivel inicial de acercamiento
    lng = -84.19452,
    lat = 9.572735,
    zoom = 7) %>%
  addTiles(group = "OpenStreetMap") %>% # capa base
  addPolygons(
    # capa de polígonos
    data = cantones_covid_positivos,
    fillColor = ~ colores_cantones_covid_positivos(cantones_covid_positivos$positivos),
    fillOpacity = 0.8,
    color = "black",
    stroke = TRUE,
    weight = 1.0,
    popup = paste(
      # ventana emergente
      paste(
        "<strong>Cantón:</strong>",
        cantones_covid_positivos$canton
      ),
      paste(
        "<strong>Casos:</strong>",
        cantones_covid_positivos$positivos
      ),
      sep = '<br/>'
    ),
    group = "Casos positivos acumulados de covid en cantones"
  ) %>%
  addLayersControl(
    # control de capas
    baseGroups = c("OpenStreetMap"),
    overlayGroups = c("Casos positivos acumulados de covid en cantones")
  ) %>%
  addLegend(
    # leyenda
    position = "bottomleft",
    pal = colores_cantones_covid_positivos,
    values = cantones_covid_positivos$positivos,
    group = "Casos positivos acumulados de covid en cantones",
    title = "Cantidad de casos"
  )
```

##### Delitos
En este ejemplo, se unen los datos geoespaciales de provincias, cantones y distritos con los datos de delitos ocurridos en Costa Rica en el año 2021. El data frame de delitos tiene columnas correspondientes al nombre de la provincia, cantón y distrito en donde ocurrió cada uno. Sin embargo, por exactitud y eficiencia, se prefieren los códigos del IGN a los nombres, por lo que se incluyen a través de uniones con los conjuntos de datos de provincias, cantones y distritos.

###### En provincias
Se crea el campo `provincia_normalizado`, en `provincias` y en `delitos`, correspondiente al nombre de la provincia, pero en minúsculas, sin acentos, ni eñes ni otros caracteres especiales o propios del idioma español (ej. "san jose", en lugar de "San José"). Este campo será más fácil de usar para unir las tablas, ya que evitará dificultades por diferencias en mayúsculas, minúsculas, tildes y otras.

```{r normalizacion-provincias}
# Normalización de los nombres de provincias

# En el data frame de provincias
provincias <-
  provincias %>%
  mutate(provincia_normalizado = tolower(stri_trans_general(provincia, id = "Latin-ASCII")))

# En el data frame de delitos
delitos <-
  delitos %>%
  mutate(provincia_normalizado = tolower(stri_trans_general(Provincia, id = "Latin-ASCII")))
```

Mediante un *join* de los nombres normalizados, se agrega el código de la provincia a `delitos`.

```{r join-delitos-provincias}
# Unión del código de provincia a delitos
delitos <-
  delitos %>%
  left_join(
    dplyr::select(
      st_drop_geometry(provincias),
      cod_provin,
      provincia_normalizado
    ),
    by = "provincia_normalizado",
    copy = FALSE,
    keep = FALSE
  )
```

Se cuenta la cantidad de registros por provincia y se une al data frame `provincias`.

```{r conteo-delitos-x-provincia}
# Conteo de registros por código de provincia
delitos_x_provincia <-
  delitos %>%
  count(cod_provin, name = "delitos")

# Unión de cantidad de delitos por provincia a provincias
provincias_delitos <-
  provincias %>%
  left_join(
    delitos_x_provincia,
    by = "cod_provin",
    copy = FALSE,
    keep = FALSE
  )

# Visualización en formato de tabla
provincias_delitos %>%
  st_drop_geometry() %>%
  select(provincia, delitos) %>%
  arrange(desc(delitos)) %>%
  datatable(options = list(
    pageLength = 10,
    language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')
  ))
```

Paleta de colores para los mapas de coropletas.

```{r colores-provincias-delitos}
# Paleta de colores para los mapas
colores_provincias_delitos <-
  colorNumeric(palette = "Reds",
               domain = provincias_delitos$delitos,
               na.color = "transparent")
```

Mapa de coropletas generado con `plot()`.

```{r plot-provincias-delitos}
# Visualización en un mapa generado con plot()
plot(
  provincias_delitos["delitos"],
  extent = st_bbox(c(xmin = -86.0, xmax = -82.3, ymin = 8.0, ymax = 11.3)),
  col = colores_provincias_delitos(provincias_delitos$delitos),
  main = "Cantidad de delitos ocurridos en 2021 en provincias de Costa Rica",
  axes = TRUE,
  graticule = TRUE
)
```

Mapa de coropletas generado con `leaflet()`.

```{r leaflet-provincias-delitos}
# Mapa leaflet de delitos en provincias
leaflet() %>%
  setView(# centro y nivel inicial de acercamiento
    lng = -84.19452,
    lat = 9.572735,
    zoom = 7) %>%
  addTiles(group = "OpenStreetMap") %>% # capa base
  addPolygons(
    # capa de polígonos
    data = provincias_delitos,
    fillColor = ~ colores_provincias_delitos(provincias_delitos$delitos),
    fillOpacity = 0.8,
    color = "black",
    stroke = TRUE,
    weight = 1.0,
    popup = paste(
      # ventana emergente
      paste(
        "<strong>Provincia:</strong>",
        provincias_delitos$provincia
      ),
      paste(
        "<strong>Delitos:</strong>",
        provincias_delitos$delitos
      ),
      sep = '<br/>'
    ),
    group = "Delitos en provincias"
  ) %>%
  addLayersControl(
    # control de capas
    baseGroups = c("OpenStreetMap"),
    overlayGroups = c("Delitos en provincias")
  ) %>%
  addLegend(
    # leyenda
    position = "bottomleft",
    pal = colores_provincias_delitos,
    values = provincias_delitos$delitos,
    group = "Delitos",
    title = "Cantidad de delitos"
  )
```

###### En cantones
Primero, se corrigen algunos nombres de cantones en `delitos`, con el fin de que sean iguales a los de `cantones`, el conjunto de datos oficial del IGN.

Se crea el campo `canton_normalizado`, en `cantones` y en `delitos`, correspondiente al nombre del cantón, en minúscula y sin acentos ni caracteres especiales.

```{r normalizacion-cantones}
# Normalización de los nombres de cantones

# En el data frame de cantones
cantones <-
  cantones %>%
  mutate(canton_normalizado = tolower(stri_trans_general(canton, id = "Latin-ASCII")))

# En el data frame de delitos
delitos <-
  delitos %>%
  mutate(canton_normalizado = tolower(stri_trans_general(Canton, id = "Latin-ASCII")))
```

Luego, mediante un `join`, se obtienen los nombres de cantones en `delitos` que no están en `cantones`.

```{r cantones-no-coincidentes-delitos-cantones}
delitos %>%
  left_join(
    dplyr::select(st_drop_geometry(cantones),
                  canton_normalizado, cod_canton),
    by = "canton_normalizado",
    copy = FALSE,
    keep = FALSE
  ) %>%
  filter(is.na(cod_canton) & canton_normalizado != "desconocido") %>% # los cod_canton = NA son los que no están en el data frame de cantones
  distinct(canton_normalizado) # se despliegan solo los nombres de cantones diferentes
```

Los anteriores, son los nombres de cantones en `delitos` sin coincidencia en `cantones`. En el siguiente bloque de código, se corrigen esos nombres de acuerdo con los de `cantones`.

```{r curacion-delitos-cantones}
# Corrección de nombres de cantones en delitos
delitos <-
  delitos %>%
  mutate(Canton = if_else(Canton == "LEON CORTES", "LEON CORTES CASTRO", Canton)) %>%
  mutate(Canton = if_else(Canton == "VASQUEZ DE CORONADO", "VAZQUEZ DE CORONADO", Canton))

# Se realiza nuevamente esta operación para reflejar los cambios en los nombres de cantones
delitos <-
  delitos %>%
  mutate(canton_normalizado = tolower(stri_trans_general(Canton, id = "Latin-ASCII")))

# Revisión
delitos %>%
  left_join(
    dplyr::select(st_drop_geometry(cantones),
                  canton_normalizado, cod_canton),
    by = "canton_normalizado",
    copy = FALSE,
    keep = FALSE
  ) %>%
  filter(is.na(cod_canton) & canton_normalizado != "desconocido") %>% # los cod_canton = NA son los que no están en el data frame de cantones
  distinct(canton_normalizado) # se despliegan solo los nombres de cantones diferentes
```

Mediante un *join* de los nombres normalizados, se agrega el código del cantón a `delitos`.

```{r join-delitos-cantones}
# Unión del código de cantón a delitos
delitos <-
  delitos %>%
  left_join(
    dplyr::select(
      st_drop_geometry(cantones),
      cod_canton,
      canton_normalizado
    ),
    by = "canton_normalizado",
    copy = FALSE,
    keep = FALSE
  )
```

Se cuenta la cantidad de registros por cantón y se une al data frame `cantones`.

```{r conteo-delitos-x-canton}
# Conteo de registros por código de cantón
delitos_x_canton <-
  delitos %>%
  count(cod_canton, name = "delitos")

# Unión de cantidad de delitos por cantón a cantones
cantones_delitos <-
  cantones %>%
  left_join(
    delitos_x_canton,
    by = "cod_canton",
    copy = FALSE,
    keep = FALSE
  )

# Visualización en formato de tabla
cantones_delitos %>%
  st_drop_geometry() %>%
  select(canton, delitos) %>%
  arrange(desc(delitos)) %>%
  datatable(options = list(
    pageLength = 10,
    language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')
  ))
```

Paleta de colores para los mapas de coropletas.

```{r colores-cantones-delitos}
# Paleta de colores para los mapas
colores_cantones_delitos <-
  colorNumeric(palette = "Reds",
               domain = cantones_delitos$delitos,
               na.color = "transparent")
```

Mapa de coropletas generado con `plot()`.

```{r plot-cantones-delitos}
# Visualización en un mapa generado con plot()
plot(
  cantones_delitos["delitos"],
  extent = st_bbox(c(xmin = -86.0, xmax = -82.3, ymin = 8.0, ymax = 11.3)),
  col = colores_cantones_delitos(cantones_delitos$delitos),
  main = "Cantidad de delitos ocurridos en 2021 en cantones de Costa Rica",
  axes = TRUE,
  graticule = TRUE
)
```

Mapa de coropletas generado con `leaflet()`.

```{r leaflet-cantones-delitos}
# Mapa leaflet de delitos en cantones
leaflet() %>%
  setView(# centro y nivel inicial de acercamiento
    lng = -84.19452,
    lat = 9.572735,
    zoom = 7) %>%
  addTiles(group = "OpenStreetMap") %>% # capa base
  addPolygons(
    # capa de polígonos
    data = cantones_delitos,
    fillColor = ~ colores_cantones_delitos(cantones_delitos$delitos),
    fillOpacity = 0.8,
    color = "black",
    stroke = TRUE,
    weight = 1.0,
    popup = paste(
      # ventana emergente
      paste(
        "<strong>Cantón:</strong>",
        cantones_delitos$canton
      ),
      paste(
        "<strong>Delitos:</strong>",
        cantones_delitos$delitos
      ),
      sep = '<br/>'
    ),
    group = "Delitos en cantones"
  ) %>%
  addLayersControl(
    # control de capas
    baseGroups = c("OpenStreetMap"),
    overlayGroups = c("Delitos en cantones")
  ) %>%
  addLegend(
    # leyenda
    position = "bottomleft",
    pal = colores_cantones_delitos,
    values = cantones_delitos$delitos,
    group = "Delitos",
    title = "Cantidad de delitos"
  )
```

###### En distritos
Primero, se corrigen algunos nombres de distritos en `delitos`, con el fin de que sean iguales a los de `distritos`, el conjunto de datos oficial del IGN.

Se crea el campo `distrito_normalizado`, en `distritos` y en `delitos`, el cual corresponde al nombre del distrito, en minúscula y sin acentos ni caracteres especiales. El nombre de un distrito debe consultarse conjuntamente con el código del cantón (`cod_canton`), debido a que el nombre del distrito solamente es único si se asocia con su cantón. Por ejemplo, existen varios distritos llamados "Concepción", pero pertenecientes a diferentes cantones.

```{r normalizacion-distritos}
# Normalización de los nombres de distritos

# En el data frame de distritos
distritos <-
  distritos %>%
  mutate(distrito_normalizado = tolower(stri_trans_general(distrito, id = "Latin-ASCII")))

# En el data frame de delitos
delitos <-
  delitos %>%
  mutate(distrito_normalizado = tolower(stri_trans_general(Distrito, id = "Latin-ASCII")))
```

Luego, mediante un `join`, se obtienen los nombres de cantones en `delitos` que no están en `distritos`.

```{r distritos-no-coincidentes-delitos-distritos}
delitos %>%
  left_join(
    dplyr::select(st_drop_geometry(distritos),
                  codigo_dta, 
                  cod_canton, 
                  distrito_normalizado
    ),
    by = c("cod_canton" = "cod_canton", "distrito_normalizado" = "distrito_normalizado"),
    copy = FALSE,
    keep = FALSE
  ) %>%
  filter(is.na(codigo_dta) & distrito_normalizado != "desconocido") %>% # los cod_dta = NA son los que no están en el data frame de distritos
  distinct(cod_canton, Canton, distrito_normalizado) %>% # se despliegan solo los nombres diferentes de distritos (tomando en cuenta el cantón)
  print(n = Inf)
```

Los anteriores, son los nombres de cantones en `delitos` sin coincidencia en `distritos`. En el siguiente bloque de código, se corrigen esos nombres de acuerdo con los de `distritos`.

```{r curacion-delitos-distritos}
# Corrección de nombres de distritos en el data frame de delitos

delitos <-
  delitos %>%
  mutate(Distrito = if_else(cod_canton == 703 & Distrito == "CAIRO", "EL CAIRO", Distrito)) %>%
  mutate(Distrito = if_else(cod_canton == 210 & Distrito == "FORTUNA", "LA FORTUNA", Distrito)) %>%
  mutate(Distrito = if_else(cod_canton == 410 & Distrito == "HORQUETAS", "LAS HORQUETAS", Distrito)) %>%
  mutate(Distrito = if_else(cod_canton == 119 & Distrito == "GENERAL", "EL GENERAL", Distrito)) %>%
  mutate(Distrito = if_else(cod_canton == 402 & Distrito == "SAN JOSE DE LA MONTA?A", "SAN JOSE DE LA MONTANA", Distrito)) %>%
  mutate(Distrito = if_else(cod_canton == 602 & Distrito == "MACACOMA", "MACACONA", Distrito)) %>%
  mutate(Distrito = if_else(cod_canton == 301 & Distrito == "SAN FRANCISCO", "AGUACALIENTE O SAN FRANCISCO", Distrito)) %>%
  mutate(Distrito = if_else(cod_canton == 209 & Distrito == "CEIBA", "LA CEIBA", Distrito)) %>%
  mutate(Distrito = if_else(cod_canton == 605 & Distrito == "CORTES", "PUERTO CORTES", Distrito)) %>%
  mutate(Distrito = if_else(cod_canton == 201 & Distrito == "LA GARITA", "GARITA", Distrito))
# TODO: agregar los cambios restantes...


# Se realiza nuevamente esta operación para reflejar los cambios en los nombres de distritos
delitos <-
  delitos %>%
  mutate(distrito_normalizado = tolower(stri_trans_general(Distrito, id = "Latin-ASCII")))

# Revisión
delitos %>%
  left_join(
    dplyr::select(st_drop_geometry(distritos),
                  codigo_dta, 
                  cod_canton, 
                  distrito_normalizado
    ),
    by = c("cod_canton" = "cod_canton", "distrito_normalizado" = "distrito_normalizado"),
    copy = FALSE,
    keep = FALSE
  ) %>%
  filter(is.na(codigo_dta) & distrito_normalizado != "desconocido") %>% # los cod_dta = NA son los que no están en el data frame de distritos
  distinct(cod_canton, Canton, distrito_normalizado) %>% # se despliegan solo los nombres diferentes de distritos (tomando en cuenta el cantón)
  print(n = Inf)
```

Mediante un *join* de los nombres normalizados, se agrega el código del distrito (`codigo_dta`) a `delitos`.

```{r join-delitos-distritos}
# Unión del código de distrito a delitos
delitos <-
  delitos %>%
  left_join(
    dplyr::select(
      st_drop_geometry(distritos),
      codigo_dta,
      cod_canton,
      distrito_normalizado
    ),
    by = c("cod_canton" = "cod_canton", "distrito_normalizado" = "distrito_normalizado"),
    copy = FALSE,
    keep = FALSE
  )
```

Se cuenta la cantidad de delitos por distrito y se une al data frame `distritos`.

```{r conteo-delitos-x-distrito}
# Conteo de delitos por código de distrito
delitos_x_distrito <-
  delitos %>%
  count(codigo_dta, name = "delitos")

# Unión de cantidad de delitos por distrito a distritos
distritos_delitos <-
  distritos %>%
  left_join(
    delitos_x_distrito,
    by = "codigo_dta",
    copy = FALSE,
    keep = FALSE
  )

# Visualización en formato de tabla
distritos_delitos %>%
  st_drop_geometry() %>%
  select(provincia, canton, codigo_dta, distrito, delitos) %>%
  arrange(desc(delitos)) %>%
  datatable(options = list(
    pageLength = 10,
    language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')
  ))
```

Paleta de colores para los mapas de coropletas.

```{r colores-distritos-delitos}
# Paleta de colores para los mapas
colores_distritos_delitos <-
  colorNumeric(palette = "Reds",
               domain = distritos_delitos$delitos,
               na.color = "transparent")
```

Mapa de coropletas generado con `plot()`.

```{r plot-distritos-delitos}
# Visualización en un mapa generado con plot()
plot(
  distritos_delitos["delitos"],
  extent = st_bbox(c(xmin = -86.0, xmax = -82.3, ymin = 8.0, ymax = 11.3)),
  col = colores_distritos_delitos(distritos_delitos$delitos),
  main = "Cantidad de delitos ocurridos en 2021 en distritos de Costa Rica",
  axes = TRUE,
  graticule = TRUE
)
```

Mapa de coropletas generado con `leaflet()`.

```{r leaflet-distritos-delitos}
# Mapa leaflet de delitos en distritos
leaflet() %>%
  setView(# centro y nivel inicial de acercamiento
    lng = -84.19452,
    lat = 9.572735,
    zoom = 7) %>%
  addTiles(group = "OpenStreetMap") %>% # capa base
  addPolygons(
    # capa de polígonos
    data = distritos_delitos,
    fillColor = ~ colores_distritos_delitos(distritos_delitos$delitos),
    fillOpacity = 0.8,
    color = "black",
    stroke = TRUE,
    weight = 1.0,
    popup = paste(
      # ventana emergente
      paste(
        "<strong>Cantón:</strong>",
        distritos_delitos$canton
      ),
      paste(
        "<strong>Distrito:</strong>",
        distritos_delitos$distrito
      ),
      paste(
        "<strong>Delitos:</strong>",
        cantones_delitos$delitos
      ),
      sep = '<br/>'
    ),
    group = "Delitos en distritos"
  ) %>%
  addLayersControl(
    # control de capas
    baseGroups = c("OpenStreetMap"),
    overlayGroups = c("Delitos en distritos")
  ) %>%
  addLegend(
    # leyenda
    position = "bottomleft",
    pal = colores_distritos_delitos,
    values = distritos_delitos$delitos,
    group = "Delitos",
    title = "Cantidad de delitos"
  )
```

## Datos raster
Las operaciones con atributos en datos raster incluyen:

- Creación de subconjuntos (_subsetting_).  
- Resumen de información (_summarizing_).  

Seguidamente, se explicará como maneja estas operaciones el paquete `terra`.

## Manejo de datos de atributos con el paquete terra
### Funciones básicas para manejo de objetos SpatRaster
El siguiente bloque de código crea y mapea un objeto ```SpatRaster``` llamado ```elevacion```.

```{r rast-creacion-1}
# Creación de un objeto SpatRaster
elevacion <- rast(
  nrows = 6,
  ncols = 6,
  resolution = 0.5,
  xmin = -1.5,
  xmax = 1.5,
  ymin = -1.5,
  ymax = 1.5,
  vals = 1:36
)

# Mapeo
plot(elevacion)
```

Los objetos `SpatRaster` también pueden contener valores categóricos de tipo `logical` o `factor`. El siguiente bloque de código crea y mapea un objeto `SpatRaster` con información sobre tipos de granos (i.e. partículas) de una porción de suelo.

```{r rast-creacion-2, collapse=TRUE}
# Tipos de granos
grano_tipo <- c("arcilla", "limo", "arena")

# Lista de granos generada aleatoriamente
lista_granos <- sample(grano_tipo, 36, replace = TRUE)
lista_granos

# Factor de tipos de granos
grano_factor <- factor(lista_granos, levels = grano_tipo)

# Objeto SpatRaster de tipos de granos
grano <- rast(
  nrows = 6,
  ncols = 6,
  resolution = 0.5,
  xmin = -1.5,
  xmax = 1.5,
  ymin = -1.5,
  ymax = 1.5,
  vals = grano_factor
)

# Mapeo
plot(grano)
```

Ambos objetos pueden guardados en el disco con la función `writeRaster()`.

```{r writeraster, eval=FALSE}
# Especificación del directorio de trabajo (debe ser una ruta existente)
setwd("/home/mfvargas")

# Escritura de los objetos raster
writeRaster(elevacion, "elevacion.asc")
writeRaster(grano, "grano.asc")
```

La función `levels()` puede utilizarse para consultar la *Raster Attribute Table* (RAT) de un objeto `SpatRaster`, la cual contiene información sobre sus factores y niveles. También puede emplearse para asignar nuevos factores a un objeto.

```{r rat, collapse=TRUE}
# Consulta de la RAT
levels(grano)

# Nuevo factor
levels(grano) = data.frame(value = c(0, 1, 2), wetness = c("mojado", "húmedo", "seco"))

# Consulta de la RAT
levels(grano)
```

Los raster categóricos también pueden almacenar información relacionada con los colores de cada valor, mediante una tabla. La tabla de colores es un data frame con tres (*red*, *green*, *blue*) o cuatro (*alpha*) columnas, en la que cada fila corresponde a un valor. Las tablas de colores en `terra` pueden consultarse o modificarse con la función `coltab()`.

### Creación de subconjuntos
Los subconjuntos se crean en objetos `SpatRaster` con el operador `[`, el cual acepta varios tipos de entradas.

- Índices de filas y columnas.
- ID de celdas.
- Coordenadas.
- Otros objetos espaciales.

En este capítulo, solo se tratarán las dos primeras opciones. Las restantes se cubrirán en las secciones sobre operaciones espaciales.

Las dos primeras opciones se ilustran en el siguiente bloque de código, en el que se consulta la celda (también llamada pixel) ubicada en la esquina superior izquierda del objeto de elevación.

```{r indices-id-celdas}
# Celda en la fila 1, columna 1
elevacion[1, 1]
elevacion[]

# Celda con ID = 1
elevacion[1]
```

La totalidad de los valores de un objeto `SpatRaster` puede consultarse con las función `values()`.

```{r values, collapse=TRUE}
# Valores de un objeto raster
values(elevacion)
```

El operador `[` también puede utilizarse para modificar los valores de las celdas un objeto `SpatRaster`.

```{r modificacion-celdas}
# Modificación de una celda
elevacion[1, 1] = 0

# Consulta de todos los valores del raster (equivalente a values())
elevacion[]

# Modificación de rangos de celdas
elevacion[1, c(1, 2)] = 0

elevacion[1, 1:6] = 0
elevacion[2, 1:6] = 10
elevacion[3, 1:6] = 15
elevacion[4, 1:6] = 15
elevacion[5, 1:6] = 20
elevacion[6, 1:6] = 35

# Consulta de los valores
elevacion[]
```

### Resumen y sumarización de información
La escritura del nombre de un objeto `SpatRaster` en la consola imprime información general sobre ese objeto. La función `summary()` proporciona algunas estadísticas descriptivas (mínimo, máximo, cuartiles, etc.). Otras estadísticas pueden ser calculadas con la función  `global()`.

```{r global, collapse=TRUE}
# Información general
elevacion

# Resumen de un raster de una capa
summary(elevacion)

# Desviación estándar
global(elevacion, sd)
```

Adicionalmente, la función `freq()` retorna la tabla de frecuencias de valores categóricos.

```{r freq}
# Tabla de frecuencias
freq(grano)
```

Las estadísticas pueden ser visualizadas con funciones como `hist()` y `density()`.

```{r hist-density}
# Histograma
hist(elevacion)

# Densidad
density(elevacion)
```