[{"path":"index.html","id":"bienvenida","chapter":"Bienvenida","heading":"Bienvenida","text":"Este es un curso introductorio al procesamiento de datos geográficos mediante el lenguaje de programación R. Se imparte en la Escuela de Geografía de la Universidad de Costa Rica.Se estudian los fundamentos de R, sus bibliotecas geoespaciales y sus capacidades para generar gráficos estadísticos. También se utilizan herramientas para facilitar la reproducibilidad de los procedimientos y su comunicación través de la Internet y otros medios.El enfoque del curso es teórico-práctico, con lecciones teóricas combinadas con ejercicios de programación en los cuales los estudiantes aplican en diversos escenarios de procesamiento de datos los conocimientos y habilidades aprendidas. se requiere de experiencia previa en programación de computadoras.Este sitio web corresponde al curso impartido durante el primer ciclo lectivo de 2022. Para consultar las versiones de otros ciclos lectivos, puede visitar el sitio web general del curso.Información de contactoSi tiene alguna pregunta o comentario sobre este curso, por favor contacte :Manuel Vargas - manuel.vargas_d@ucr.ac.cr\nProfesor\nUniversidad de Costa Rica,\nCiudad Universitaria Rodrigo Facio,\nSan Pedro de Montes de Oca,\nCosta Rica.Los contenidos de este curso, menos que se especifique de otra forma, se comparten mediante una licencia de Creative Commons Reconocimiento-CompartirIgual 4.0 Internacional.","code":""},{"path":"programa-del-curso.html","id":"programa-del-curso","chapter":"Programa del curso","heading":"Programa del curso","text":"Programa del grupo 001Programa del grupo 002","code":""},{"path":"pensamiento-computacional.html","id":"pensamiento-computacional","chapter":"1 Pensamiento computacional","heading":"1 Pensamiento computacional","text":"","code":""},{"path":"pensamiento-computacional.html","id":"resumen","chapter":"1 Pensamiento computacional","heading":"1.1 Resumen","text":"El pensamiento computacional es un enfoque para la resolución de problemas basado en conceptos y métodos de las ciencias de la computación. Los principios fundamentales del pensamiento computacional son:Descomposición: división de un problema en subproblemas más pequeños.Reconocimiento de patrones: búsqueda de similitudes en los problemas.Abstracción: identificación de la información que se necesita y filtrado de la que se necesita para resolver un problema.Algoritmos: descripción, paso por paso, de la solución un problema.","code":""},{"path":"pensamiento-computacional.html","id":"diapositivas","chapter":"1 Pensamiento computacional","heading":"1.2 Diapositivas","text":"Introducción al pensamiento computacional (diapositivas)","code":""},{"path":"pensamiento-computacional.html","id":"recursos-de-interés","chapter":"1 Pensamiento computacional","heading":"1.3 Recursos de interés","text":"Harvard University. (2022). CS50’s Introduction Computer Science. EdX. https://www.edx.org/course/introduction-computer-science-harvardx-cs50xWing, J. M. (2006). Computational thinking. Communications ACM, 49(3), 33-35. https://doi.org/10.1145/1118178.1118215. Disponible en https://www.cs.cmu.edu/~15110-s13/Wing06-ct.pdf.","code":""},{"path":"arquitectura-de-computadoras-y-lenguajes-de-programación.html","id":"arquitectura-de-computadoras-y-lenguajes-de-programación","chapter":"2 Arquitectura de computadoras y lenguajes de programación","heading":"2 Arquitectura de computadoras y lenguajes de programación","text":"","code":""},{"path":"arquitectura-de-computadoras-y-lenguajes-de-programación.html","id":"resumen-1","chapter":"2 Arquitectura de computadoras y lenguajes de programación","heading":"2.1 Resumen","text":"Las computadoras modernas están construídas con base en circuitos integrados (CI), también llamados chips o microchips. Los CI procesan información digital (que usa valores discretos), la cual generalmente es binaria (.e. de dos valores). Los CI de una computadora procesan dos estados correspondientes dos niveles de tensión eléctrica: alto y bajo. Estos estados se representan con 0 y 1. Esto facilita la aplicación de la lógica binaria y de la aritmética binaria.Durante el período entre las guerras mundiales, Allan Turing desarrolló la máquina de Turing, un dispositivo teórico que manipula símbolos de una cinta de acuerdo con una tabla de reglas. La máquina de Turing simula el funcionamiento de un algoritmo y los conceptos de entrada, procesamiento y salida. En 1945, John von Neumann propuso un concepto conocido como programa almacenado, en el cual los datos y los programas se almacenan en una estructura llamada memoria, separada del hardware que ejecuta las instrucciones. Este modelo permite que las computadoras sean más fáciles de reprogramar y es conocido actualmente como arquitectura de von Neumann.El lenguaje máquina es un conjunto de instrucciones binarias interpretables por un CPU. Las instrucciones representan acciones ser ejecutadas por la computadora. Cada CPU tiene su propio lenguaje máquina. Un programa consiste de una secuencia de instrucciones en lenguaje máquina.Debido que programar una computadora en lenguaje máquina es excesivamente lento y complicado, en la década de 1950 comenzaron crearse lenguajes de programación que, en lugar de unos y ceros, consisten de instrucciones formadas por palabras, usualmente en idioma inglés. Existe una gran variedad de lenguajes de programación que han sido creados con diversos fines: científicos, comerciales, educacionales, etc.","code":""},{"path":"arquitectura-de-computadoras-y-lenguajes-de-programación.html","id":"diapositivas-1","chapter":"2 Arquitectura de computadoras y lenguajes de programación","heading":"2.2 Diapositivas","text":"Arquitectura de computadoras y lenguajes de programación (diapositivas)","code":""},{"path":"interacción-humano-computadora.html","id":"interacción-humano-computadora","chapter":"3 Interacción humano-computadora","heading":"3 Interacción humano-computadora","text":"","code":""},{"path":"interacción-humano-computadora.html","id":"resumen-2","chapter":"3 Interacción humano-computadora","heading":"3.1 Resumen","text":"La interacción humano-computadora (IHC) es un área de investigación dedicada al diseño y uso de la tecnología computacional. Esta interacción se realiza través de interfaces entre personas (usuarios) y computadoras. La IHC se sitúa en la intersección de varias disciplinas que incluyen ciencias de la computación, ciencias de la conducta, diseño y estudios de medios, entre otras.La IHC enfatiza que, diferencia de otras máquinas y herramientas con usos más limitados, las computadoras tienen aplicaciones muy diversas que implican un “diálogo” más complejo con los usuarios.","code":""},{"path":"interacción-humano-computadora.html","id":"interfaces-de-usuario","chapter":"3 Interacción humano-computadora","heading":"3.2 Interfaces de usuario","text":"La interfaz de usuario es el medio con el que el usuario puede comunicarse con una computadora (o, en general, con cualquier máquina o dispositivo), y comprende todos las formas de interacción entre esta y el usuario. Idealmente, las interfaces de usuario se diseñan para que sean fáciles de entender y de utilizar.Las interfaces de usuario pueden clasificarse en tres tipos: interfaces de línea de comandos (CLI, del inglés, command-line interface), interfaces gráficas de usuario (GUI, del inglés, graphical user interface) e interfaces naturales de usuario (NUI, del inglés, natural user interface).","code":""},{"path":"interacción-humano-computadora.html","id":"interfaces-de-línea-de-comandos","chapter":"3 Interacción humano-computadora","heading":"3.2.1 Interfaces de línea de comandos","text":"Las interfaces de línea de comandos (CLI) permiten los usuarios dar indicaciones la computadora por medio de líneas de texto correspondientes comandos o instrucciones (ej. al sistema operativo) (vea la figura 3.1). Los comandos pueden introducirse interactivamente en algún tipo de entrada de texto (ej. el prompt de un sistema operativo) o, de manera más automatizada, través de un archivo (ej. un script).\nFigure 3.1: Terminal (CLI) del sistema operativo Ubuntu (Linux).\nEste tipo de interfaz existe casi desde los inicios de la computación y es superada en antigüedad solo por las tarjetas perforadas y otros mecanismos similares.Las CLI tienen la ventaja de que facilitan el desarrollo de procedimientos reproducibles y repetibles. Por otro lado, puede ser más complejas, especialmente para usuarios experimentados.","code":""},{"path":"interacción-humano-computadora.html","id":"interfaces-gráficas-de-usuario","chapter":"3 Interacción humano-computadora","heading":"3.2.2 Interfaces gráficas de usuario","text":"Las interfaces gráficas de usuario (GUI) utilizan imágenes y otros objetos gráficos (ej. iconos) para representar la información y las acciones disponibles en la interfaz. Surgieron como una evolución de las CLI. Por ejemplo, muchos sistemas operativos desarrollaron primero sus CLI y luego GUI que permiten realizar acciones equivalentes los comandos de las CLI. La figura 3.2 muestra la interfaz gráfica del sistema operativo Ubuntu (Linux).\nFigure 3.2: Interfaz gráfica GNOME del sistema operativo Ubuntu (Linux).\nComo un precursor de las actuales GUI, suele mencionarse una interfaz de hipervículos desarrollada en el Stanford Research Institute, en la década de 1960 (se recomienda ver Mother Demos, presented Douglas Engelbart (1968)). Este concepto fue ampliado y trasladado un entorno gráfico por los investigadores del Xerox PARC, en Palo Alto. Ahí se introdujeron conceptos como ventanas, casillas de verificación (checkboxes), botones de radio, menús y puntero del ratón. La interfaz fue implementada comercialmente en el computador Xerox Star 8010, en 1981.Las GUI son más amigables e intuitivas que las CLI, pero también pueden ser menos versátiles y menos aptas para reproducir procedimientos.","code":""},{"path":"interacción-humano-computadora.html","id":"interfaces-naturales-de-usuario","chapter":"3 Interacción humano-computadora","heading":"3.2.3 Interfaces naturales de usuario","text":"En las interfaces naturales de usuario (NUI), este interactúa con la computadora sin utilizar dispositivos como el ratón o el teclado, sino través de movimientos, gestos o la voz. Las NUI requieren que el usuario aprenda el uso de nuevas tecnologías, ya que puede utilizar medios ya conocidos.","code":""},{"path":"interacción-humano-computadora.html","id":"recursos-de-interés-1","chapter":"3 Interacción humano-computadora","heading":"3.3 Recursos de interés","text":"Marcel. (2012). Mother Demos, presented Douglas Engelbart (1968). https://www.youtube.com/watch?v=yJDv-zdhzMY","code":""},{"path":"ejemplo-de-interfaz-de-línea-de-comandos---gdalogr-biblioteca-para-lectura-y-escritura-de-datos-geoespaciales.html","id":"ejemplo-de-interfaz-de-línea-de-comandos---gdalogr-biblioteca-para-lectura-y-escritura-de-datos-geoespaciales","chapter":"4 Ejemplo de interfaz de línea de comandos - GDAL/OGR: biblioteca para lectura y escritura de datos geoespaciales","heading":"4 Ejemplo de interfaz de línea de comandos - GDAL/OGR: biblioteca para lectura y escritura de datos geoespaciales","text":"","code":""},{"path":"ejemplo-de-interfaz-de-línea-de-comandos---gdalogr-biblioteca-para-lectura-y-escritura-de-datos-geoespaciales.html","id":"resumen-3","chapter":"4 Ejemplo de interfaz de línea de comandos - GDAL/OGR: biblioteca para lectura y escritura de datos geoespaciales","heading":"4.1 Resumen","text":"Se introduce la biblioteca GDAL/OGR para lectura y escritura de datos geoespaciales y se muestran varios ejemplos de su uso través de los programas para la línea de comandos del sistema operativo.","code":""},{"path":"ejemplo-de-interfaz-de-línea-de-comandos---gdalogr-biblioteca-para-lectura-y-escritura-de-datos-geoespaciales.html","id":"trabajo-previo","chapter":"4 Ejemplo de interfaz de línea de comandos - GDAL/OGR: biblioteca para lectura y escritura de datos geoespaciales","heading":"4.2 Trabajo previo","text":"","code":""},{"path":"ejemplo-de-interfaz-de-línea-de-comandos---gdalogr-biblioteca-para-lectura-y-escritura-de-datos-geoespaciales.html","id":"lecturas","chapter":"4 Ejemplo de interfaz de línea de comandos - GDAL/OGR: biblioteca para lectura y escritura de datos geoespaciales","heading":"4.2.1 Lecturas","text":"Pebesma, E., Wagner, W., Verbesselt, J., Goor, E., Briese, C., & Neteler, M. (2016). OpenEO: GDAL Earth Observation Analytics. https://r-spatial.org/2016/11/29/openeo.html","code":""},{"path":"ejemplo-de-interfaz-de-línea-de-comandos---gdalogr-biblioteca-para-lectura-y-escritura-de-datos-geoespaciales.html","id":"tutoriales","chapter":"4 Ejemplo de interfaz de línea de comandos - GDAL/OGR: biblioteca para lectura y escritura de datos geoespaciales","heading":"4.2.2 Tutoriales","text":"Gandhi, U. (2020). Mastering GDAL Tools. Spatial Thoughts. https://spatialthoughts.com/courses/mastering-gdal-tools/","code":""},{"path":"ejemplo-de-interfaz-de-línea-de-comandos---gdalogr-biblioteca-para-lectura-y-escritura-de-datos-geoespaciales.html","id":"descripción-general","chapter":"4 Ejemplo de interfaz de línea de comandos - GDAL/OGR: biblioteca para lectura y escritura de datos geoespaciales","heading":"4.3 Descripción general","text":"Geospatial Data Abstraction Library (GDAL) es una biblioteca para leer y escribir datos geoespaciales en formatos raster y vectoriales. GDAL se refiere la funcionalidad para datos raster y OGR (sigla antes usada para OpenGIS Simple Features Reference Implementation) la correspondiente datos vectoriales. En ocasiones, se utiliza la sigla GDAL (sin OGR) para referirse la funcionalidad para ambos modelos de datos. GDAL es distribuida por la Open Source Geospatial Foundation (OSGeo) con una licencia X/MIT.GDAL/OGR cuenta con un único modelo abstracto de datos raster y un único modelo abstracto de datos vectoriales, lo que permite programar aplicaciones geoespaciales sin tener que ocuparse de las particularidades de cada formato que se utilice (GeoTIFF, NetCDF, ESRI Shapefile, GeoPackage, GeoJSON, etc.).pesar de que GDAL/OGR está programada en C/C++, cuenta con una interfaz de programación de aplicaciones (API, en inglés, Application Programming Interface) para varios lenguajes de programación, incluyendo C, C++, Python y Java. Además, ofrece un conjunto de programas para la línea de comandos del sistema operativo cuyas distribuciones binarias están disponibles para varios sistemas operativos, incluyendo Windows, macOS y Linux. Estas API y los programas también están incluídos en la plataforma de ciencia de datos Anaconda, la cual puede instalarse en todos los sistemas operativos mencionados.","code":""},{"path":"ejemplo-de-interfaz-de-línea-de-comandos---gdalogr-biblioteca-para-lectura-y-escritura-de-datos-geoespaciales.html","id":"programas-para-la-línea-de-comandos-del-sistema-operativo","chapter":"4 Ejemplo de interfaz de línea de comandos - GDAL/OGR: biblioteca para lectura y escritura de datos geoespaciales","heading":"4.4 Programas para la línea de comandos del sistema operativo","text":"Los programas de GDAL/OGR para la línea de comandos del sistema operativo permiten ejecutar tareas de geoprocesamiento y de conversión entre formatos geoespaciales sin utilizar una interfaz gráfica o un lenguaje de programación.","code":""},{"path":"ejemplo-de-interfaz-de-línea-de-comandos---gdalogr-biblioteca-para-lectura-y-escritura-de-datos-geoespaciales.html","id":"instalación","chapter":"4 Ejemplo de interfaz de línea de comandos - GDAL/OGR: biblioteca para lectura y escritura de datos geoespaciales","heading":"4.4.1 Instalación","text":"En el sitio web de GDAL se describen varias opciones para su descarga e instalación, incluyendo archivos binarios ejecutables para varias plataformas.En el caso del sistema operativo Windows, estos programas se incluyen en la aplicación OSGeo4W, la cual puede instalarse junto con el sistema de información geográfica de escritorio QGIS. Se recomienda usar el instalador de red OSGeo4W.","code":""},{"path":"ejemplo-de-interfaz-de-línea-de-comandos---gdalogr-biblioteca-para-lectura-y-escritura-de-datos-geoespaciales.html","id":"consideraciones-generales","chapter":"4 Ejemplo de interfaz de línea de comandos - GDAL/OGR: biblioteca para lectura y escritura de datos geoespaciales","heading":"4.4.2 Consideraciones generales","text":"Los programas de GDAL comparten una serie de opciones comunes para datos raster y de opciones comunes para datos vectoriales que pueden visualizarse con la opción -- help-general. Por ejemplo:Para obtener ayuda acerca de un comando particular, puede usarse la opción -- help. Por ejemplo:","code":"ogrinfo --help-generalGeneric GDAL utility command options:\n  --version: report version of GDAL in use.\n  --license: report GDAL license info.\n  --formats: report all configured format drivers.\n  --format [format]: details of one format.\n  --optfile filename: expand an option file into the argument list.\n  --config key value: set system configuration option.\n  --debug [on/off/value]: set debug level.\n  --pause: wait for user input, time to attach debugger\n  --locale [locale]: install locale for debugging (i.e. en_US.UTF-8)\n  --help-general: report detailed help on general options.ogrinfo --helpUsage: ogrinfo [--help-general] [-ro] [-q] [-where restricted_where|@filename]\n               [-spat xmin ymin xmax ymax] [-geomfield field] [-fid fid]\n               [-sql statement|@filename] [-dialect sql_dialect] [-al] [-rl] [-so] [-fields={YES/NO}]\n               [-geom={YES/NO/SUMMARY}] [[-oo NAME=VALUE] ...]\n               [-nomd] [-listmdd] [-mdd domain|`all`]*\n               [-nocount] [-noextent] [-nogeomtype] [-wkt_format WKT1|WKT2|...]\n               [-fielddomain name]\n               datasource_name [layer [layer ...]]"},{"path":"ejemplo-de-interfaz-de-línea-de-comandos---gdalogr-biblioteca-para-lectura-y-escritura-de-datos-geoespaciales.html","id":"ejemplos-de-uso","chapter":"4 Ejemplo de interfaz de línea de comandos - GDAL/OGR: biblioteca para lectura y escritura de datos geoespaciales","heading":"4.4.3 Ejemplos de uso","text":"En esta sección, se presentan ejemplos de uso de los programas, tanto para datos vectoriales como para datos raster.","code":""},{"path":"ejemplo-de-interfaz-de-línea-de-comandos---gdalogr-biblioteca-para-lectura-y-escritura-de-datos-geoespaciales.html","id":"programas-para-datos-vectoriales","chapter":"4 Ejemplo de interfaz de línea de comandos - GDAL/OGR: biblioteca para lectura y escritura de datos geoespaciales","heading":"4.4.3.1 Programas para datos vectoriales","text":"","code":""},{"path":"ejemplo-de-interfaz-de-línea-de-comandos---gdalogr-biblioteca-para-lectura-y-escritura-de-datos-geoespaciales.html","id":"ogrinfo","chapter":"4 Ejemplo de interfaz de línea de comandos - GDAL/OGR: biblioteca para lectura y escritura de datos geoespaciales","heading":"4.4.3.1.1 ogrinfo","text":"El programa ogrinfo despliega información acerca de una fuente de datos vectoriales.Los siguientes comandos despliegan información sobre la capa de países de Natural Earth, tanto para el formato comprimido (ZIP) como para el formato shapefile (SHP). En el caso comprimido, note el uso de /vsizip/, para sistemas de archivos virtuales.Cree una nueva carpeta (ej. ejemplos-uso-gdal) para almacenar los archivos con los que trabajará.Descargue en la nueva carpeta la capa de paises desde la dirección https://www.naturalearthdata.com/http//www.naturalearthdata.com/download/110m/cultural/ne_110m_admin_0_countries.zip.Descomprima el archivo ZIP (lo borre).Con una herramienta de escritorio (ej. QGIS), visualice tanto el archivo ZIP como el SHP.Desde una interfaz de línea de comandos (ej. OSGeo4W Shell), ubíquese en la carpeta que creó y ejecute los siguientes comandos para obtener información sobre ambos archivos:¿Qué información despliegan ambos comandos? ¿Qué efectos produce el uso de las opciones -al y -? Revise la documentación sobre estas opciones y pruebe los comandos omitiendo cada una y ambas.Ejecute los siguientes comandos para filtrar registros de acuerdo con expresiones lógicas (booleana).Note el uso del operador (y), el cuál es un operador lógico, como también lo son el (o) y el ().","code":" # Información sobre la capa comprimida en formato ZIP\nogrinfo -al -so /vsizip/ne_110m_admin_0_countries.zip\n\n# Información sobre la capa descomprimida en formato shapefile\nogrinfo -al -so ne_110m_admin_0_countries.shp# Registros (países y otros territorios) del continente 'Oceania' (se omite el campo de la geometría)\nogrinfo -al -where \"CONTINENT='Oceania'\" -geom=NO ne_110m_admin_0_countries.shp\n\n# Registros de Oceanía de tipo país ('Country')\nogrinfo -al -where \"CONTINENT='Oceania' AND TYPE='Country'\" -geom=NO ne_110m_admin_0_countries.shp"},{"path":"ejemplo-de-interfaz-de-línea-de-comandos---gdalogr-biblioteca-para-lectura-y-escritura-de-datos-geoespaciales.html","id":"ogr2ogr","chapter":"4 Ejemplo de interfaz de línea de comandos - GDAL/OGR: biblioteca para lectura y escritura de datos geoespaciales","heading":"4.4.3.1.2 ogr2ogr","text":"El programa ogr2ogr realiza conversiones entre formatos de fuentes de datos vectoriales. la vez, puede ejecutar otras operaciones como selección de atributos y geometrías, filtrado por criterios espaciales y espaciales, reproyección y validación de geometrías, entre otras.Ejecute el siguiente comando para desplegar la lista de formatos (drivers) vectoriales soportados por OGR:Ejecute los siguientes comandos para convertir la capa de países (en SHP) otros formatos y cambiar su nombre:Ejecute el siguiente comando para desplegar la lista de capas en el WFS “IGN Cartografía 1:5mil” del Instituto Geográfico Nacional (IGN):Ejecute el siguiente comando para descargar la capa de cantones del WFS “IGN Cartografía 1:5mil” del Instituto Geográfico Nacional (IGN) en formato GeoPackage:","code":"# Despliegue de la lista de formatos vectoriales soportados por GDAL/OGR\nogr2ogr --formatsSupported Formats:\n  FITS -raster,vector- (rw+): Flexible Image Transport System\n  PCIDSK -raster,vector- (rw+v): PCIDSK Database File\n  netCDF -raster,multidimensional raster,vector- (rw+vs): Network Common Data Format\n  PDS4 -raster,vector- (rw+vs): NASA Planetary Data System 4\n  VICAR -raster,vector- (rw+v): MIPL VICAR file\n  JP2OpenJPEG -raster,vector- (rwv): JPEG-2000 driver based on OpenJPEG library\n  PDF -raster,vector- (rw+vs): Geospatial PDF\n  MBTiles -raster,vector- (rw+v): MBTiles\n  BAG -raster,multidimensional raster,vector- (rw+v): Bathymetry Attributed Grid\n  EEDA -vector- (ro): Earth Engine Data API\n  OGCAPI -raster,vector- (rov): OGCAPI\n  ESRI Shapefile -vector- (rw+v): ESRI Shapefile\n...# Conversión de SHP a GeoJSON\nogr2ogr paises.geojson ne_110m_admin_0_countries.shp\n\n# Conversión de SHP a GeoPackage\nogr2ogr paises.gpkg ne_110m_admin_0_countries.shp# Lista de capas en el WFS \"IGN Cartografía 1:5mil\"\nogrinfo WFS:\"http://geos.snitcr.go.cr/be/IGN_5/wfs\"INFO: Open of `WFS:http://geos.snitcr.go.cr/be/IGN_5/wfs'\n      using driver `WFS' successful.\nMetadata:\n  ABSTRACT=This is the reference implementation of WFS 1.0.0 and WFS 1.1.0, supports all WFS operations including Transaction.\n  PROVIDER_NAME=The Ancient Geographers\n  TITLE=SNIT Web Feature Service\n1: IGN_5:forestal2017_5k (title: ARBOLES 2017 1:5MIL)\n2: IGN_5:indice_5000 (title: Cobertura Ortofoto 1:5mil)\n3: IGN_5:cultivos2017_5k (title: Cultivos 2017 1:5mil)\n4: IGN_5:curvas_5000 (title: Curvas de Nivel 10m (5000))\n5: IGN_5:delimitacion2017_5k (title: Delimitación territorial 2017 1:5mil)\n6: IGN_5:edificaciones2017_5k (title: Edificaciones 2017 1:5mil)\n7: IGN_5:hidrografia_5000 (title: Hidrografía 1:5mil)\n8: IGN_5:limitecantonal_5k (title: Límite Cantonal 1:5mil)\n9: IGN_5:limitedistrital_5k (title: Límite Distrital 1:5mil)\n10: IGN_5:limiteprovincial_5k (title: Límite Provincial 1:5mil)\n11: IGN_5:linea_costa_5000 (title: Línea de Costa 1:5mil)\n12: IGN_5:pastos2017_5k (title: Pastos 2017 1:5mil)\n13: IGN_5:urbano_5000 (title: Urbano 1:5mil)\n14: IGN_5:vias_5000 (title: Vías 1:5mil)# Descarga y validación de geometrías\nogr2ogr -makevalid cantones.gpkg WFS:\"http://geos.snitcr.go.cr/be/IGN_5/wfs\" \"IGN_5:limitecantonal_5k\"\n\n# Descarga, validación de geometrías y reproyección a WGS84\nogr2ogr -t_srs EPSG:4326 -makevalid cantones-wgs84.gpkg WFS:\"http://geos.snitcr.go.cr/be/IGN_5/wfs\" \"IGN_5:limitecantonal_5k\""},{"path":"ejemplo-de-interfaz-de-línea-de-comandos---gdalogr-biblioteca-para-lectura-y-escritura-de-datos-geoespaciales.html","id":"ejercicios","chapter":"4 Ejemplo de interfaz de línea de comandos - GDAL/OGR: biblioteca para lectura y escritura de datos geoespaciales","heading":"4.4.4 Ejercicios","text":"De la capa de países de Natural Earth, extraiga los registros con población estimada superior mil millones. En la capa resultante, incluya solamente los campos de nombre del país en español y población estimada. ¿Cuál opción debe utilizar para especificar los campos que desea incluir en el archivo de salida?De la capa de cantones de Costa Rica, extraiga en un archivo GeoJSON los cantones de las provincia de Guanacaste, Puntarenas y Limón.De la capa de cantones de Costa Rica, extraiga en un archivo GeoJSON los cantones con área mayor o igual 2000 km2.De la capa de cantones de Costa Rica, extraiga en un archivo GeoJSON los cantones con área mayor o igual 2000 km2 de la provincia de Limón.De la capa de cantones de Costa Rica, extraiga en un archivo GeoJSON los cantones con área mayor o igual 2000 km2 de las provincias de Guanacaste, Puntarenas y Limón.De la capa de cantones de Costa Rica, extraiga en un archivo GeoPackage, los cantones de Guanacaste, con la excepción de Liberia.","code":"# La opción -select especifica la lista de campos que se copian al archivo de salida\nogr2ogr -select \"NAME_ES, POP_EST\" -where \"POP_EST >= 1000000000\" paises-muy-poblados.gpkg ne_110m_admin_0_countries.shpogr2ogr -where \"provincia = 'Guanacaste' OR provincia = 'Puntarenas' OR provincia = 'Limón'\" cantones-guanacaste-puntarenas-limon.geojson WFS:\"http://geos.snitcr.go.cr/be/IGN_5/wfs\" \"IGN_5:limitecantonal_5k\"ogr2ogr -where \"area >= 2000\" cantones-grandes.geojson WFS:\"http://geos.snitcr.go.cr/be/IGN_5/wfs\" \"IGN_5:limitecantonal_5k\"# El operador lógico AND se utiliza para buscar los registros que cumplen dos condiciones simultáneamente\nogr2ogr -where \"area >= 2000 AND provincia = 'Limón'\" cantones-grandes-limon.geojson WFS:\"http://geos.snitcr.go.cr/be/IGN_5/wfs\" \"IGN_5:limitecantonal_5k\"# En este caso, deben utilizarse paréntesis para alterar el orden de precedencia de los operadores lógicos AND y OR\nogr2ogr -where \"area >= 2000 AND (provincia = 'Guanacaste' OR provincia = 'Puntarenas' OR provincia = 'Limón')\" cantones-grandes-guanacaste-puntarenas-limon.geojson WFS:\"http://geos.snitcr.go.cr/be/IGN_5/wfs\" \"IGN_5:limitecantonal_5k\"# El operador NOT se utiliza para excluir el cantón de Liberia.\nogr2ogr -where \"provincia = 'Guanacaste' AND NOT(canton = 'Liberia')\" cantones-guanacaste-excepto-liberia.gpkg WFS:\"http://geos.snitcr.go.cr/be/IGN_5/wfs\" \"IGN_5:limitecantonal_5k\""},{"path":"ejemplo-de-interfaz-de-línea-de-comandos---gdalogr-biblioteca-para-lectura-y-escritura-de-datos-geoespaciales.html","id":"recursos-de-interés-2","chapter":"4 Ejemplo de interfaz de línea de comandos - GDAL/OGR: biblioteca para lectura y escritura de datos geoespaciales","heading":"4.5 Recursos de interés","text":"Codecademy. (s. f.). Command Line Tutorial: Learn Command Line. Codecademy. Recuperado 19 de marzo de 2022, de https://www.codecademy.com/learn/learn--command-lineSS64 Command line reference. (s. f.). Recuperado 3 de abril de 2022, de https://ss64.com/","code":""},{"path":"reproducibilidad.html","id":"reproducibilidad","chapter":"5 Reproducibilidad","heading":"5 Reproducibilidad","text":"","code":""},{"path":"reproducibilidad.html","id":"resumen-4","chapter":"5 Reproducibilidad","heading":"5.1 Resumen","text":"Un análisis realizado por un investigador se considera reproducible si el código fuente y los datos que utilizó para obtener los resultados están disponibles y son suficientes para que otro investigador, trabajando de manera independiente, pueda llegar al mismo resultado. El concepto de reproducibilidad es cada vez más importante debido al aumento exponencial de datos y al empleo de la programación de computadoras por parte de especialistas de diversas disciplinas.","code":""},{"path":"reproducibilidad.html","id":"el-concepto-de-reproducibilidad","chapter":"5 Reproducibilidad","heading":"5.2 El concepto de reproducibilidad","text":"En general, la reproducibilidad es la capacidad de un ensayo o experimento de ser reproducido por otros. Más formalmente, en investigación cuantitativa, un análisis se considera reproducible si “el código fuente y los datos utilizados por un investigador para llegar un resultado están disponibles y son suficientes para que otro investigador, trabajando de manera independiente, pueda llegar al mismo resultado”.1La reproducibilidad, junto con la falsabilidad, es uno de los pilares del método científico. Sin embargo, en años recientes, se ha generado una creciente preocupación debido que muchos estudios científicos publicados fallan las pruebas de reproducibilidad (véase, por ejemplo, Excel Depression, de Paul Krugman), dando lugar una crisis de reproducibilidad o replicabilidad en varias ciencias.El concepto de reproducibilidad es cada vez más importante debido, entre otras razones, al aumento exponencial de datos disponibles y la aplicación de la programación de computadoras, para procesar estos datos, por parte de especialistas de muchas disciplinas.","code":""},{"path":"reproducibilidad.html","id":"reproducibilidad-en-ciencia-de-datos-geoespaciales","chapter":"5 Reproducibilidad","heading":"5.3 Reproducibilidad en ciencia de datos geoespaciales","text":"Alex Singleton y otros autores2 han identificado los siguientes retos para la reproducibilidad en ciencia de datos geoespaciales:Los datos deben ser de dominio público y estar disponibles para los investigadores.El software utilizado debe ser de código abierto (open source) y estar disponible para ser revisado.Siempre que sea posible, los flujos de trabajo deben ser públicos y con enlaces los datos, software y métodos de análisis, junto con la documentación necesaria.El proceso de revisión por pares (peer review process) y la publicación académica deben requerir la presentación de un modelo de flujo de trabajo e idealmente la disponibilidad de los materiales necesarios para la replicación.En los casos en los que la reproducibilidad total sea posible (ej. datos sensibles), los investigadores deben esforzarse por incluir todos los aspectos que puedan de un marco de trabajo abierto.En general, el estándar mínimo de reproducibilidad requiere que los datos y el código fuente estén disponibles para otros investigadores.3 Sin embargo, dependiendo de las circunstancias y recursos disponibles, existe todo un espectro de posibilidades, que se ilustra en la figura 5.1.\nFigure 5.1: Espectro de reproducibilidad. Imagen de Anita Graser, basada en (Peng, 2001).\n","code":""},{"path":"reproducibilidad.html","id":"herramientas-para-facilitar-la-reproducibilidad","chapter":"5 Reproducibilidad","heading":"5.4 Herramientas para facilitar la reproducibilidad","text":"La documentación es vital durante todo el ciclo de vida de una investigación reproducible. Se recomienda utilizar mecanismos estandarizados y abiertos como el lenguaje de marcado de hipertexto (HTML, en inglés, HyperText Markup Language) o Markdown, con los cuales pueden crearse documentos mediante editores de texto simples (.e. se requiere de software propietario), y exportables varios formatos (ej. LaTeX, PDF).Para dar mantenimiento, tanto al código fuente como la documentación, es necesario un sistema de control de versiones como Git, el cual permite llevar el registro de los cambios en archivos y también facilita el trabajo colaborativo al reunir las modificaciones hechas por varias personas. Git es usado en varias plataformas que comparten código fuente (ej. GitHub, GitLab) y que ofrecen servicios relacionados, como hospedaje de sitios web.","code":""},{"path":"reproducibilidad.html","id":"recursos-de-interés-3","chapter":"5 Reproducibilidad","heading":"5.5 Recursos de interés","text":"Bartomeus Lab. (2016). reproducible workflow. https://www.youtube.com/watch?v=s3JldKoA0zwFOSS4G. (2021). FOSS4G2021—Open source open spatial data science—Anita Graser. https://www.youtube.com/watch?v=ZjXb53pOor0Krugman, P. (2013). Opinion | Excel Depression. New York Times. https://www.nytimes.com/2013/04/19/opinion/krugman--excel-depression.htmlPeng, R. D. (2011). Reproducible Research Computational Science. Science, 334(6060), 1226-1227. https://doi.org/10.1126/science.1213847Singleton, . D., Spielman, S., & Brunsdon, C. (2016). Establishing framework Open Geographic Information science. International Journal Geographical Information Science, 30(8), 1507-1521. https://doi.org/10.1080/13658816.2015.1137579","code":""},{"path":"markdown-lenguaje-de-marcado.html","id":"markdown-lenguaje-de-marcado","chapter":"6 Markdown: lenguaje de marcado","heading":"6 Markdown: lenguaje de marcado","text":"","code":""},{"path":"markdown-lenguaje-de-marcado.html","id":"trabajo-previo-1","chapter":"6 Markdown: lenguaje de marcado","heading":"6.1 Trabajo previo","text":"","code":""},{"path":"markdown-lenguaje-de-marcado.html","id":"tutoriales-1","chapter":"6 Markdown: lenguaje de marcado","heading":"6.1.1 Tutoriales","text":"Markdown Tutorial. (s. f.). Recuperado 19 de marzo de 2022, de https://www.markdowntutorial.com/","code":""},{"path":"markdown-lenguaje-de-marcado.html","id":"otros","chapter":"6 Markdown: lenguaje de marcado","heading":"6.1.2 Otros","text":"Instale en su computadora el sistema base del lenguaje R y luego el ambiente integrado de desarrollo RStudio Desktop.Cree una cuenta gratuita en la plataforma de desarrollo colaborativo GitHub.","code":""},{"path":"markdown-lenguaje-de-marcado.html","id":"resumen-5","chapter":"6 Markdown: lenguaje de marcado","heading":"6.2 Resumen","text":"Markdown es un lenguaje de marcado ligero ampliamente utilizado en comunicación científica, documentación de programas e investigación reproducible.","code":""},{"path":"markdown-lenguaje-de-marcado.html","id":"descripción-general-1","chapter":"6 Markdown: lenguaje de marcado","heading":"6.3 Descripción general","text":"Markdown es un lenguaje de marcado creado en 2004 por John Gruber. Las “marcas” se utilizan para brindar información acerca de la presentación (ej. negritas, itálicas) o la estructura (ej. títulos, encabezados) de un documento. Se caracteriza por ser más sencillo de leer y de usar que otros lenguajes de marcado (ej. Lenguaje de marcado de Hipertexto o HTML), por lo que se considera un lenguaje de marcado ligero. Los documentos escritos en Markdown pueden exportarse una gran variedad de formatos (ej. HTML, DOC, PDF, LaTex) para ser usados en libros, presentaciones o páginas web, entre otros. Markdown es ampliamente utilizado en comunicación científica, documentación de programas e investigación reproducible.","code":""},{"path":"markdown-lenguaje-de-marcado.html","id":"variaciones","chapter":"6 Markdown: lenguaje de marcado","heading":"6.4 Variaciones","text":"Las variaciones de Markdown, también llamadas flavors, son extensiones o modificaciones de la especificación original. Entre las más populares están:R Markdown: para el lenguaje R.GitHub Flavored Markdown: para la plataforma GitHub.Python Markdown: para el lenguaje Python.Pandoc’s Markdown: para el programa Pandoc de conversión entre formatos.Kramdown: para el lenguaje Ruby.Puede verse una lista más extensa en https://github.com/commonmark/commonmark-spec/wiki/markdown-flavors.","code":""},{"path":"markdown-lenguaje-de-marcado.html","id":"sintaxis","chapter":"6 Markdown: lenguaje de marcado","heading":"6.5 Sintaxis","text":"La sintaxis de Markdown permite especificar diferentes componentes de un documento, entre los que están:Encabezados.Estilos (ej. negritas, itálicas).Citas textuales.Enlaces otros documentos (ej. páginas web).Imágenes.Listas.","code":""},{"path":"markdown-lenguaje-de-marcado.html","id":"encabezados","chapter":"6 Markdown: lenguaje de marcado","heading":"6.5.1 Encabezados","text":"Pueden definirse seis niveles de encabezados, mediante símbolos de numeral (#) antes del texto. El primer nivel es el de tamaño de texto más grande y el sexto el más pequeño. En la parte izquierda de la figura 6.1 se muestra la sintaxis Markdown de los encabezados y la derecha la forma en que se despliegan en un documento.\nFigure 6.1: Sintaxis de Markdown: encabezados.\n","code":""},{"path":"markdown-lenguaje-de-marcado.html","id":"itálicas","chapter":"6 Markdown: lenguaje de marcado","heading":"6.5.2 Itálicas","text":"Se definen con un asterisco (*) antes y después del texto o con un guión bajo (_) antes y después del texto.\nFigure 6.2: Sintaxis de Markdown: itálicas.\n","code":""},{"path":"markdown-lenguaje-de-marcado.html","id":"negritas","chapter":"6 Markdown: lenguaje de marcado","heading":"6.5.3 Negritas","text":"Se definen con dos asteriscos (**) antes y después del texto o con dos guiones bajos (__) antes y después del texto.\nFigure 6.3: Sintaxis de Markdown: negritas.\n","code":""},{"path":"markdown-lenguaje-de-marcado.html","id":"citas-textuales","chapter":"6 Markdown: lenguaje de marcado","heading":"6.5.4 Citas textuales","text":"Se definen con un símbolo de “mayor que” (>) antes de cada línea.\nFigure 6.4: Sintaxis de Markdown: citas textuales.\n","code":""},{"path":"markdown-lenguaje-de-marcado.html","id":"enlaces-a-otros-documentos-hipervínculos","chapter":"6 Markdown: lenguaje de marcado","heading":"6.5.5 Enlaces a otros documentos (hipervínculos)","text":"Se definen con paréntesis cuadrados ([]) seguidos de paréntesis redondos (()). En los paréntesis cuadrados se coloca (opcionalmente) el texto del enlace y en los redondos la dirección del documento.\nFigure 6.5: Sintaxis de Markdown: enlaces otros documentos.\n","code":""},{"path":"markdown-lenguaje-de-marcado.html","id":"imágenes","chapter":"6 Markdown: lenguaje de marcado","heading":"6.5.6 Imágenes","text":"Se definen con un signo de admiración de cierre (!), paréntesis cuadrados ([]) y paréntesis redondos (()). En los paréntesis cuadrados se coloca (opcionalmente) un texto alternativo de la imagen y en los redondos la dirección de la imagen, ya sea local o remota.\nFigure 6.6: Sintaxis de Markdown: imágenes.\n","code":""},{"path":"markdown-lenguaje-de-marcado.html","id":"listas-numeradas","chapter":"6 Markdown: lenguaje de marcado","heading":"6.5.7 Listas numeradas","text":"Se definen con números (1. 2. 3. ...) antes de cada elemento.\nFigure 6.7: Sintaxis de Markdown: listas numeradas.\n","code":""},{"path":"markdown-lenguaje-de-marcado.html","id":"listas-no-numeradas","chapter":"6 Markdown: lenguaje de marcado","heading":"6.5.8 Listas no numeradas","text":"Se definen con guiones (-) o asteriscos (*) antes de cada elemento.\nFigure 6.8: Sintaxis de Markdown: listas numeradas.\n","code":""},{"path":"markdown-lenguaje-de-marcado.html","id":"otros-elementos-de-sintaxis","chapter":"6 Markdown: lenguaje de marcado","heading":"6.5.9 Otros elementos de sintaxis","text":"Para conocer otros elementos de la sintaxis de Markdown, se recomienda revisar en detalle la Guía de referencia de Markdown.","code":""},{"path":"markdown-lenguaje-de-marcado.html","id":"ejercicios-1","chapter":"6 Markdown: lenguaje de marcado","heading":"6.6 Ejercicios","text":"Cree un documento Markdown llamado README.md, en RStudio, y escriba en este un breve perfil académico (curriculum académico).\nIncluya información como: nombre, fotografía, datos de contacto, áreas de interés, carrera, cursos aprobados, publicaciones, etc.\nPuede usar información ficticia (incluya datos confidenciales o sensibles).\nEspecifique la fuente de las imágenes (y de cualquier otra información para la que sea necesario) y utilice imágenes para las que tiene autorización. Considere utilizar sitios con imágenes con licencias abiertas (ej. Wikimedia Commons, Unsplash, FreeImages).\nAsegúrese de utilizar los siguientes elementos de sintaxis Markdown:\nVarios niveles de encabezados.\nNegritas e itálicas.\nListas.\nEnlaces sitios web.\nImágenes (al menos una local y una remota).\n\nIncluya información como: nombre, fotografía, datos de contacto, áreas de interés, carrera, cursos aprobados, publicaciones, etc.Puede usar información ficticia (incluya datos confidenciales o sensibles).Especifique la fuente de las imágenes (y de cualquier otra información para la que sea necesario) y utilice imágenes para las que tiene autorización. Considere utilizar sitios con imágenes con licencias abiertas (ej. Wikimedia Commons, Unsplash, FreeImages).Asegúrese de utilizar los siguientes elementos de sintaxis Markdown:\nVarios niveles de encabezados.\nNegritas e itálicas.\nListas.\nEnlaces sitios web.\nImágenes (al menos una local y una remota).\nVarios niveles de encabezados.Negritas e itálicas.Listas.Enlaces sitios web.Imágenes (al menos una local y una remota).Cree un repositorio en GitHub llamado perfil-academico y suba este el documento que creó en el paso 1.Cree un sitio web en GitHub Pages con el repositorio creado en el paso 2.","code":""},{"path":"markdown-lenguaje-de-marcado.html","id":"recursos-de-interés-4","chapter":"6 Markdown: lenguaje de marcado","heading":"6.7 Recursos de interés","text":"Carrera Arias, F. J. (2020). Install R Windows, Mac OS X, Ubuntu Tutorial. DataCamp Community. https://www.datacamp.com/community/tutorials/installing-R-windows-mac-ubuntuMarkdown Guide. (s. f.). Recuperado 10 de abril de 2022, de https://www.markdownguide.org/","code":""},{"path":"git-sistema-de-control-de-versiones.html","id":"git-sistema-de-control-de-versiones","chapter":"7 Git: sistema de control de versiones","heading":"7 Git: sistema de control de versiones","text":"","code":""},{"path":"git-sistema-de-control-de-versiones.html","id":"trabajo-previo-2","chapter":"7 Git: sistema de control de versiones","heading":"7.1 Trabajo previo","text":"","code":""},{"path":"git-sistema-de-control-de-versiones.html","id":"tutoriales-2","chapter":"7 Git: sistema de control de versiones","heading":"7.1.1 Tutoriales","text":"Abba, . V. (2021). Git GitHub Tutorial – Version Control Beginners. FreeCodeCamp.Org. https://www.freecodecamp.org/news/git--github--beginners/","code":""},{"path":"git-sistema-de-control-de-versiones.html","id":"otros-1","chapter":"7 Git: sistema de control de versiones","heading":"7.1.2 Otros","text":"Instale en su computadora el sistema de control de versiones Git.","code":""},{"path":"git-sistema-de-control-de-versiones.html","id":"resumen-6","chapter":"7 Git: sistema de control de versiones","heading":"7.2 Resumen","text":"Git es un sistema para administrar versiones de código fuente o, en general, de cualquier conjunto de archivos.","code":""},{"path":"git-sistema-de-control-de-versiones.html","id":"descripción-general-2","chapter":"7 Git: sistema de control de versiones","heading":"7.3 Descripción general","text":"Git es un sistema de control de versiones diseñado para rastrear cambios en el código fuente durante el proceso de desarrollo de software. Sin embargo, puede ser utilizado para llevar el control de los cambios en cualquier conjunto de archivos (ej. documentación, música).Un sistema de control de versiones proporciona, entre otras ventajas:La capacidad de recuperar versiones anteriores del conjunto de archivos.La capacidad de integrar modificaciones efectuadas por varias personas en el conjunto de archivos.La capacidad de mantener varias “ramas” (branches) de un producto (ej. “estable”, “evaluación”, “inestable”, como en el caso de Debian Linux, GRASS GIS y muchos otros proyectos de software libre).Facilidades para mantener redundancia y respaldos de los archivos (ej. Programa de respaldos de GitHub).Git fue diseñado por Linus Torvalds en 2005 durante del desarrollo del kernel del sistema operativo Linux. Se caracteriza por ser un sistema de control de versiones distribuido, lo que significa que el código fuente puede estar alojado en la estación de trabajo de cualquier miembro del equipo de desarrollo (.e. tiene que existir un repositorio central).El protocolo de Git es utilizado en varios sitios que proveen servicios de alojamiento de software, entre los que están SourceForge, Bitbucket, GitLab y GitHub.","code":""},{"path":"git-sistema-de-control-de-versiones.html","id":"como-funciona-git","chapter":"7 Git: sistema de control de versiones","heading":"7.4 ¿Como funciona Git?","text":"Desde el punto de vista de un usuario de Git (ej. un programador), Git se utiliza para sincronizar la versión local de un conjunto de archivos, llamado proyecto o repositorio, con la versión que está alojada en un sistema remoto (ej. GitHub). Cada repositorio se almacena en un directorio (carpeta) del sistema operativo. La sincronización se realiza principalmente través de dos operaciones:push: para “subir” al repositorio remoto los cambios realizados en el repositorio local. Esta operación se realiza mediante el comando git push. Es probable que el sistema remoto le solicite al usuario algún tipo de autenticación (ej. nombre de usuario y clave).pull: para “bajar” al repositorio local los cambios realizados en el repositorio remoto. Esta operación se realiza mediante el comando git pull.Las operaciones push y pull se ilustran en la figura 7.1.\nFigure 7.1: Operaciones push y pull. Imagen de Melinda Higgins.\nAntes de un push, el usuario debe seleccionar los archivos que desea subir mediante el comando git add, el cual pasa los archivos un “área de espera” (staging area). Luego debe usarse el comando git commit para “guardar” los cambios en el área de espera.La relación entre estas operaciones de Git, se ilustra en la figura 7.2.\nFigure 7.2: Operaciones de Git. Imagen de Steven Klavins.\nEn la figura 7.3 se muestra el funcionamiento de Git mediante una comparación con el procesamiento de una compra en línea.\nFigure 7.3: Operaciones de Git y compras en línea. Imagen de Melinda Higgins.\nOtras operaciones de Git de uso frecuente son:git config: para especificar opciones globales de la sesión de Git (ej. nombre del usuario, dirección de corre electrónico).git clone: para clonar (.e. copiar) un repositorio remoto en la computadora local.git status: para revisar el estado de los archivos y, por ejemplo, saber cuales deben pasarse al área de espera.","code":""},{"path":"git-sistema-de-control-de-versiones.html","id":"ejemplos-de-uso-1","chapter":"7 Git: sistema de control de versiones","heading":"7.5 Ejemplos de uso","text":"","code":""},{"path":"git-sistema-de-control-de-versiones.html","id":"clonación-de-un-repositorio-remoto-y-sincronización-de-los-cambios-efectuados-localmente","chapter":"7 Git: sistema de control de versiones","heading":"7.5.1 Clonación de un repositorio remoto y sincronización de los cambios efectuados localmente","text":"Para seguir este ejemplo:Bifurque (fork) su cuenta en GitHub el repositorio localizado en la dirección https://github.com/gf0604-procesamientodatosgeograficos/2022--tutorial-git-repo-ejemplo.Con la opción File - New Project - Version Control - Git de RStudio, clone su computadora el repositorio que acaba de bifurcar.Con el editor de RStudio, abra el archivo README.md, agregue una línea y guarde el archivo.Luego, ejecute los siguientes comandos desde la la ventana Terminal de RStudio. Nota: las líneas que empiezan con # son comentarios.Revise los cambios aplicados en el repositorio remoto en GitHub. Si se realizan nuevos cambios en el repositorio local, deben repetirse los pasos del 1 al 4. Los comentarios en el commando commit deben reflejar los cambios realizados.","code":"# 0. Especificación del nombre y de la dirección de correo del usuario.\n# Debe modificar la dirección de correo y el nombre del usuario con sus propios datos.\n$ git config --global user.email usuario@correo.com\n$ git config --global user.name usuariogithub\n# Para revisar:\n$ git config --global --list\n\n# 1. Revisión de los archivos con modificaciones.\n$ git status\n\n# 2. Adición de los archivos modificados al \"área de espera\".\n# El punto (.) indica que se agregarán todos los archivos modificados.\n$ git add .\n\n# 3. Almacenamiento (commit) del conjunto de archivos modificados, junto con un mensaje explicativo.\n$ git commit -m \"Agregar línea 2\"\n\n# 4. \"Subida\" (push) de las modificaciones al repositorio remoto.\n$ git push"},{"path":"git-sistema-de-control-de-versiones.html","id":"recursos-de-interés-5","chapter":"7 Git: sistema de control de versiones","heading":"7.6 Recursos de interés","text":"GitHub Archive Program. (s. f.). GitHub Archive Program. Recuperado 10 de abril de 2022, de https://archiveprogram.github.com/Higgins, M. (s. f.). Reproducible Templates Analysis Dissemination. Coursera. Recuperado 11 de abril de 2022, de https://www.coursera.org/learn/reproducible-templates-analysisKlavins, S. (2020). Version Control part 1. Medium. https://stevenklavins94.medium.com/version-control-part-1-c5f1b43127f6","code":""},{"path":"r---conceptos-básicos.html","id":"r---conceptos-básicos","chapter":"8 R - Conceptos básicos","heading":"8 R - Conceptos básicos","text":"","code":""},{"path":"r---conceptos-básicos.html","id":"trabajo-previo-3","chapter":"8 R - Conceptos básicos","heading":"8.1 Trabajo previo","text":"","code":""},{"path":"r---conceptos-básicos.html","id":"lecturas-1","chapter":"8 R - Conceptos básicos","heading":"8.1.1 Lecturas","text":"Grolemund, G., & Wickham, H. (2014). Hands-Programming R: Write Functions Simulations. O’Reilly Media. https://rstudio-education.github.io/hopr/","code":""},{"path":"r---conceptos-básicos.html","id":"resumen-7","chapter":"8 R - Conceptos básicos","heading":"8.2 Resumen","text":"En esta lección, se estudiarán los conceptos básicos del lenguaje de programación R, incluyendo:Características generales de R.El ambiente de desarrollo RStudio.Funciones y paquetes.Tipos de datos.Definición de funciones.Condicionales.Ciclos.","code":""},{"path":"r---conceptos-básicos.html","id":"características-generales","chapter":"8 R - Conceptos básicos","heading":"8.3 Características generales","text":"R es un lenguaje de programación enfocado en análisis estadístico. Es ampliamente utilizado en diversas áreas de investigación, entre las que pueden mencionarse aprendizaje automático (machine learning), ciencia de datos (data science) y big data, con aplicaciones en campos como biomedicina, bioinformática y finanzas, entre muchos otros. Fue creado por Ross Ihaka y Robert Gentleman en la Universidad de Auckland, Nueva Zelanda, en 1993.Algunas de las principales características de este lenguaje son:Es interpretado: las instrucciones se traducen una por una lenguaje máquina, diferencia de los lenguajes compilados, que traducen de manera conjunta las instrucciones de una unidad completa (ej. un programa o una biblioteca). Los lenguajes interpretados tienden ser más lentos que los compilados, pero también son más flexibles.Es multiplataforma: puede ejecutarse en los sistemas operativos más populares (ej. Microsoft Windows, macOS, Linux).Tiene un sistema de tipos de datos dinámico: las variables pueden tomar diferentes tipos de datos (ej. textuales, numéricos) durante la ejecución del programa, diferencia del caso de un sistema de tipos de datos estático, en el que las variables solo pueden tener un tipo de datos.Soporta varios paradigmas de programación: los paradigmas son estilos o enfoques teóricos de programación. R soporta los paradigmas de programación funcional, programación orientada objetos, programación imperativa y programación procedimental.R es un proyecto de software libre que se comparte mediante una licencia GNU General Public Licence (GNU GPL). Esta característica permite que la funcionalidad original de R pueda ser ampliada mediante bibliotecas o paquetes desarrollados por la comunidad de programadores.Para programar en R, puede utilizarse una interfaz de línea de comandos, editores de texto (ej. Visual Studio Code, Vim) y también ambientes de desarrollo integrados (IDE, integrated development environment) como Jupyter o RStudio.","code":""},{"path":"r---conceptos-básicos.html","id":"el-ambiente-de-desarrollo-rstudio","chapter":"8 R - Conceptos básicos","heading":"8.4 El ambiente de desarrollo RStudio","text":"RStudio es el IDE más popular para el lenguaje R. Está disponible en una versión de escritorio (RStudio Desktop) y en una versión para servidor (RStudio Server). Esta última permite la conexión de varios usuarios través de un navegador web. RStudio se ofrece también como un servicio en la nube, través de RStudio Cloud.La figura 8.1 muestra la interfaz de RStudio.\nFigure 8.1: Interfaz del ambiente integrado de desarrollo RStudio.\nAdemás de edición de código fuente en R (y otros lenguajes), RStudio contiene capacidades para depurar código y visualizar datos en formatos tabulares, gráficos y de mapas.","code":""},{"path":"r---conceptos-básicos.html","id":"conjuntos-de-datos-para-pruebas","chapter":"8 R - Conceptos básicos","heading":"8.5 Conjuntos de datos para pruebas","text":"Para efectos de pruebas y ejemplos, la distribución base de R incorpora varios conjuntos de datos que pueden listarse con la función data(). Para obtener información acerca de un conjunto de datos en particular, puede utilizarse el operador ?.","code":"\n# Información sobre todos los conjuntos de datos incorporados en la distribución base de R\ndata()\n\n# Información sobre el cojunto de datos \"cars\"\n?cars\n\n# Información sobre el cojunto de datos \"Iris\"\n?iris"},{"path":"r---conceptos-básicos.html","id":"funciones","chapter":"8 R - Conceptos básicos","heading":"8.6 Funciones","text":"R, al igual que otros lenguajes de programación, estructura su funcionalidad en unidades de código fuente llamadas funciones. Cada función realiza una tarea específica como, por ejemplo, un cálculo matemático y, por lo general, retorna un valor como salida. Todas las funciones tienen un nombre y, opcionalmente, un conjunto de argumentos que especifican los datos de entrada que procesa la función. Los argumentos se escriben entre paréntesis redondos (()) y estos siempre deben incluirse, aún en el caso de que la función tenga ningún argumento. Si la función tiene varios argumentos, deben separarse mediante comas (,).","code":""},{"path":"r---conceptos-básicos.html","id":"ejemplos","chapter":"8 R - Conceptos básicos","heading":"8.6.1 Ejemplos","text":"La función print() recibe como argumento un valor (ej. un texto o un número) para imprimirlo en la pantalla. En el siguiente fragmento de código en R, se utiliza print() para imprimir la hilera “Hola mundo”. Nótese el uso del símbolo # para comentarios (.e. texto que es código ejecutable).La función mean() retorna la media aritmética del argumento de entrada. En el siguiente ejemplo, se calcula la media de los números de un vector creado su vez con la función c().La función getwd() (get working directory) retorna la ruta del directorio de trabajo de la sesión actual de R. Este es el directorio en el cual R espera encontrar, por ejemplo, archivos de datos.La función setwd() (set working directory) establece la ruta del directorio de trabajo de la sesión actual de R. Como argumento, recibe una hilera de texto con la ruta.Note las barras utilizadas para separar los subdirectorios: / (\\)","code":"\n# Impresión de una hilera de caracteres\nprint(\"Hola mundo\")\n#> [1] \"Hola mundo\"\n# Media aritmética\nmean(c(2, 4, 5, 9))\n#> [1] 5\n# Impresión del directorio de trabajo\ngetwd()\n#> [1] \"/home/mfvargas/gf0604-procesamientodatosgeograficos/2022-i/github/2022-i\"\n# Definición del directorio de trabajo (la ruta debe existir)\nsetwd(\"C:/Users/mfvargas\")\n\n# Directorio con espacios, tildes y eñes\nsetwd(\"C:/Users/mfvargas/mi directorio con espacios y tildes áéíóúñ\")"},{"path":"r---conceptos-básicos.html","id":"ejercicios-2","chapter":"8 R - Conceptos básicos","heading":"8.6.2 Ejercicios","text":"Obtenga la ruta de su directorio de trabajo con la función getwd().Si lo desea, cambie la ruta de su directorio de trabajo con la función setwd(). Verifique el cambio con getwd().","code":""},{"path":"r---conceptos-básicos.html","id":"argumentos","chapter":"8 R - Conceptos básicos","heading":"8.6.3 Argumentos","text":"Los argumentos de las funciones tienen nombres que pueden especificarse, en caso de ser necesario. En algunos casos, el orden y el tipo de datos de los argumentos permiten que el interpretador de R conozca cuál es cada uno.En el siguiente ejemplo, se utilizan los argumentos x, xlab y ylab de la función plot() para especificar la fuente de datos y las etiquetas de los ejes x e y de un gráfico de dispersión.","code":"\n# Gráfico de dispersón del conjunto de datos \"cars\" con etiquetas en los ejes x e y\nplot(\n  x=cars, \n  xlab=\"Velocidad (mph)\", \n  ylab=\"Distancia requerida para frenar (pies)\"\n)"},{"path":"r---conceptos-básicos.html","id":"ejercicios-3","chapter":"8 R - Conceptos básicos","heading":"8.6.3.1 Ejercicios","text":"Estudie la documentación de la función plot() y agregue al gráfico anterior:\nUn título.\nUn subtítulo.\nUn título.Un subtítulo.","code":""},{"path":"r---conceptos-básicos.html","id":"ayuda","chapter":"8 R - Conceptos básicos","heading":"8.6.4 Ayuda","text":"Para obtener ayuda de una función desde la línea de comandos de R, puede utilizarse un signo de pregunta (?) seguido del nombre de la función o bien la función help(). Por ejemplo:Adicionalmente, puede utilizarse la función apropos() para buscar funciones por palabras clave.La función example() presenta ejemplos sobre el uso de una función.Por otra parte, el sitio R Documentation reúne documentación de funciones de una gran cantidad de paquetes de R. También puede obtenerse ayuda sobre una función en los buscadores de Internet (ej. Google), además de ejemplos, tutoriales y otros materiales de apoyo.","code":"\n# Ayuda de la función setwd()\n?setwd\nhelp(setwd)\n# Búsqueda, por palabras clave, de funciones relacionadas con \"mean\" (media aritmética). Note las comillas (\"\").\napropos(\"mean\")\n#>  [1] \".colMeans\"     \".rowMeans\"     \"colMeans\"     \n#>  [4] \"kmeans\"        \"mean\"          \"mean.Date\"    \n#>  [7] \"mean.default\"  \"mean.difftime\" \"mean.POSIXct\" \n#> [10] \"mean.POSIXlt\"  \"rowMeans\"      \"weighted.mean\"\n# Ejemplos de uso de la función mean()\nexample(\"mean\")\n#> \n#> mean> x <- c(0:10, 50)\n#> \n#> mean> xm <- mean(x)\n#> \n#> mean> c(xm, mean(x, trim = 0.10))\n#> [1] 8.75 5.50"},{"path":"r---conceptos-básicos.html","id":"paquetes","chapter":"8 R - Conceptos básicos","heading":"8.7 Paquetes","text":"Las funciones de R se distribuyen mediante paquetes. Cada paquete contiene un conjunto de funciones y estructuras de datos relacionadas entre sí. Para utilizar un paquete, primero debe cargarse (en la memoria del computador) con la función library().Algunos paquetes están contenidos en la distribución base de R y otros deben instalarse de manera separada con la función install.packages().En el siguiente ejemplo, se instala el paquete PASWR2, el cual contiene el conjunto de datos TITANIC3.El paquete PASWR2 se carga con library().El conjunto de datos TITANIC3 puede visualizarse con la función View().Para visualizar gráficamente el conjunto de datos, el siguiente gráfico de barras muestra la distribución de pasajeros por clase.La distribución por cada clase puede dividirse en fallecidos y sobrevivientes.El siguiente gráfico muestra en un gráfico de barras apiladas la distribución de pasajeros sobrevivientes y fallecidos en cada clase.La misma información se muestra seguidamente en un gráfico de barras agrupadas.","code":"\n# Carga del paquete stats\nlibrary(stats)\n# Instalación del paquete PASWR2 (note las comillas)\ninstall.packages(\"PASWR2\")\n# Carga de PASWR2\nlibrary(PASWR2)\n#> Loading required package: lattice\n#> Loading required package: ggplot2\n# Visualización del conjunto de datos TITANIC3\nView(TITANIC3)\n# Cantidades de pasajeros por clase\ntable(TITANIC3$pclass)\n#> \n#> 1st 2nd 3rd \n#> 323 277 709\n\n# Gráfico de barras por clase de pasajero\nbarplot(\n  height=table(TITANIC3$pclass),\n  main=\"Distribución de pasajeros del Titanic por clase\",\n  xlab = \"Clase\",\n  ylab = \"Cantidad de pasajeros\"  \n)\n# Cantidades de pasajeros fallecidos y sobrevivientes por clase\n# (0 corresponde a fallecidos y 1 a sobrevivientes)\ntable(TITANIC3$survived, TITANIC3$pclass)\n#>    \n#>     1st 2nd 3rd\n#>   0 123 158 528\n#>   1 200 119 181\n# Gráfico de barras apiladas\nbarplot(\n  height = table(TITANIC3$survived, TITANIC3$pclass),\n  main = \"Distribución de pasajeros fallecidos y sobrevivientes por clase\",\n  xlab = \"Clase\",\n  ylab = \"Cantidad de pasajeros\",\n  col = topo.colors(2)\n)\n\n# Leyenda\nlegend(\n  x = \"topleft\",\n  inset = 0.03,\n  legend = c(\"Fallecidos\", \"Sobrevivientes\"),\n  fill = topo.colors(2),\n  horiz = TRUE\n)\n# Gráfico de barras agrupadas\nbarplot(\n  height = table(TITANIC3$survived, TITANIC3$pclass),\n  main = \"Distribución de pasajeros fallecidos y sobrevivientes por clase\",\n  xlab = \"Clase\",\n  ylab = \"Cantidad de pasajeros\",  \n  col = topo.colors(2),\n  beside = TRUE\n)\n\n# Leyenda\nlegend(\n  x = \"topleft\",\n  inset = 0.03,\n  legend = c(\"Fallecidos\", \"Sobrevivientes\"),\n  fill = topo.colors(2),\n  horiz = TRUE\n)"},{"path":"r---conceptos-básicos.html","id":"ejercicios-4","chapter":"8 R - Conceptos básicos","heading":"8.7.1 Ejercicios","text":"Muestre la distribución de pasajeros fallecidos y sobrevivientes por sexo en un gráfico de barras apiladas.Muestre la distribución de pasajeros fallecidos y sobrevivientes por sexo en un gráfico de barras agrupadas.","code":""},{"path":"r---conceptos-básicos.html","id":"tipos-de-datos","chapter":"8 R - Conceptos básicos","heading":"8.8 Tipos de datos","text":"R puede trabajar con varios tipos de datos básicos, entre los que están números, caracteres (.e. textos) y lógicos. También puede trabajar con tipos compuestos, como factores y data frames.R proporciona acceso los datos través de objetos. Un objeto es una entidad que tiene asociadas propiedades (.e. datos) y métodos (.e. funciones) para manipular esas propiedades. Un objeto puede ser, por ejemplo, un número, una hilera de texto, un vector o una matriz.Hay muchas formas de crear objetos en R. Una de las más sencillas es con los operadores de asignación. Estos son = y <- (o ->). Por ejemplo, las siguientes sentencias crean un número, un texto y un vector.Tanto x, como nombre como dias son variables. Una variable es una etiqueta que se le asigna un objeto. Una variable debe comenzar con una letra.El tipo de una variable puede consultarse con la función typeof(). Por ejemplo:continuación, se describen con más detalle algunos de los tipos de datos utilizados en el lenguaje R.","code":"\n# Número\nx <- 10\nx\n#> [1] 10\n\n# Otro número\n20 -> y\ny\n#> [1] 20\n\n# Hilera de caracteres\nnombre <- 'Manuel'\nnombre\n#> [1] \"Manuel\"\n\n# Vector de hileras de caracteres\ndias <- c('Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado')\ndias\n#> [1] \"Domingo\"   \"Lunes\"     \"Martes\"    \"Miércoles\"\n#> [5] \"Jueves\"    \"Viernes\"   \"Sábado\"\ntypeof(x)\n#> [1] \"double\"\ntypeof(y)\n#> [1] \"double\"\ntypeof(nombre)\n#> [1] \"character\"\ntypeof(dias)\n#> [1] \"character\""},{"path":"r---conceptos-básicos.html","id":"tipos-básicos","chapter":"8 R - Conceptos básicos","heading":"8.8.1 Tipos básicos","text":"R define seis tipos de datos básicos. En esta sección, se describen los más utilizados durante este curso.","code":""},{"path":"r---conceptos-básicos.html","id":"números","chapter":"8 R - Conceptos básicos","heading":"8.8.1.1 Números","text":"Pueden ser enteros (integer) o decimales (double). Se utilizan en diversos tipos de operaciones, incluyendo las aritméticas (ej. suma, resta, multiplicación, división).Para declarar números enteros puede usarse el sufijo L o la función .integer().Nótese que al declararse una variable numérica, ya sea que tenga o punto decimal, R la considera por defecto de tipo double. Para que se considere de tipo integer, debe utilizarse el sufijo L o la función .integer().","code":"\n# Declaración de variables numéricas\nx <- 5\ny <- 0.5\n\n# Suma\nx + y\n#> [1] 5.5\n\n# Tipos de datos numéricos\ntypeof(x)\n#> [1] \"double\"\ntypeof(y)\n#> [1] \"double\"\ntypeof(x + y)\n#> [1] \"double\"\n# Números enteros\nx <- 10L\ny <- as.integer(15)\n\n# Multiplicación\nx * y\n#> [1] 150\n\n# Tipos de datos enteros\ntypeof(x)\n#> [1] \"integer\"\ntypeof(y)\n#> [1] \"integer\"\ntypeof(x * y)\n#> [1] \"integer\""},{"path":"r---conceptos-básicos.html","id":"caracteres","chapter":"8 R - Conceptos básicos","heading":"8.8.1.2 Caracteres","text":"Se utilizan para representar textos. Deben estar encerrados entre comillas simples ('') o dobles (\"\").","code":"\n# Hileras de caracteres\nnombre <- \"María\"\napellido <- \"Pérez\"\n\n# Concatenación mediante la función paste()\npaste(nombre, apellido)\n#> [1] \"María Pérez\""},{"path":"r---conceptos-básicos.html","id":"lógicos","chapter":"8 R - Conceptos básicos","heading":"8.8.1.3 Lógicos","text":"Los objetos lógicos (también llamados booleanos) tienen dos posibles valores: verdadero (TRUE) o falso (FALSE).Las expresiones lógicas pueden combinarse con operadores como:& (Y, en inglés )| (O, en inglés )! (, en inglés )","code":"\n# Variable lógica\na <- 1 < 2\na\n#> [1] TRUE\n\n# Variable lógica\nb <- 1 > 2\nb\n#> [1] FALSE\n# Operador lógico AND\n(1 < 2) & (3 < 4)\n#> [1] TRUE\n\n# Operador lógico OR\n(2 + 2 == 5) | (20 <= 10)\n#> [1] FALSE\n\n# Operador lógico NOT\n!(2 + 2 == 5)\n#> [1] TRUE"},{"path":"r---conceptos-básicos.html","id":"vectores","chapter":"8 R - Conceptos básicos","heading":"8.8.1.4 Vectores","text":"Un vector es una estructura unidimensional que combina objetos del mismo tipo.","code":""},{"path":"r---conceptos-básicos.html","id":"definición","chapter":"8 R - Conceptos básicos","heading":"8.8.1.4.1 Definición","text":"Los vectores pueden definirse de varias formas como, por ejemplo, con la función c() (del inglés combine):Los vectores también pueden crearse con el operador :, el cual especifica una secuencia:La función seq() también crea un vector con base en una secuencia y permite especificar argumentos como un valor de incremento y la longitud de la secuencia.","code":"\n# Definición de un vector de números\nvector_numeros <- c(1, 7, 32, 45, 57)\nvector_numeros\n#> [1]  1  7 32 45 57\n\n# Definición de un vector de hileras de caracteres\nvector_nombres <- c(\"Álvaro\", \"Ana\", \"Berta\", \"Bernardo\")\nvector_nombres\n#> [1] \"Álvaro\"   \"Ana\"      \"Berta\"    \"Bernardo\"\n# Definición de un vector de números con la secuencia de 1 a 10\nvector_secuencia <- 1:10\nvector_secuencia\n#>  [1]  1  2  3  4  5  6  7  8  9 10\n\n# Definición de un vector de números con la secuencia de -5 a 5\nvector_secuencia <- -5:5\nvector_secuencia\n#>  [1] -5 -4 -3 -2 -1  0  1  2  3  4  5\n\n# Definición de un vector de números con la secuencia de -0.5 a 3.7\nvector_secuencia <- -0.5:3.7\nvector_secuencia\n#> [1] -0.5  0.5  1.5  2.5  3.5\n# Definición de un vector de números con la secuencia de 1 a 10\nvector_secuencia <- seq(1, 10)\nvector_secuencia\n#>  [1]  1  2  3  4  5  6  7  8  9 10\n\n# Definición de un vector de números con la secuencia de 0.5 a 15.3, con incremento de 2\nvector_secuencia <- seq(from=0.5, to=15.3, by=2)\nvector_secuencia\n#> [1]  0.5  2.5  4.5  6.5  8.5 10.5 12.5 14.5\n\n# Definición de un vector de números con la secuencia de 1.5 a 9.4, con longitud de 4\nvector_secuencia <- seq(from=1.5, to=9.4, length.out=4)\nvector_secuencia\n#> [1] 1.500000 4.133333 6.766667 9.400000"},{"path":"r---conceptos-básicos.html","id":"indexación","chapter":"8 R - Conceptos básicos","heading":"8.8.1.4.2 Indexación","text":"Los elementos de un vector se acceden través de sus índices (.e. posiciones). La primera posición corresponde al índice 1, la segunda al índice 2 y así sucesivamente. Los índices se especifican entre paréntesis cuadrados ([]), ya sea para una posición específica o para un rango de posiciones. También es posible especificar los índices que se desea excluir.El operador : puede utilizarse para especificar un rango de índices:Con la función c(), es posible especificar un conjunto de índices particulares:Los números negativos pueden usarse para excluir índices:Los valores lógicos TRUE y FALSE también pueden usarse para incluir y excluir índices de un vector:","code":"\n# Vector de nombres de países\npaises <- c(\"Argentina\", \"Francia\", \"China\", \"Australia\", \"México\")\npaises\n#> [1] \"Argentina\" \"Francia\"   \"China\"     \"Australia\"\n#> [5] \"México\"\n\n# Elemento en el índice 3\npaises[3]\n#> [1] \"China\"\n# Elementos entre los índices 2 y 4 (2, 3 y 4)\npaises[2:4]\n#> [1] \"Francia\"   \"China\"     \"Australia\"\n# Elementos entre los índices 1, 4 y 5\npaises[c(1, 4, 5)]\n#> [1] \"Argentina\" \"Australia\" \"México\"\n# Exclusión de los índices 3 y 4\npaises[c(-3, -4)]\n#> [1] \"Argentina\" \"Francia\"   \"México\"\n# Se incluyen los índices 1, 2 y 4; y se excluyen los índices 3 y 5\npaises[c(TRUE, TRUE, FALSE, TRUE, FALSE)]\n#> [1] \"Argentina\" \"Francia\"   \"Australia\""},{"path":"r---conceptos-básicos.html","id":"operaciones","chapter":"8 R - Conceptos básicos","heading":"8.8.1.4.3 Operaciones","text":"En los vectores pueden aplicarse operaciones aritméticas:Y también pueden realizarse operaciones relacionales:","code":"\na <- c(1, 3, 5, 7)\nb <- c(2, 4, 6, 8)\n\n# Suma de vectores\na + b\n#> [1]  3  7 11 15\n\n# Multiplicación de vectores\na * b\n#> [1]  2 12 30 56\n# Comparación con el operador <\na < b\n#> [1] TRUE TRUE TRUE TRUE"},{"path":"r---conceptos-básicos.html","id":"matrices","chapter":"8 R - Conceptos básicos","heading":"8.8.1.5 Matrices","text":"Una matriz es una estructura bidimensional de filas y columnas.","code":""},{"path":"r---conceptos-básicos.html","id":"definición-1","chapter":"8 R - Conceptos básicos","heading":"8.8.1.5.1 Definición","text":"Las matrices se definen mediante la función matrix().La función list() se utiliza, en este caso, para combinar vectores. En general, se usa para combinar datos de cualquier tipo.","code":"\n# Definición de una matriz de 3 x 3 con elementos de la secuencia 1:9 distribuidos en las columnas\nm <- matrix(1:9, nrow=3, ncol=3)\nm\n#>      [,1] [,2] [,3]\n#> [1,]    1    4    7\n#> [2,]    2    5    8\n#> [3,]    3    6    9\n\n# Definición de una matriz de 3 x 3 con elementos de la secuencia 1:9 distribuidos en las filas\nm <- matrix(1:9, nrow=3, ncol=3, byrow=TRUE)\nm\n#>      [,1] [,2] [,3]\n#> [1,]    1    2    3\n#> [2,]    4    5    6\n#> [3,]    7    8    9\n\n# Definición de una matriz de 3 x 2 con nombres para las filas y las columnas\ndatos <- c(18, 500, 25, 1000, 30, 2000)\nfilas <- c(\"Ana\", \"Mario\", \"Laura\")\ncolumnas <- c(\"Edad\", \"Salario\")\n\nm <- matrix(datos, nrow=3, ncol=2, byrow=TRUE, dimnames=list(filas, columnas))\nm\n#>       Edad Salario\n#> Ana     18     500\n#> Mario   25    1000\n#> Laura   30    2000"},{"path":"r---conceptos-básicos.html","id":"indexación-1","chapter":"8 R - Conceptos básicos","heading":"8.8.1.5.2 Indexación","text":"La indexación de matrices es similar la de vectores, pero deben especificarse índices tanto para filas como para columnas.","code":"\n# Elemento en la posición [2,2] (segunda fila, segunda columna)\nm[2, 2]\n#> [1] 1000\n\n# Elementos de la primera fila\nm[1,]\n#>    Edad Salario \n#>      18     500\n\n# Elementos de la segunda columna\nm[, 2]\n#>   Ana Mario Laura \n#>   500  1000  2000\n\n# Elementos de las filas 1 y 2\nm[1:2, ]\n#>       Edad Salario\n#> Ana     18     500\n#> Mario   25    1000\n\n# Elementos de la fila \"Mario\"\nm[\"Mario\", ]\n#>    Edad Salario \n#>      25    1000\n\n# Elementos de la columna \"Salario\"\nm[, \"Salario\"]\n#>   Ana Mario Laura \n#>   500  1000  2000"},{"path":"r---conceptos-básicos.html","id":"operaciones-1","chapter":"8 R - Conceptos básicos","heading":"8.8.1.5.3 Operaciones","text":"De manera similar los vectores, en las matrices pueden realizarse operaciones aritméticas y relacionales.","code":"\na <- matrix(1:4, nrow=2, ncol=2)\na\n#>      [,1] [,2]\n#> [1,]    1    3\n#> [2,]    2    4\n\nb <- matrix(5:8, nrow=2, ncol=2)\nb\n#>      [,1] [,2]\n#> [1,]    5    7\n#> [2,]    6    8\n\n# Suma de matrices\na + b\n#>      [,1] [,2]\n#> [1,]    6   10\n#> [2,]    8   12\n\n# Multiplicación de matrices\na * b\n#>      [,1] [,2]\n#> [1,]    5   21\n#> [2,]   12   32\n\n# Comparación de matrices con el operador >\na > b\n#>       [,1]  [,2]\n#> [1,] FALSE FALSE\n#> [2,] FALSE FALSE"},{"path":"r---conceptos-básicos.html","id":"tipos-compuestos","chapter":"8 R - Conceptos básicos","heading":"8.8.2 Tipos compuestos","text":"","code":""},{"path":"r---conceptos-básicos.html","id":"factores","chapter":"8 R - Conceptos básicos","heading":"8.8.2.1 Factores","text":"Los factores se utilizan para representar datos categóricos. Un factor corresponde un conjunto de categorías correspondientes un concepto (ej. [“Sí”, “”], [“Casado”, “Soltero”], [“Alto”, “Medio”, “Bajo”]).Internamente, los factores se representan en R como números enteros con etiquetas asociadas. pesar de que los factores parecen (y pueden funcionar como) hileras de caracteres, en realidad son números y debe tenerse cuidado de manejarlos como caracteres.Los elementos de un factor se denominan niveles (levels) y, por defecto, se almacenan en orden alfabético.","code":""},{"path":"r---conceptos-básicos.html","id":"definición-2","chapter":"8 R - Conceptos básicos","heading":"8.8.2.1.1 Definición","text":"Un factor se crea con la función factor().","code":"\n# Factor de valores de sexo\nsexo <- factor(c(\"Masculino\", \"Femenino\", \"Femenino\", \"Masculino\"))"},{"path":"r---conceptos-básicos.html","id":"operaciones-2","chapter":"8 R - Conceptos básicos","heading":"8.8.2.1.2 Operaciones","text":"R proporciona una gran variedad de funciones para manejar factores. Seguidamente, se ejemplifican algunas de estas.","code":"\n# Etiquetas de los niveles\nlevels(sexo)\n#> [1] \"Femenino\"  \"Masculino\"\n\n# Cantidad de niveles\nnlevels(sexo)\n#> [1] 2\n\n# Conteo de elementos de cada uno de los niveles del factor\ntable(sexo)\n#> sexo\n#>  Femenino Masculino \n#>         2         2"},{"path":"r---conceptos-básicos.html","id":"data-frames","chapter":"8 R - Conceptos básicos","heading":"8.8.2.2 Data Frames","text":"Los data frames son estructuras bidimensionales compuestas por varios vectores, de manera similar una matriz. Por lo general, las filas de la matriz corresponden observaciones (o cases) y las columnas variables. La definición de un data frame puede incluir nombres para cada observación y para cada variable. Los data frames implementan un conjunto de funciones similares las de una hoja electrónica o la tabla de una base de datos relacional. Son fundamentales para el manejo de datos en R.","code":""},{"path":"r---conceptos-básicos.html","id":"definición-3","chapter":"8 R - Conceptos básicos","heading":"8.8.2.2.1 Definición","text":"La función data.frame() crea un data frame partir de vectores que serán las columnas del data frame.","code":"\n# Vector de nombres de países\npaises <- c(\"PAN\", \"CRI\", \"NIC\", \"SLV\", \"HND\", \"GTM\", \"BLZ\", \"DOM\")\n\n# Vector de cantidades de habitantes de cada país (en millones)\npoblaciones <- c(4.1, 5.0, 6.2, 6.4, 9.2, 16.9, 0.3, 10.6)\n\n# Creación de un data frame a partir de los dos vectores\npoblaciones_paises <- \n  data.frame(\n    pais = paises, \n    poblacion = poblaciones\n  )\n\n# Impresión del data frame\npoblaciones_paises\n#>   pais poblacion\n#> 1  PAN       4.1\n#> 2  CRI       5.0\n#> 3  NIC       6.2\n#> 4  SLV       6.4\n#> 5  HND       9.2\n#> 6  GTM      16.9\n#> 7  BLZ       0.3\n#> 8  DOM      10.6"},{"path":"r---conceptos-básicos.html","id":"indexación-2","chapter":"8 R - Conceptos básicos","heading":"8.8.2.2.2 Indexación","text":"Los datos de un data frame pueden accederse principalmente de dos formas. La primera es mediante la misma sintaxis [fila, columna] que se utiliza en las matrices.Además, mediante el operador $, es posible acceder las columnas (.e. variables) del data frame.","code":"\n# Fila 1\npoblaciones_paises[1, ]\n#>   pais poblacion\n#> 1  PAN       4.1\n\n# Filas 1, 5 y 7\npoblaciones_paises[c(1, 5, 7), ]\n#>   pais poblacion\n#> 1  PAN       4.1\n#> 5  HND       9.2\n#> 7  BLZ       0.3\n\n# Columna 2\npoblaciones_paises[, 2]\n#> [1]  4.1  5.0  6.2  6.4  9.2 16.9  0.3 10.6\n\n# Fila 1, columna 2\npoblaciones_paises[1, 2]\n#> [1] 4.1\n\n# Filas 1:4, columna 2\npoblaciones_paises[1:4, 2]\n#> [1] 4.1 5.0 6.2 6.4\n# Columna de nombres de países\npoblaciones_paises$pais\n#> [1] \"PAN\" \"CRI\" \"NIC\" \"SLV\" \"HND\" \"GTM\" \"BLZ\" \"DOM\"\n\n# Modificación de los valores de toda una columna\npoblaciones_paises$poblacion = poblaciones_paises$poblacion*2\npoblaciones_paises\n#>   pais poblacion\n#> 1  PAN       8.2\n#> 2  CRI      10.0\n#> 3  NIC      12.4\n#> 4  SLV      12.8\n#> 5  HND      18.4\n#> 6  GTM      33.8\n#> 7  BLZ       0.6\n#> 8  DOM      21.2"},{"path":"r---conceptos-básicos.html","id":"operaciones-3","chapter":"8 R - Conceptos básicos","heading":"8.8.2.2.3 Operaciones","text":"R proporciona una gran variedad de funciones para manejar data frames. Las siguientes son algunas de las más utilizadas.La función read.table() lee los datos contenidos en un archivo de texto y los retorna en un data frame. read.csv() es una función derivada, con valores por defecto orientados los archivos de valores separados por comas (CSV, Comma Separated Values). Como argumento principal, read.csv() recibe la ruta del archivo CSV, el cual puede encontrarse en un disco local, en la Web o en otra ubicación.","code":"\n# Lectura de archivo CSV ubicado en la Web\ncovid <- \n  read.csv(\"https://raw.githubusercontent.com/gf0604-procesamientodatosgeograficos/2022-i/main/datos/cepredenac/covid/covid-centroamericard-20210422.csv\")\n\ncovid\n#>   pais fallecidos recuperados activos positivos\n#> 1  PAN       6198      351949    3845    361992\n#> 2  CRI       3125      199779   32370    235274\n#> 3  GTM       7345      194075   16725    218145\n#> 4  HND       4981       77020  121358    203359\n#> 5  SLV       2089       64208    1864     68161\n#> 6  BLZ        318       12164     114     12596\n#> 7  NIC        181        5212      57      5450"},{},{"path":"r---conceptos-básicos.html","id":"otros-2","chapter":"8 R - Conceptos básicos","heading":"8.8.3 Otros","text":"","code":""},{"path":"r---conceptos-básicos.html","id":"fechas","chapter":"8 R - Conceptos básicos","heading":"8.8.3.1 Fechas","text":"Las fecha se manejan en R mediante un tipo especial que permite realizar operaciones como diferencias, agrupamientos y otras. Internamente, las fechas en R se almacenan como un número que representa la cantidad de días transcurridos desde el 1 de enero de 1970 (1970-01-01).","code":""},{"path":"r---conceptos-básicos.html","id":"operaciones-4","chapter":"8 R - Conceptos básicos","heading":"8.8.3.1.1 Operaciones","text":"La función Sys.Date() retorna la fecha actual.La función .Date() convierte datos entre los tipos fecha y carácter, de acuerdo con un formato.Hay una lista de formatos de fechas en Date Formats R - R-bloggers.","code":"\n# Fecha actual\nfecha_actual <- Sys.Date()\nfecha_actual\n#> [1] \"2022-06-27\"\n\n# Tipo de datos\ntypeof(fecha_actual)\n#> [1] \"double\"\n\n# Clase\nclass(fecha_actual)\n#> [1] \"Date\"\n# Conversión de fecha en formato año-mes-día\nfecha_caracter_01 <- \"2020-01-01\"\nfecha_01 <- as.Date(fecha_caracter_01, format=\"%Y-%m-%d\")\nfecha_01\n#> [1] \"2020-01-01\"\n\n# Conversión de fecha en formato día/mes/año\nfecha_caracter_02 <- \"31/01/2020\"\nfecha_02 <- as.Date(fecha_caracter_02, format=\"%d/%m/%Y\")\nfecha_02\n#> [1] \"2020-01-31\"\n\n# Diferencia entre fechas\nfecha_02 - fecha_01\n#> Time difference of 30 days"},{"path":"r---conceptos-básicos.html","id":"definición-de-funciones","chapter":"8 R - Conceptos básicos","heading":"8.9 Definición de funciones","text":"Además de todas las funciones disponibles en la distribución base de R y en sus diferentes paquetes, R permite que los programadores definan sus propias funciones.Toda función tiene tres partes esenciales:Un nombre.Un conjunto de argumentos.Un conjunto de líneas de código, también llamado el cuerpo de la función.Para programar una función, debe definirse cada una de esas partes por medio de la palabra función function().Por ejemplo, la siguiente función calcula la nota final de un curso con base en los promedios de exámenes, proyectos y tareas.La función return() es la que define el valor de retorno de la función. Si se incluye, la función retorna la última expresión evaluada.Ahora que está definida, la función nota_final() puede ser invocada, con diferentes argumentos:Si se desea darle al usuario la opción de omitir algunos argumentos, se les puede asignar un valor por defecto.Seguidamente, la función nota_final() se redefine asignando valores por defecto algunos de los argumentos:","code":"\nmi_funcion <- function(argumento_1, argumento_2, argumento_n) {\n  # Cuerpo de la función\n}\nnota_final <- function(promedio_examenes,\n                       promedio_proyectos,\n                       promedio_tareas) {\n  factor_examenes <- promedio_examenes * 0.5\n  factor_proyectos <- promedio_proyectos * 0.4\n  factor_tareas <- promedio_tareas * 0.1\n  \n  return(factor_examenes + factor_proyectos + factor_tareas)\n}\n# Si ni se incluyen los nombres de los argumentos, la función asume que se ingresan en el mismo orden en el que fueron definidos\nnota_final(100, 50, 0)\n#> [1] 70\n\n# El uso de los nombres de argumentos permite modificar su orden\nnota_final(promedio_examenes =  100, promedio_tareas =  0, promedio_proyectos = 50)\n#> [1] 70\nnota_final <- function(promedio_examenes,\n                       promedio_proyectos = 0,\n                       promedio_tareas = 0) {\n  factor_examenes <- promedio_examenes * 0.5\n  factor_proyectos <- promedio_proyectos * 0.4\n  factor_tareas <- promedio_tareas * 0.1\n  \n  # Al no llamarse a la función return(), se retorna la última expresión:\n  factor_examenes + factor_proyectos + factor_tareas\n}\n\n# Se utiliza el valor por defecto (0) para el argumento promedio_tareas\nnota_final(promedio_examenes = 100, promedio_proyectos = 50)\n#> [1] 70\n\n# Se llama la función usando la posición del primer argumento y el nombre del segundo\nnota_final(100, promedio_proyectos = 50)\n#> [1] 70"},{"path":"r---conceptos-básicos.html","id":"ejercicios-6","chapter":"8 R - Conceptos básicos","heading":"8.9.1 Ejercicios","text":"Defina una función con nombre celsius_a_fahrenheit() que reciba como argumento una cantidad en grados Celsius y retorne el equivalente en grados Fahrenheit.Defina una función con nombre fahrenheit_a_celsius() que reciba como argumento una cantidad en grados Fahrenheit y retorne el equivalente en grados Celsius.Defina una función con nombre imc() para calcular el índice de masa corporal (IMC) de una persona con base en su peso (en kilogramos) y su estatura (en metros).","code":""},{"path":"r---conceptos-básicos.html","id":"condicionales","chapter":"8 R - Conceptos básicos","heading":"8.10 Condicionales","text":"Las sentencias condicionales evalúan una expresión lógica (.e. condición) y ejecutan, o , un bloque de intrucciones dependiendo de si la expresión es verdadera (TRUE) o falsa (FALSE). Permiten que los programas “tomen decisiones” y varíen su curso de acción.Los condicionales en R se implementa mediante la sentencia y sus cláusulas else y else .","code":""},{"path":"r---conceptos-básicos.html","id":"la-sentencia-if","chapter":"8 R - Conceptos básicos","heading":"8.10.1 La sentencia if","text":"La sentencia evalúa una condición (.e. una expresión lógica) y ejecuta un bloque de instrucciones, si es verdadera. El bloque se delimita con los caracteres de “llaves”: {}.Por ejemplo:Ya sea que se ejecute o el bloque del , el programa continúa con las instrucciones que siguen al bloque, si las hay.","code":"\nif (condicion) {\n  # bloque de instrucciones a ejecutar si la condicion es verdadera\n}\nedad <- 25\n\nif (edad >= 18) {\n  print(\"Adulto\")\n}\n#> [1] \"Adulto\""},{"path":"r---conceptos-básicos.html","id":"la-claúsula-else","chapter":"8 R - Conceptos básicos","heading":"8.10.2 La claúsula else","text":"Una sentencia puede ir seguida de una cláusula else, la cual define un bloque que se ejecuta si la condición es falsa.\nPor ejemplo:","code":"\nedad <- 15\n\nif (edad >= 18) {\n  print(\"Adulto\")\n} else {\n  print(\"Menor\")\n}\n#> [1] \"Menor\""},{"path":"r---conceptos-básicos.html","id":"la-cláusula-else-if","chapter":"8 R - Conceptos básicos","heading":"8.10.3 La cláusula else if","text":"Una sentencia también puede ir seguida de una o varias cláusulas else , las cuales evalúan condiciones adicionales.Las cláusulas else deben escribirse antes de la cláusula else, la cual es siempre la última, si es que está presente. Tanto las cláusulas else como la cláusula else son opcionales.","code":"\nedad <- 70\n\nif (edad < 18) {\n  print(\"Menor\")\n} else if (edad < 65) {\n  print(\"Adulto\")\n} else {\n  print(\"Adulto mayor\")\n}\n#> [1] \"Adulto mayor\""},{"path":"r---conceptos-básicos.html","id":"ejercicios-7","chapter":"8 R - Conceptos básicos","heading":"8.10.4 Ejercicios","text":"Defina una función con nombre interpretacion_imc() que reciba como argumento un número correspondiente al índice de masa corporal (IMC) de una persona. Debe retornar una hilera de caracteres correspondiente la interpretación del IMC (“Bajo peso”, “Normal”, “Sobrepeso”, “Obesidad”), de acuerdo con la tabla disponible en Índice de masa corporal - Wikipedia.","code":""},{"path":"r---conceptos-básicos.html","id":"ciclos","chapter":"8 R - Conceptos básicos","heading":"8.11 Ciclos","text":"Los ciclos permiten ejecutar tareas de manera repetitiva en un programa. Algunos ciclos se ejecutan una cantidad definida de veces, mientras que otros lo hacen mientras se cumple una condición lógica. Pueden usarse en combinación con cláusulas que terminan anticipadamente el ciclo o que omiten algunas de sus iteraciones.Los ciclos en R se implementan mediante las sentencias , y repeat, en combinación con las sentencias break y next.R provee varias funciones que implementan ciclos de manera implícita, tales como apply(), tapply() y lapply(). Adicionalmente, hay muchas operaciones (ej. las aritméticas) que están “vectorizadas”, por lo que es necesario utilizarlas en ciclos. El uso de código vectorizado es muy recomendado en R, por ser muy eficiente.","code":""},{"path":"r---conceptos-básicos.html","id":"sentencias-básicas-para-manejo-de-ciclos","chapter":"8 R - Conceptos básicos","heading":"8.11.1 Sentencias básicas para manejo de ciclos","text":"","code":""},{"path":"r---conceptos-básicos.html","id":"la-sentencia-for","chapter":"8 R - Conceptos básicos","heading":"8.11.1.1 La sentencia for","text":"La sentencia repite las instrucciones contenidas en un bloque para cada uno de los elementos de un vector o lista. En cada iteración, el valor del elemento que está siendo procesado se almacena en una variable.Por ejemplo, el siguiente fragmento de código utiliza un ciclo de tipo para recorrer un vector de nombres e imprimir un saludo para cada uno.En el siguiente ejemplo, se utiliza otro ciclo para recorrer un vector de números y sumar sus elementos.","code":"\nfor (variable in vector) {\n  # bloque de instrucciones\n}\nvector_nombres <- c(\"Andrés\", \"Beatriz\", \"Carlos\", \"Marta\", \"Pedro\", \"Sara\")\n\nfor (nombre in vector_nombres) {\n  cat(\"Hola\", nombre, \"\\n\")\n}\n#> Hola Andrés \n#> Hola Beatriz \n#> Hola Carlos \n#> Hola Marta \n#> Hola Pedro \n#> Hola Sara\nvector_numeros <- c(29.6, -36.81, 31.85, 25.71, 90.2, 0.4)\n\nsuma <- 0\n\nfor (x in vector_numeros) {\n  suma <- suma + x\n}\n\ncat(\"Suma:\", suma)\n#> Suma: 140.95"},{"path":"r---conceptos-básicos.html","id":"ejercicios-8","chapter":"8 R - Conceptos básicos","heading":"8.11.1.1.1 Ejercicios","text":"Utilice un ciclo para recorrer el vector del ejemplo anterior y calcular el promedio de sus elementos.Seguidamente, se utiliza dos “anidados” para sumar los elementos de cada una de las columnas de una matriz.","code":"\nm <- matrix(1:12, nrow=3, ncol=4)\nm\n#>      [,1] [,2] [,3] [,4]\n#> [1,]    1    4    7   10\n#> [2,]    2    5    8   11\n#> [3,]    3    6    9   12\n\n# Ciclo externo para recorrer las columnas de la matriz\nfor (j in 1:ncol(m)) {\n  suma_columna <- 0\n  # Ciclo interno para recorrer las elementos de cada columna\n  for (i in 1:nrow(m)) {\n    suma_columna <- suma_columna + m[i, j]\n  }\n  print(suma_columna)\n}\n#> [1] 6\n#> [1] 15\n#> [1] 24\n#> [1] 33"},{"path":"r---conceptos-básicos.html","id":"ejercicios-9","chapter":"8 R - Conceptos básicos","heading":"8.11.1.1.2 Ejercicios","text":"Utilice dos ciclos anidados para recorrer la matriz del ejemplo anterior y calcular el promedio de cada una de sus columnas.","code":""},{"path":"r---conceptos-básicos.html","id":"la-sentencia-while","chapter":"8 R - Conceptos básicos","heading":"8.11.1.2 La sentencia while","text":"La sentencia evalúa una condición (.e. una expresión lógica) en cada iteración del ciclo y ejecuta las intrucciones del bloque mientras la condición sea verdadera. Generalmente, en algún momento la condición se vuelve falsa y así finaliza el ciclo.En el siguiente ejemplo, se utiliza un ciclo para preguntarle al usuario cuál es la respuesta definitiva al sentido de la vida, el universo y todo lo demás y se continúa haciendo la pregunta hasta que responda correctamente:","code":"\nwhile (condicion) {\n  # bloque de instrucciones \n}\n# Función para leer una respuesta desde la pantalla\nleer_respuesta <- function() {\n  readline(prompt=\"¿Cual es la respuesta definitiva al sentido de la vida, el universo y todo lo demás? \")\n}\n\n# Si la respuesta es incorrecta, se repite la pregunta hasta que el usuario conteste correctamente\nwhile (leer_respuesta() != \"42\") {   \n  print(\"¡Su respuesta es incorrecta!\")\n}"},{"path":"r---conceptos-básicos.html","id":"ejercicios-10","chapter":"8 R - Conceptos básicos","heading":"8.11.1.2.1 Ejercicios","text":"Utilice un ciclo para implementar el cálculo del promedio de los elementos de un vector. Sugerencia: utilice la función length() para obtener la longitud del vector y así saber cuando terminar de recorrerlo.","code":""},{"path":"r---conceptos-básicos.html","id":"la-sentencia-repeat","chapter":"8 R - Conceptos básicos","heading":"8.11.1.3 La sentencia repeat","text":"La sentencia repeat implementa un ciclo que se repite indefinidamente. Puede interrumpirse con una sentencia break.Los ciclos repeat tienen una estructura más sencilla que los . Algo que los diferencia es que los bloques de los ciclos repeat entran ejecutarse al menos una vez.En el siguiente ejemplo, se utiliza un ciclo repeat para implementar la pregunta y lectura de la respuesta que anteriormente se implementó con un ciclo .","code":"\nrepeat {\n  # bloque de instrucciones \n}\n# Función para leer una respuesta desde la pantalla\nleer_respuesta <- function() {\n  readline(prompt=\"¿Cual es la respuesta definitiva al sentido de la vida, el universo y todo lo demás? \")\n}\n\n# Ciclo para imprimir la pregunta y leer la respuesta hasta que esta sea correcta\nrepeat {\n  respuesta <- leer_respuesta()\n  if (respuesta != \"42\") {\n    # Respuesta incorrecta\n    print(\"¡Su respuesta es incorrecta!\")\n  } else {\n    # Respuesta correcta. Se interrumpe el ciclo.\n    break\n  }\n}"},{"path":"r---conceptos-básicos.html","id":"las-sentencias-break-y-next","chapter":"8 R - Conceptos básicos","heading":"8.11.1.4 Las sentencias break y next","text":"La sentencia break interrumpe un ciclo. La ejecución del programa continúa con la instrucción siguiente al bloque del ciclo.En el siguiente ciclo , se suman uno uno los números de un vector, pero se usa un break para interrumpir el ciclo cuando el acumulado es mayor que 100.Por su parte, la sentencia next retorna el control al principio del bloque. Las instrucciones que hay después del next se ejecutan. La siguiente iteración del ciclo (si la hay), se inicia entonces.El siguiente ciclo recorre un vector de números. Se utiliza la sentencia next para “saltar” los números impares y sumar solo los pares.","code":"\nvector_numeros <- c(17, 23, 37, 41, 52, 64, 75)\n\nacumulado <- 0\n\nfor (x in vector_numeros) {\n  acumulado <- acumulado + x\n  cat(\"Acumulado:\", acumulado, \"\\n\")\n  if (acumulado >= 100) {\n    cat(\"Se superó el límite de 100 en el acumulado\")\n    break\n  }\n}\n#> Acumulado: 17 \n#> Acumulado: 40 \n#> Acumulado: 77 \n#> Acumulado: 118 \n#> Se superó el límite de 100 en el acumulado\nvector_numeros <- c(17, 23, 37, 41, 52, 64, 75)\n\nsuma_pares <- 0\n\nfor (x in vector_numeros) {\n  if (x %% 2 == 0) {\n    # Número par: se suma\n    suma_pares <- suma_pares + x\n  } else {\n    # Número impar: se \"salta\" al siguiente número\n    next\n  }\n}\n\ncat(\"Suma de los números pares:\", suma_pares)\n#> Suma de los números pares: 116"},{"path":"r---conceptos-básicos.html","id":"las-funciones-apply","chapter":"8 R - Conceptos básicos","heading":"8.11.2 Las funciones apply()","text":"Esta es una familia de funciones que manipulan subconjuntos de datos obtenidos partir de matrices, listas y data frames, los cuales son recorridos de una forma repetitiva. Pueden funcionar como una alternativa los ciclos y aplicar funciones en los subconjuntos de datos como, por ejemplo, funciones estadísticas en las columnas de una matriz o de un data frame. Su uso es muy recomendado por su eficiencia, flexibilidad y simplicidad.Entre estas funciones, pueden mencionarse apply(), lapply(), sapply(), vapply(), mapply(), rapply() y tapply().","code":""},{"path":"r---conceptos-básicos.html","id":"apply","chapter":"8 R - Conceptos básicos","heading":"8.11.2.1 apply()","text":"La función apply() toma como entrada un arreglo o una matriz y aplica alguna función sobre sus filas o columnas.La sintaxis de la función es:En donde:\n- X: es un arreglo o matriz.\n- MARGIN: MARGIN = 1 significa que la función actúa en las filas, MARGIN = 2 significa que la función actúa en las columnas y MARGIN = c(1, 2) significa que la función actúa en las filas y en las columnas.\n- FUN: es la función que se aplicará cada uno de los elementos de X.En el siguiente ejemplo, se utiliza la función apply() para sumar los elementos de las columnas de una matriz.","code":"\napply(X, MARGIN, FUN, ...)\nm <- matrix(1:12, nrow=3, ncol=4)\nm\n#>      [,1] [,2] [,3] [,4]\n#> [1,]    1    4    7   10\n#> [2,]    2    5    8   11\n#> [3,]    3    6    9   12\n\n# Suma de las columnas\napply(m, 2, sum)\n#> [1]  6 15 24 33"},{"path":"r---conceptos-básicos.html","id":"ejercicios-11","chapter":"8 R - Conceptos básicos","heading":"8.11.2.1.1 Ejercicios","text":"Utilice la función apply() para obtener el promedio de los elementos de cada columna de la matriz del ejemplo anterior.","code":""},{"path":"r---conceptos-básicos.html","id":"lapply","chapter":"8 R - Conceptos básicos","heading":"8.11.2.2 lapply()","text":"La función lapply() toma como entrada un vector o lista y retorna una lista de la misma longitud en la que cada uno de sus elementos es el resultado de aplicar una función al vector o lista de entrada.La sintaxis de la función es:En donde:\n- X: es un vector o lista.\n- FUN: es la función que se aplicará cada elemento de X. Algunas funciones predefinidas que pueden utilizarse incluyen mean(), median(), sum(), min() y max(). También pueden usarse funciones definidas por el usuario.En los siguientes ejemplos, se utiliza lapply() para aplicar diferentes funciones un vector de nombres de personas.","code":"\nlapply(X, FUN, ...)\nnombres <- c(\"Andrés\", \"Beatriz\", \"Carlos\", \"Marta\", \"Pedro\", \"Sara\")\n\n# Los nombres de la lista se transforman a minúscula\nnombres_en_minuscula <- lapply(nombres, tolower)\nnombres_en_minuscula\n#> [[1]]\n#> [1] \"andrés\"\n#> \n#> [[2]]\n#> [1] \"beatriz\"\n#> \n#> [[3]]\n#> [1] \"carlos\"\n#> \n#> [[4]]\n#> [1] \"marta\"\n#> \n#> [[5]]\n#> [1] \"pedro\"\n#> \n#> [[6]]\n#> [1] \"sara\"\n\n# Se genera un saludo para cada nombre\nnombres_con_saludo <- lapply(nombres, function(arg1, arg2) paste(arg1, arg2), arg1=\"Hola\")\nnombres_con_saludo\n#> [[1]]\n#> [1] \"Hola Andrés\"\n#> \n#> [[2]]\n#> [1] \"Hola Beatriz\"\n#> \n#> [[3]]\n#> [1] \"Hola Carlos\"\n#> \n#> [[4]]\n#> [1] \"Hola Marta\"\n#> \n#> [[5]]\n#> [1] \"Hola Pedro\"\n#> \n#> [[6]]\n#> [1] \"Hola Sara\""},{"path":"r---conceptos-básicos.html","id":"tapply","chapter":"8 R - Conceptos básicos","heading":"8.11.2.3 tapply()","text":"La función tapply() aplica una función cada nivel de un factor.La sintaxis de la función es:En donde:\n- X: es un objeto, tipicamente un vector.\n- INDEX: es una lista que contiene un factor.\n- FUN: es la función que se aplicará cada elemento de X.En el siguiente ejemplo, se utiliza tapply() para calcular la mediana del ancho del sépalo para cada especie del conjunto de datos iris.","code":"\ntapply(X, INDEX, FUN)\ndata(iris)\ntapply(iris$Sepal.Width, iris$Species, median)\n#>     setosa versicolor  virginica \n#>        3.4        2.8        3.0"},{"path":"r---conceptos-básicos.html","id":"ejercicios-12","chapter":"8 R - Conceptos básicos","heading":"8.11.2.3.1 Ejercicios","text":"Utilice la función tapply() para obtener el promedio de las longitudes de los pétalos para cada especie del conjunto de datos iris.","code":""},{"path":"r---conceptos-básicos.html","id":"vectorización","chapter":"8 R - Conceptos básicos","heading":"8.11.3 Vectorización","text":"En R, muchas operaciones y funciones pueden ser vectorizadas, lo que significa que pueden aplicarse los elementos de un vector sin necesidad de iterar uno por uno en estos.Por ejemplo, considérese el siguiente fragmento de código vectorizado, que utiliza un ciclo para convertir los números de un vector sus valores absolutos:El siguiente fragmento de código realiza la misma tarea, pero de forma vectorizada:","code":"\nvector_numeros <- c(23, -17, 34, 0, -12, 55)\n\nfor (i in 1:length(vector_numeros)) {\n  if (vector_numeros[i] < 0) {\n    vector_numeros[i] <- -vector_numeros[i]\n  }\n}\n\nvector_numeros\n#> [1] 23 17 34  0 12 55\nvector_numeros <- c(23, -17, 34, 0, -12, 55)\n\n# Se usa una expresión lógica para seleccionar los elementos del vector < 0\nnegativos <- vector_numeros < 0\nnegativos\n#> [1] FALSE  TRUE FALSE FALSE  TRUE FALSE\n\n# Se cambian los elementos seleccionados en el paso anterior sin utilizar el for\nvector_numeros[negativos] <- vector_numeros[negativos] * -1\n\nvector_numeros\n#> [1] 23 17 34  0 12 55"},{"path":"r---conceptos-básicos.html","id":"ejercicios-13","chapter":"8 R - Conceptos básicos","heading":"8.11.3.1 Ejercicios","text":"Utilice código vectorizado para implementar una función que reciba como argumento un vector de números y retorne el mismo vector con los elementos impares (solo los impares) elevados al cuadrado.","code":""},{"path":"r---conceptos-básicos.html","id":"recursos-de-interés-6","chapter":"8 R - Conceptos básicos","heading":"8.12 Recursos de interés","text":"Find Open Datasets Machine Learning Projects | Kaggle. (s. f.). Recuperado 24 de abril de 2022, de https://www.kaggle.com/datasetsNewest «r» Questions. (s. f.). Stack Overflow. Recuperado 24 de abril de 2022, de https://stackoverflow.com/questions/tagged/rR Language Definition. (s. f.). Recuperado 24 de abril de 2022, de https://cran.r-project.org/doc/manuals/r-release/R-lang.html","code":""},{"path":"r-markdown.html","id":"r-markdown","chapter":"9 R Markdown","heading":"9 R Markdown","text":"","code":""},{"path":"r-markdown.html","id":"trabajo-previo-4","chapter":"9 R Markdown","heading":"9.1 Trabajo previo","text":"","code":""},{"path":"r-markdown.html","id":"lecturas-2","chapter":"9 R Markdown","heading":"9.1.1 Lecturas","text":"Xie, Y., Allaire, J. J., & Grolemund, G. (2018). R Markdown: definitive guide. CRC Press. https://bookdown.org/yihui/rmarkdown/Xie, Y., Dervieux, C., & Riederer, E. (2020). R Markdown Cookbook. CRC Press. https://bookdown.org/yihui/rmarkdown-cookbook/","code":""},{"path":"r-markdown.html","id":"resumen-8","chapter":"9 R Markdown","heading":"9.2 Resumen","text":"En este capítulo, se estudia R Markdown, un formato que permite insertar código R, y sus salidas, en documentos escritos en Markdown. Se describe la anatomía de un documento R Markdown y se presenta un ejemplo.","code":""},{"path":"r-markdown.html","id":"características-generales-1","chapter":"9 R Markdown","heading":"9.3 Características generales","text":"R Markdown es un formato que permite insertar código R, y sus salidas, en documentos escritos en Markdown. Fue introducido por Yihui Xie en 2012, junto con el paquete knitr, cuyo propósito es facilitar la investigación reproducible en R través de la programación literaria (literate programming), un paradigma de programación propuesto por Donald Knuth en 1984.Los programas “literarios” (o “letrados”) están escritos como una exposición lógica en un lenguaje humano similar la explicación de las fórmulas y ecuaciones empleadas para representar y resolver un problema en un texto de física o de matemáticas. En estos programas, se describe el análisis del problema, su solución y su implementación, intercalando código fuente entre los párrafos (y otros contenidos como imágenes, tablas, gráficos estadísticos y mapas), de forma similar como en los textos de matemáticas se intercalan las fórmulas y las ecuaciones. La programación literaria puede mejorar enormemente un programa, ya que permite documentar ampliamente en qué consiste el problema resolver, cómo se resuelve, cómo y por qué se adoptó cierto diseño, cómo se optimizó y cómo se implementó en un lenguaje de programación.R Markdown se apoya en knitr y en Pandoc, una herramienta para convertir documentos de un formato otro. knitr ejecuta el código R incrustado en Markdown y convierte los documentos en R Markdown Markdown. Por su parte, Pandoc exporta los documentos Markdown al formato de salida deseado (ej. HTML, PDF, Microsoft Word, Microsoft PowerPoint). Este proceso se ilustra en la figura 9.1.\nFigure 9.1: Conversión de un documento R Markdown (.RMD) su formato de salida. Imagen de Xie et al..\n","code":""},{"path":"r-markdown.html","id":"anatomía-de-un-documento-r-markdown","chapter":"9 R Markdown","heading":"9.4 Anatomía de un documento R Markdown","text":"Un documento R Markdown tiene tres tipos de contenido:Metadatos en YAMLNarrativa en MarkdownFragmentos de código en R","code":""},{"path":"r-markdown.html","id":"metadatos-en-yaml","chapter":"9 R Markdown","heading":"9.4.1 Metadatos en YAML","text":"Todo documento R Markdown inicia con un encabezado en la sintaxis YAML (YAML Ain’t Markup Language), el cual contiene metadatos del documento como el título, el autor, la fecha de creación, el formato de salida y la estructura de la tabla de contenidos, entre muchos otros. Los elementos de metadatos que pueden especificarse pueden variar de acuerdo al formato de salida.Un encabezado YAML comienza y termina con tres guiones (---) y contiene un conjunto de campos y valores de la forma:Por ejemplo, un encabezado YAML típico puede ser el siguiente:Los campos del encabezado pueden anidarse con sangrías de dos espacios como, por ejemplo:Las viñetas del paquete ymlthis presentan una lista de los campos YAML disponibles para el encabezado de un documento R Markdown. Los campos también pueden consultarse en la ayuda en línea, por ejemplo con ?rmarkdown::html_document.","code":"---\ncampo01: valor01\ncampo02: valor02\ncampo0n: valor0n\n------\ntitle: Mi primer documento R Markdown\nauthor: Manuel Vargas\noutput: html_document\n------\noutput:\n  html_document:\n    toc: true\n    toc_float: true\n---"},{"path":"r-markdown.html","id":"narrativa-en-markdown","chapter":"9 R Markdown","heading":"9.4.2 Narrativa en Markdown","text":"La narrativa proporciona estructura y contenido al documento en la forma de encabezados, párrafos, enlaces y otros elementos de la sintaxis de Markdown.","code":""},{"path":"r-markdown.html","id":"fragmentos-de-código-en-r","chapter":"9 R Markdown","heading":"9.4.3 Fragmentos de código en R","text":"Cada fragmento (chunk) de código consiste de:La especificación del lenguaje (engine). Usualmente es R, pero hay otras opciones (ej. Python, SQL, C, Bash).Una etiqueta (opcional, pero recomedable).Opciones.Código fuente.Por ejemplo:El fragmento anterior de código R tiene asignada la etiqueta cars y la opción echo=FALSE, la cual indica que debe desplegarse el código fuente de este fragmento en el documento. Sí se desplegará la salida generada por el código plot(cars).Hay más de 50 opciones para fragmentos de código que pueden consultarse en https://yihui.org/knitr/options/.","code":"```{r cars, echo=FALSE}\nplot(cars)\n```"},{"path":"r-markdown.html","id":"ejemplo-de-documento-r-markdown","chapter":"9 R Markdown","heading":"9.5 Ejemplo de documento R Markdown","text":"Un ejemplo de documento R Markdown con gráficos de COVID-19 en Costa Rica, generados con funciones del paquete base de R, está disponible en:Sitio en GitHub Pages: https://gf0604-procesamientodatosgeograficos.github.io/2022--analisis-covid-basico/Código fuente: https://github.com/gf0604-procesamientodatosgeograficos/2022--analisis-covid-basico","code":""},{"path":"r-markdown.html","id":"recursos-de-interés-7","chapter":"9 R Markdown","heading":"9.6 Recursos de interés","text":"Alzahawi, S. (s. f.). Reproducible Reports R Markdown. Recuperado 21 de marzo de 2022, de https://rmarkdown-shilaan.netlify.app/Bartomeus Lab. (2016). reproducible workflow. https://www.youtube.com/watch?v=s3JldKoA0zwBasic YAML. (s. f.). Recuperado 6 de mayo de 2022, de https://cran.r-project.org/web/packages/ymlthis/vignettes/yaml-fieldguide.htmlHiggins, M. (s. f.). Reproducible Templates Analysis Dissemination. Coursera. Recuperado 11 de abril de 2022, de https://www.coursera.org/learn/reproducible-templates-analysisOptions—Yihui Xie | 谢益辉. (s. f.). Recuperado 6 de mayo de 2022, de https://yihui.org/knitr/options/RStudio. (s. f.). rmarkdown::CHEAT SHEET. Recuperado 6 de mayo de 2022, de https://raw.githubusercontent.com/rstudio/cheatsheets/main/rmarkdown.pdfQuarto. (s. f.). Recuperado 6 de mayo de 2022, de https://quarto.org/","code":""},{"path":"tidyverse-colección-de-paquetes-para-ciencia-de-datos.html","id":"tidyverse-colección-de-paquetes-para-ciencia-de-datos","chapter":"10 Tidyverse: colección de paquetes para ciencia de datos","heading":"10 Tidyverse: colección de paquetes para ciencia de datos","text":"","code":""},{"path":"tidyverse-colección-de-paquetes-para-ciencia-de-datos.html","id":"trabajo-previo-5","chapter":"10 Tidyverse: colección de paquetes para ciencia de datos","heading":"10.1 Trabajo previo","text":"","code":""},{"path":"tidyverse-colección-de-paquetes-para-ciencia-de-datos.html","id":"lecturas-3","chapter":"10 Tidyverse: colección de paquetes para ciencia de datos","heading":"10.1.1 Lecturas","text":"Wickham, H., & Grolemund, G. (2017). R Data Science: Import, Tidy, Transform, Visualize, Model Data. O’Reilly Media. https://r4ds..co.nz/","code":""},{"path":"tidyverse-colección-de-paquetes-para-ciencia-de-datos.html","id":"resumen-9","chapter":"10 Tidyverse: colección de paquetes para ciencia de datos","heading":"10.2 Resumen","text":"En este capítulo se estudia Tidyverse, una colección de paquetes para ciencia de datos.","code":""},{"path":"tidyverse-colección-de-paquetes-para-ciencia-de-datos.html","id":"características-generales-2","chapter":"10 Tidyverse: colección de paquetes para ciencia de datos","heading":"10.3 Características generales","text":"Tidyverse es una colección de paquetes de R enfocados en ciencia de datos. La ciencia de datos es una discipina que permite convertir datos procesados en entendimiento, comprensión y conocimiento.4","code":""},{"path":"tidyverse-colección-de-paquetes-para-ciencia-de-datos.html","id":"modelo-de-ciencia-de-datos","chapter":"10 Tidyverse: colección de paquetes para ciencia de datos","heading":"10.3.1 Modelo de ciencia de datos","text":"La figura 10.1 ilustra el modelo de un proyecto típico de ciencia de datos, el cual incluye los procesos de importar, organizar, transformar, visualizar, modelar y comunicar.\nFigure 10.1: Modelo de ciencia de datos. Imagen de Hadley Wickham.\nImportar los datos, típicamente implica leerlos de un archivo, una base de datos o una interfaz de programación de aplicaciones (API) y cargarlos en un data frame. Organizar (tidy) los datos significa colocarlos en estructuras rectangulares, similares tablas, de manera que cada fila sea una observación y cada columna una variable.Una vez que los datos han sido importados y organizados, suele ser necesario realizar en estos algún tipo de transformación. Transformar los datos puede implicar la generación de algún subconjunto de filas y columnas, la creación de nuevas variables o el cálculo de estadísticas (ej. conteos, promedios).Cuando los datos han sido organizados con las variables necesarias, pueden aplicarse dos fuentes de generación de conocimiento: la visualización y el modelado. Al visualizar los datos (en tablas, gráficos, mapas, etc.), pueden encontrarse patrones inesperados o pueden surgir nuevas preguntas. Por su parte, los modelos son herramientas matemáticas o computacionales que facilitan la descripción o predicción de un problema.El último paso es la comunicación, una actividad crítica de cualquier proyecto de análisis de datos o de ciencia en general. Todos estos procesos se articulan mediante programación de computadoras.Los paquetes de Tidyverse “comparten filosofía de diseño, gramática y estructuras de datos”5 para apoyar estos procesos del modelo de ciencia de datos. El concepto de Tidyverse fue introducido por Hadley Wickham, quien también ha programado varios de sus paquetes.","code":""},{"path":"tidyverse-colección-de-paquetes-para-ciencia-de-datos.html","id":"paquetes-1","chapter":"10 Tidyverse: colección de paquetes para ciencia de datos","heading":"10.3.2 Paquetes","text":"El núcleo de Tidyverse está compuesto por ocho paquetes base, los cuales proveen las funcionalidades utilizadas más frecuentemente en análisis de datos:ggplot2: sistema para la creación declarativa de gráficos, basado en el libro Grammar Graphics, de Wilkinson et al..dplyr: gramática para la manipulación de datos que proporciona un conjunto consistente de “verbos” que resulven los retos más comunes de manipulación de datos.tidyr: conjunto de funciones para organizar (tidy) datos, colocando las observaciones, variables y valores en filas, columnas y celdas de estructuras rectangulares.readr: conjunto de funciones para cargar datos de estructuras rectangulares (ej. archivos CSV) en memoria.purr: conjunto de herramientas de programación funcional para trabajar con funciones y vectores.tibble: un tibble es una redefinición del concepto de data frame, para hacerlos más eficientes y fáciles de usar.stringr: colección de funciones para facilitar el trabajo con hileras de caracteres.forcats: colección de funciones para facilitar el trabajo con factores.Hay otros paquetes para tareas más especifícas relacionadas con importación, limpieza y modelado de datos, entre otras. Los paquetes de Tidyverse son de los más descargados, entre la totalidad de paquetes del lenguaje de programación R.","code":""},{"path":"tidyverse-colección-de-paquetes-para-ciencia-de-datos.html","id":"instalación-y-carga","chapter":"10 Tidyverse: colección de paquetes para ciencia de datos","heading":"10.4 Instalación y carga","text":"Los paquetes de Tidyverse pueden instalarse de manera conjunta o individualmente con la función install.packages():Una vez instalados, los paquetes también pueden cargarse conjunta o separadamente con la función library():También es posible utilizar la notación paquete::funcion() para llamar una función sin necesidad de cargar todo el paquete:","code":"\n# Instalación conjunta\ninstall.packages(\"tidyverse\")\n\n# Instalación de paquetes individuales\ninstall.packages(\"ggplot2\")\ninstall.packages(\"dplyr\")\n# Carga conjunta\nlibrary(tidyverse)\n\n# Carga de paquetes individuales\nlibrary(ggplot2)\nlibrary(dplyr)\n# Llamado a la función glimpse() del paquete dplyr\ndplyr::glimpse(iris)\n#> Rows: 150\n#> Columns: 5\n#> $ Sepal.Length <dbl> 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.…\n#> $ Sepal.Width  <dbl> 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.…\n#> $ Petal.Length <dbl> 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.…\n#> $ Petal.Width  <dbl> 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.…\n#> $ Species      <fct> setosa, setosa, setosa, setosa, setos…"},{"path":"tidyverse-colección-de-paquetes-para-ciencia-de-datos.html","id":"el-conjunto-de-datos-palmerpenguins","chapter":"10 Tidyverse: colección de paquetes para ciencia de datos","heading":"10.5 El conjunto de datos palmerpenguins","text":"palmerpenguins es un paquete de datos de R ampliamente utilizado para ejemplificar funciones de exploración y visualización. Es muy popular en ciencia de datos en general y también está disponible para otros lenguajes de programación (ej. Python, Julia). Se utiliza como una alternativa otros conjuntos de datos como, por ejemplo, iris.Los datos de palmerpenguins fueron recolectados entre 2007 y 2009 por la Dr. Kristen Gorman y el Programa de Investigación Ecológica de Largo Plazo (LTER) de la Estación Palmer. Consisten de 344 observaciones de pingüinos de tres especies, las cuales habitan en tres islas del archipiélago Palmer, en la Antártida. Para cada individuo se registraron variables como especie, sexo, masa (peso), longitud de la aleta (flipper), longitud del pico (bill) y profundidad del pico, entre otras.En R, el paquete puede instalarse con la función install.packages():Una vez instalado, el paquete puede cargarse con la función library():El paquete contiene dos conjuntos de datos:penguins_raw: datos sin procesar.penguins: subconjunto curado de los datos sin procesar.palmerpinguins se utilizará en este capítulo, y en los siguientes, para ejemplificar varias de las funcionalidades de Tidyverse.","code":"\n# Instalación de palmerpenguins\ninstall.packages(\"palmerpenguins\")\nlibrary(palmerpenguins)"},{"path":"tidyverse-colección-de-paquetes-para-ciencia-de-datos.html","id":"ejemplos-de-visualizaciones","chapter":"10 Tidyverse: colección de paquetes para ciencia de datos","heading":"10.5.1 Ejemplos de visualizaciones","text":"Se muestran varios tipos de gráficos estadísticos generados con la función ‘ggplot()’.","code":""},{"path":"tidyverse-colección-de-paquetes-para-ciencia-de-datos.html","id":"gráficos-de-dispersión","chapter":"10 Tidyverse: colección de paquetes para ciencia de datos","heading":"10.5.1.1 Gráficos de dispersión","text":"Este tipo de gráficos muestra relaciones entre variables.","code":"\n# Gráfico de dispersión de longitud del pico vs masa (peso)\nggplot(data = penguins, aes(x = bill_length_mm, y = body_mass_g)) +\n  geom_point(size = 2) +\n  geom_smooth(method = \"lm\", se = FALSE) +\n  ggtitle(\"Longitud del pico vs. masa\") +\n  xlab(\"Longitud del pico (mm)\") +\n  ylab(\"Masa (g)\") +\n  labs(color = \"Especie\", shape = \"Especie\")\n#> `geom_smooth()` using formula 'y ~ x'\n# Gráfico de dispersión de longitud del pico vs masa (peso) por especie\nggplot(data = penguins, aes(x = bill_length_mm, y = body_mass_g)) +\n  geom_point(aes(color = species,\n                 shape = species),\n             size = 2) +\n  geom_smooth(method = \"lm\", se = FALSE, aes(color = species)) +\n  scale_color_manual(values = c(\"darkorange\", \"darkorchid\", \"cyan4\")) +\n  ggtitle(\"Longitud del pico vs. masa por especie\") +\n  xlab(\"Longitud del pico (mm)\") +\n  ylab(\"Masa (g)\") +\n  labs(color = \"Especie\", shape = \"Especie\")\n#> `geom_smooth()` using formula 'y ~ x'"},{"path":"tidyverse-colección-de-paquetes-para-ciencia-de-datos.html","id":"histogramas","chapter":"10 Tidyverse: colección de paquetes para ciencia de datos","heading":"10.5.1.2 Histogramas","text":"Este tipo de gráficos muestra distribuciones de variables.","code":"\n# Distribución de la variable de masa (peso)\nggplot(data = penguins, aes(x = body_mass_g)) +\n  geom_histogram() +\n  ggtitle(\"Distribución de la variable masa (peso)\") +\n  xlab(\"Masa (g)\") +\n  ylab(\"n\")\n# Distribución de la variable de masa (peso) por especie\nggplot(data = penguins, aes(x = body_mass_g)) +\n  geom_histogram(aes(fill = species), alpha = 0.5, position = \"identity\") +\n  scale_fill_manual(values = c(\"darkorange\",\"darkorchid\",\"cyan4\")) +\n  ggtitle(\"Distribución de la variable masa (peso) por especie\") +\n  xlab(\"Masa (g)\") +\n  ylab(\"n\") +\n  labs(fill = \"Especie\")"},{"path":"tidyverse-colección-de-paquetes-para-ciencia-de-datos.html","id":"diagramas-de-caja","chapter":"10 Tidyverse: colección de paquetes para ciencia de datos","heading":"10.5.1.3 Diagramas de caja","text":"Este tipo de gráficos muestra datos través de sus cuartiles.","code":"\n# Diagrama de caja de la variable masa (peso)\nggplot(data = penguins, aes(y = body_mass_g)) +\n  geom_boxplot() +\n  ylab(\"Masa (g)\")\n# Diagrama de caja de la variable masa (peso) por especie\nggplot(data = penguins, aes(x = species, y = body_mass_g)) +\n  geom_boxplot(aes(color = species), width = 0.3, show.legend = FALSE) +\n  scale_color_manual(values = c(\"darkorange\",\"purple\",\"cyan4\")) +\n  xlab(\"Especie\") +\n  ylab(\"Masa (g)\")"},{"path":"tidyverse-colección-de-paquetes-para-ciencia-de-datos.html","id":"datos-tidy","chapter":"10 Tidyverse: colección de paquetes para ciencia de datos","heading":"10.6 Datos tidy","text":"Los paquetes de Tidyverse trabajan con datos tidy (.e. ordenados, organizados), un concepto también introducido por Hadley Wickham y que está relacionado con la organización de los datos en estructuras rectangulares de filas y columnas, similares las tablas o matrices.Según Wickham, los datos tidy deben cumplir con tres características:Cada variable debe tener su propia columna.Cada observación debe tener su propia fila.Cada valor debe tener su propia celda.Estas características se ilustran en la figura 10.2.\nFigure 10.2: Datos tidy. Imagen de Hadley Wickham.\nEl empleo de este modelo de datos es común en todos los paquetes de Tidyverse, lo que posibilita aprender y usar sus funciones con mayor facilidad. Además, permite invertir menos esfuerzo en lidiar con diferentes modelos de datos y así dedicar más tiempo y esfuerzo en los problemas de análisis resolver.","code":""},{"path":"tidyverse-colección-de-paquetes-para-ciencia-de-datos.html","id":"tibbles","chapter":"10 Tidyverse: colección de paquetes para ciencia de datos","heading":"10.6.0.1 Tibbles","text":"Los datos tidy pueden almacenarse en los tradicionales data frames (tipo data.frame) de R. Adicionalmente, Tidyverse implementa el tipo de datos tibble o tbl. Un tbl también es un data.frame, pero más “liviano” y fácil de usar.Una de las diferencias entre un data.frame y un tibble es el despliegue de los datos:Como puede verse, la función print() despliega solamente las 10 primeras filas del tibble y una cantidad limitada de columnas, mostrando así una salida más legible. Este comportamiento puede modificarse con los argumentos de print().","code":"\n# Clase del conjunto de datos penguins\nclass(penguins)\n#> [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n# Impresión del tibble penguins\nprint(penguins)\n#> # A tibble: 344 × 8\n#>    species island    bill_length_mm bill_depth_mm\n#>    <fct>   <fct>              <dbl>         <dbl>\n#>  1 Adelie  Torgersen           39.1          18.7\n#>  2 Adelie  Torgersen           39.5          17.4\n#>  3 Adelie  Torgersen           40.3          18  \n#>  4 Adelie  Torgersen           NA            NA  \n#>  5 Adelie  Torgersen           36.7          19.3\n#>  6 Adelie  Torgersen           39.3          20.6\n#>  7 Adelie  Torgersen           38.9          17.8\n#>  8 Adelie  Torgersen           39.2          19.6\n#>  9 Adelie  Torgersen           34.1          18.1\n#> 10 Adelie  Torgersen           42            20.2\n#> # … with 334 more rows, and 4 more variables:\n#> #   flipper_length_mm <int>, body_mass_g <int>, sex <fct>,\n#> #   year <int>\n# Impresión del tibble penguins con 15 filas y todas las columnas\nprint(penguins, n=15, width = Inf)\n#> # A tibble: 344 × 8\n#>    species island    bill_length_mm bill_depth_mm\n#>    <fct>   <fct>              <dbl>         <dbl>\n#>  1 Adelie  Torgersen           39.1          18.7\n#>  2 Adelie  Torgersen           39.5          17.4\n#>  3 Adelie  Torgersen           40.3          18  \n#>  4 Adelie  Torgersen           NA            NA  \n#>  5 Adelie  Torgersen           36.7          19.3\n#>  6 Adelie  Torgersen           39.3          20.6\n#>  7 Adelie  Torgersen           38.9          17.8\n#>  8 Adelie  Torgersen           39.2          19.6\n#>  9 Adelie  Torgersen           34.1          18.1\n#> 10 Adelie  Torgersen           42            20.2\n#> 11 Adelie  Torgersen           37.8          17.1\n#> 12 Adelie  Torgersen           37.8          17.3\n#> 13 Adelie  Torgersen           41.1          17.6\n#> 14 Adelie  Torgersen           38.6          21.2\n#> 15 Adelie  Torgersen           34.6          21.1\n#>    flipper_length_mm body_mass_g sex     year\n#>                <int>       <int> <fct>  <int>\n#>  1               181        3750 male    2007\n#>  2               186        3800 female  2007\n#>  3               195        3250 female  2007\n#>  4                NA          NA <NA>    2007\n#>  5               193        3450 female  2007\n#>  6               190        3650 male    2007\n#>  7               181        3625 female  2007\n#>  8               195        4675 male    2007\n#>  9               193        3475 <NA>    2007\n#> 10               190        4250 <NA>    2007\n#> 11               186        3300 <NA>    2007\n#> 12               180        3700 <NA>    2007\n#> 13               182        3200 female  2007\n#> 14               191        3800 male    2007\n#> 15               198        4400 male    2007\n#> # … with 329 more rows"},{"path":"tidyverse-colección-de-paquetes-para-ciencia-de-datos.html","id":"pipes","chapter":"10 Tidyverse: colección de paquetes para ciencia de datos","heading":"10.7 Pipes","text":"Las funciones de Tidyverse pueden encadenarse través del operador pipe (%>%) (tubo), para formar pipelines (tuberías). En este contexto, un pipeline consiste de una cadena de procesos conectados de forma tal que la salida de cada proceso de la cadena es la entrada del próximo. Esto permite la comunicación y sincronización entre los procesos y evita la anidación (nesting) de llamados funciones.El siguiente ejemplo implementa un pipeline de funciones de Tidyverse:Una alternativa los pipes es la anidación de llamados funciones:El uso de pipes permite un funcionamiento homogéneo de las funciones de Tidyverse:El primer argumento es un data frame. Puede omitirse si la función recibe el data frame través del operador pipe.Los argumentos siguientes describen que hacer con el data frame, utilizando los nombres de las columnas (sin comillas).El resultado es un nuevo data frame.","code":"\n# Cadena de \"pipes\" entre funciones de Tidyverse\npenguins %>%\n  dplyr::filter(species == \"Gentoo\") %>% # subconjunto de observaciones\n  select(species, bill_length_mm, flipper_length_mm) # subconjunto de columnas\n#> # A tibble: 124 × 3\n#>    species bill_length_mm flipper_length_mm\n#>    <fct>            <dbl>             <int>\n#>  1 Gentoo            46.1               211\n#>  2 Gentoo            50                 230\n#>  3 Gentoo            48.7               210\n#>  4 Gentoo            50                 218\n#>  5 Gentoo            47.6               215\n#>  6 Gentoo            46.5               210\n#>  7 Gentoo            45.4               211\n#>  8 Gentoo            46.7               219\n#>  9 Gentoo            43.3               209\n#> 10 Gentoo            46.8               215\n#> # … with 114 more rows\n# Llamados anidados a funciones\nselect(filter(penguins, species == \"Gentoo\"),\n       bill_length_mm,\n       flipper_length_mm)\n#> # A tibble: 124 × 2\n#>    bill_length_mm flipper_length_mm\n#>             <dbl>             <int>\n#>  1           46.1               211\n#>  2           50                 230\n#>  3           48.7               210\n#>  4           50                 218\n#>  5           47.6               215\n#>  6           46.5               210\n#>  7           45.4               211\n#>  8           46.7               219\n#>  9           43.3               209\n#> 10           46.8               215\n#> # … with 114 more rows"},{"path":"tidyverse-colección-de-paquetes-para-ciencia-de-datos.html","id":"recursos-de-interés-8","chapter":"10 Tidyverse: colección de paquetes para ciencia de datos","heading":"10.8 Recursos de interés","text":"Canelón, S. (2020). Antarctic Tour Tidyverse. https://spcanelon.github.io/tour---tidyverse/R- Ladies Global. (2020). R-Ladies Chicago (English)—Antarctic Tour Tidyverse—Silvia Canelón. https://www.youtube.com/watch?v=m_ZoMmAIx-oWickham, H. (2014). Tidy Data. Journal Statistical Software, 59(1), 1-23. https://doi.org/10.18637/jss.v059.i10Wickham, H., & Grolemund, G. (s. f.). R para Ciencia de Datos. Recuperado 14 de mayo de 2022, de https://es.r4ds.hadley.nz/","code":""},{"path":"dplyr-gramática-para-manipulación-de-datos.html","id":"dplyr-gramática-para-manipulación-de-datos","chapter":"11 dplyr: gramática para manipulación de datos","heading":"11 dplyr: gramática para manipulación de datos","text":"","code":""},{"path":"dplyr-gramática-para-manipulación-de-datos.html","id":"trabajo-previo-6","chapter":"11 dplyr: gramática para manipulación de datos","heading":"11.1 Trabajo previo","text":"","code":""},{"path":"dplyr-gramática-para-manipulación-de-datos.html","id":"lecturas-4","chapter":"11 dplyr: gramática para manipulación de datos","heading":"11.1.1 Lecturas","text":"Wickham, H., & Grolemund, G. (2017). R Data Science: Import, Tidy, Transform, Visualize, Model Data. O’Reilly Media. https://r4ds..co.nz/","code":""},{"path":"dplyr-gramática-para-manipulación-de-datos.html","id":"resumen-10","chapter":"11 dplyr: gramática para manipulación de datos","heading":"11.2 Resumen","text":"En este capítulo se estudia el paquete dplyr de Tidyverse.","code":""},{"path":"dplyr-gramática-para-manipulación-de-datos.html","id":"características-generales-3","chapter":"11 dplyr: gramática para manipulación de datos","heading":"11.3 Características generales","text":"El paquete dplyr de Tidyverse es descrito como una “gramática para la manipulación de datos, la cual proporciona un conjunto consistente de verbos que ayuda solucionar los retos de manipulación de datos más comunes”. Los principales “verbos” (.e. funciones) de esta gramática son:select(): selecciona columnas con base en sus nombres.select(): selecciona columnas con base en sus nombres.filter(): selecciona filas con base en sus valores.filter(): selecciona filas con base en sus valores.arrange(): cambia el orden de las filas.arrange(): cambia el orden de las filas.mutate(): crea nuevas columnas, las cuales se expresan como funciones de columnas existentes.mutate(): crea nuevas columnas, las cuales se expresan como funciones de columnas existentes.summarise(): agrupa y resume valores.summarise(): agrupa y resume valores.Todas estas operaciones pueden combinarse con la función group_by(), la cual ejecuta cualquiera de las operaciones anteriores “en grupo”. Además, dplyr proporciona funciones adicionales para tareas más específicas.Todas las funciones de dplyr trabajan de manera similar:El primer argumento es un data frame. Puede omitirse si la función recibe el data frame través del operador pipe.Los argumentos siguientes describen que hacer con el data frame, utilizando los nombres de las columnas (sin comillas).El resultado es un nuevo data frame.Las funciones de dplyr pueden encadenarse través del operador pipe (%>%) (tubo), para formar pipelines (tuberías).","code":""},{"path":"dplyr-gramática-para-manipulación-de-datos.html","id":"instalación-y-carga-1","chapter":"11 dplyr: gramática para manipulación de datos","heading":"11.4 Instalación y carga","text":"El paquete dplyr pueden instalarse junto con todos los demás paquete de Tidyverse o de manera individual:Una vez instalado, dplyr puede cargarse con la función library():","code":"\n# Instalación conjunta de Tidyverse\ninstall.packages(\"tidyverse\")\n\n# Instalación individual\ninstall.packages(\"dplyr\")\n# Carga conjunta de Tidyverse\nlibrary(tidyverse)\n\n# Carga individual\nlibrary(dplyr)"},{"path":"dplyr-gramática-para-manipulación-de-datos.html","id":"conjuntos-de-datos-de-ejemplo","chapter":"11 dplyr: gramática para manipulación de datos","heading":"11.5 Conjuntos de datos de ejemplo","text":"Para los ejemplos de este capítulo, se utiliza el paquete de datos palmerpenguins.Estructura del conjunto de datos penguins:Vista del conjunto de datos penguins:","code":"\n# Carga del paquete de datos palmerpenguins\nlibrary(palmerpenguins)\n# Carga del paquete de datos palmerpenguins\nglimpse(penguins)\n#> Rows: 344\n#> Columns: 8\n#> $ species           <fct> Adelie, Adelie, Adelie, Adelie, …\n#> $ island            <fct> Torgersen, Torgersen, Torgersen,…\n#> $ bill_length_mm    <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3…\n#> $ bill_depth_mm     <dbl> 18.7, 17.4, 18.0, NA, 19.3, 20.6…\n#> $ flipper_length_mm <int> 181, 186, 195, NA, 193, 190, 181…\n#> $ body_mass_g       <int> 3750, 3800, 3250, NA, 3450, 3650…\n#> $ sex               <fct> male, female, female, NA, female…\n#> $ year              <int> 2007, 2007, 2007, 2007, 2007, 20…\n# Vista del paquete de datos palmerpenguins\nView(penguins)"},{"path":"dplyr-gramática-para-manipulación-de-datos.html","id":"funciones-1","chapter":"11 dplyr: gramática para manipulación de datos","heading":"11.6 Funciones","text":"","code":""},{"path":"dplyr-gramática-para-manipulación-de-datos.html","id":"select","chapter":"11 dplyr: gramática para manipulación de datos","heading":"11.6.1 select()","text":"La función select() selecciona (y opcionalmente renombra) columnas de un data frame con base en sus nombres.Cambio de nombres de columnas:El operador : permite seleccionar un rango de columnas continuas:Selección de todas las columnas que cumplen una condición:","code":"\n# Selección de las columnas de especie, longitud del pico y sexo\npenguins %>%\n  select(species, bill_length_mm, sex)\n#> # A tibble: 344 × 3\n#>    species bill_length_mm sex   \n#>    <fct>            <dbl> <fct> \n#>  1 Adelie            39.1 male  \n#>  2 Adelie            39.5 female\n#>  3 Adelie            40.3 female\n#>  4 Adelie            NA   <NA>  \n#>  5 Adelie            36.7 female\n#>  6 Adelie            39.3 male  \n#>  7 Adelie            38.9 female\n#>  8 Adelie            39.2 male  \n#>  9 Adelie            34.1 <NA>  \n#> 10 Adelie            42   <NA>  \n#> # … with 334 more rows\n# Selección y cambio de nombre de las columnas de especie, longitud del pico y sexo\npenguins %>%\n  select(especie = species,\n         longitud_pico_mm = bill_length_mm,\n         sexo = sex)\n#> # A tibble: 344 × 3\n#>    especie longitud_pico_mm sexo  \n#>    <fct>              <dbl> <fct> \n#>  1 Adelie              39.1 male  \n#>  2 Adelie              39.5 female\n#>  3 Adelie              40.3 female\n#>  4 Adelie              NA   <NA>  \n#>  5 Adelie              36.7 female\n#>  6 Adelie              39.3 male  \n#>  7 Adelie              38.9 female\n#>  8 Adelie              39.2 male  \n#>  9 Adelie              34.1 <NA>  \n#> 10 Adelie              42   <NA>  \n#> # … with 334 more rows\n# Selección de las columnas en el rango de species a flipper_length_mm\npenguins %>%\n  select(species:flipper_length_mm)\n#> # A tibble: 344 × 5\n#>    species island    bill_length_mm bill_depth_mm\n#>    <fct>   <fct>              <dbl>         <dbl>\n#>  1 Adelie  Torgersen           39.1          18.7\n#>  2 Adelie  Torgersen           39.5          17.4\n#>  3 Adelie  Torgersen           40.3          18  \n#>  4 Adelie  Torgersen           NA            NA  \n#>  5 Adelie  Torgersen           36.7          19.3\n#>  6 Adelie  Torgersen           39.3          20.6\n#>  7 Adelie  Torgersen           38.9          17.8\n#>  8 Adelie  Torgersen           39.2          19.6\n#>  9 Adelie  Torgersen           34.1          18.1\n#> 10 Adelie  Torgersen           42            20.2\n#> # … with 334 more rows, and 1 more variable:\n#> #   flipper_length_mm <int>\n# Selección de las columnas numéricas\npenguins %>%\n  select(where(is.numeric))\n#> # A tibble: 344 × 5\n#>    bill_length_mm bill_depth_mm flipper_length_… body_mass_g\n#>             <dbl>         <dbl>            <int>       <int>\n#>  1           39.1          18.7              181        3750\n#>  2           39.5          17.4              186        3800\n#>  3           40.3          18                195        3250\n#>  4           NA            NA                 NA          NA\n#>  5           36.7          19.3              193        3450\n#>  6           39.3          20.6              190        3650\n#>  7           38.9          17.8              181        3625\n#>  8           39.2          19.6              195        4675\n#>  9           34.1          18.1              193        3475\n#> 10           42            20.2              190        4250\n#> # … with 334 more rows, and 1 more variable: year <int>"},{"path":"dplyr-gramática-para-manipulación-de-datos.html","id":"filter","chapter":"11 dplyr: gramática para manipulación de datos","heading":"11.6.2 filter()","text":"La función filter() retorna un subconjunto de un data frame con todas las filas que satisfacen una condición (.e. expresión lógica).Ejemplos de uso de expresiones y operadores lógicos:Condiciones relacionadas con valores NA:La función drop_na() remueve las filas con valores NA en una o varias columnas.","code":"\n# Filas de la especie 'Adelie' con longitud del pico mayor o igual a 45 mm\npenguins %>%\n  filter(species == 'Adelie' & bill_length_mm >= 45)\n#> # A tibble: 3 × 8\n#>   species island    bill_length_mm bill_depth_mm\n#>   <fct>   <fct>              <dbl>         <dbl>\n#> 1 Adelie  Torgersen           46            21.5\n#> 2 Adelie  Torgersen           45.8          18.9\n#> 3 Adelie  Biscoe              45.6          20.3\n#> # … with 4 more variables: flipper_length_mm <int>,\n#> #   body_mass_g <int>, sex <fct>, year <int>\n# Filas de las especie 'Adelie' o 'Gentoo'\npenguins %>%\n  filter(species == 'Adelie' | species == 'Gentoo')\n#> # A tibble: 276 × 8\n#>    species island    bill_length_mm bill_depth_mm\n#>    <fct>   <fct>              <dbl>         <dbl>\n#>  1 Adelie  Torgersen           39.1          18.7\n#>  2 Adelie  Torgersen           39.5          17.4\n#>  3 Adelie  Torgersen           40.3          18  \n#>  4 Adelie  Torgersen           NA            NA  \n#>  5 Adelie  Torgersen           36.7          19.3\n#>  6 Adelie  Torgersen           39.3          20.6\n#>  7 Adelie  Torgersen           38.9          17.8\n#>  8 Adelie  Torgersen           39.2          19.6\n#>  9 Adelie  Torgersen           34.1          18.1\n#> 10 Adelie  Torgersen           42            20.2\n#> # … with 266 more rows, and 4 more variables:\n#> #   flipper_length_mm <int>, body_mass_g <int>, sex <fct>,\n#> #   year <int>\n# Filas de especies diferentes a 'Chinstrap'\npenguins %>%\n  filter(!(species == 'Chinstrap'))\n#> # A tibble: 276 × 8\n#>    species island    bill_length_mm bill_depth_mm\n#>    <fct>   <fct>              <dbl>         <dbl>\n#>  1 Adelie  Torgersen           39.1          18.7\n#>  2 Adelie  Torgersen           39.5          17.4\n#>  3 Adelie  Torgersen           40.3          18  \n#>  4 Adelie  Torgersen           NA            NA  \n#>  5 Adelie  Torgersen           36.7          19.3\n#>  6 Adelie  Torgersen           39.3          20.6\n#>  7 Adelie  Torgersen           38.9          17.8\n#>  8 Adelie  Torgersen           39.2          19.6\n#>  9 Adelie  Torgersen           34.1          18.1\n#> 10 Adelie  Torgersen           42            20.2\n#> # … with 266 more rows, and 4 more variables:\n#> #   flipper_length_mm <int>, body_mass_g <int>, sex <fct>,\n#> #   year <int>\n# Filas con longitud del pico mayor o igual al promedio\npenguins %>%\n  filter(bill_length_mm >= mean(bill_length_mm, na.rm = TRUE))\n#> # A tibble: 175 × 8\n#>    species island    bill_length_mm bill_depth_mm\n#>    <fct>   <fct>              <dbl>         <dbl>\n#>  1 Adelie  Torgersen           46            21.5\n#>  2 Adelie  Dream               44.1          19.7\n#>  3 Adelie  Torgersen           45.8          18.9\n#>  4 Adelie  Biscoe              45.6          20.3\n#>  5 Adelie  Torgersen           44.1          18  \n#>  6 Gentoo  Biscoe              46.1          13.2\n#>  7 Gentoo  Biscoe              50            16.3\n#>  8 Gentoo  Biscoe              48.7          14.1\n#>  9 Gentoo  Biscoe              50            15.2\n#> 10 Gentoo  Biscoe              47.6          14.5\n#> # … with 165 more rows, and 4 more variables:\n#> #   flipper_length_mm <int>, body_mass_g <int>, sex <fct>,\n#> #   year <int>\n# Filas con longitud del pico mayor o igual al promedio\n#   El argumento lógico na.rm de mean() indica si los valores NA (\"not available\") \n#   deben ser removidos antes del cálculo\npenguins %>%\n  filter(bill_length_mm >= mean(bill_length_mm, na.rm = TRUE))\n#> # A tibble: 175 × 8\n#>    species island    bill_length_mm bill_depth_mm\n#>    <fct>   <fct>              <dbl>         <dbl>\n#>  1 Adelie  Torgersen           46            21.5\n#>  2 Adelie  Dream               44.1          19.7\n#>  3 Adelie  Torgersen           45.8          18.9\n#>  4 Adelie  Biscoe              45.6          20.3\n#>  5 Adelie  Torgersen           44.1          18  \n#>  6 Gentoo  Biscoe              46.1          13.2\n#>  7 Gentoo  Biscoe              50            16.3\n#>  8 Gentoo  Biscoe              48.7          14.1\n#>  9 Gentoo  Biscoe              50            15.2\n#> 10 Gentoo  Biscoe              47.6          14.5\n#> # … with 165 more rows, and 4 more variables:\n#> #   flipper_length_mm <int>, body_mass_g <int>, sex <fct>,\n#> #   year <int>\n# Filas con valor NA en la columna sex\npenguins %>%\n  select(species, island, sex) %>%\n  filter(is.na(sex))\n#> # A tibble: 11 × 3\n#>    species island    sex  \n#>    <fct>   <fct>     <fct>\n#>  1 Adelie  Torgersen <NA> \n#>  2 Adelie  Torgersen <NA> \n#>  3 Adelie  Torgersen <NA> \n#>  4 Adelie  Torgersen <NA> \n#>  5 Adelie  Torgersen <NA> \n#>  6 Adelie  Dream     <NA> \n#>  7 Gentoo  Biscoe    <NA> \n#>  8 Gentoo  Biscoe    <NA> \n#>  9 Gentoo  Biscoe    <NA> \n#> 10 Gentoo  Biscoe    <NA> \n#> 11 Gentoo  Biscoe    <NA>\n# Filas con valor diferente a NA en la columna sex\npenguins %>%\n  select(species,\n         bill_length_mm,\n         bill_depth_mm,\n         flipper_length_mm,\n         body_mass_g,\n         sex) %>%\n  drop_na(sex)\n#> # A tibble: 333 × 6\n#>    species bill_length_mm bill_depth_mm flipper_length_mm\n#>    <fct>            <dbl>         <dbl>             <int>\n#>  1 Adelie            39.1          18.7               181\n#>  2 Adelie            39.5          17.4               186\n#>  3 Adelie            40.3          18                 195\n#>  4 Adelie            36.7          19.3               193\n#>  5 Adelie            39.3          20.6               190\n#>  6 Adelie            38.9          17.8               181\n#>  7 Adelie            39.2          19.6               195\n#>  8 Adelie            41.1          17.6               182\n#>  9 Adelie            38.6          21.2               191\n#> 10 Adelie            34.6          21.1               198\n#> # … with 323 more rows, and 2 more variables:\n#> #   body_mass_g <int>, sex <fct>\n# Filas con valor diferente a NA en cualquier columna\npenguins %>%\n  select(species,\n         bill_length_mm,\n         bill_depth_mm,\n         flipper_length_mm,\n         body_mass_g,\n         sex) %>%\n  drop_na()\n#> # A tibble: 333 × 6\n#>    species bill_length_mm bill_depth_mm flipper_length_mm\n#>    <fct>            <dbl>         <dbl>             <int>\n#>  1 Adelie            39.1          18.7               181\n#>  2 Adelie            39.5          17.4               186\n#>  3 Adelie            40.3          18                 195\n#>  4 Adelie            36.7          19.3               193\n#>  5 Adelie            39.3          20.6               190\n#>  6 Adelie            38.9          17.8               181\n#>  7 Adelie            39.2          19.6               195\n#>  8 Adelie            41.1          17.6               182\n#>  9 Adelie            38.6          21.2               191\n#> 10 Adelie            34.6          21.1               198\n#> # … with 323 more rows, and 2 more variables:\n#> #   body_mass_g <int>, sex <fct>"},{"path":"dplyr-gramática-para-manipulación-de-datos.html","id":"arrange","chapter":"11 dplyr: gramática para manipulación de datos","heading":"11.6.3 arrange()","text":"La función arrange() cambia el orden de las filas de un data frame de acuerdo con los valores de las columnas seleccionadas.Por defecto, las columnas se ordenan de manera acendente. Si se desea un orden descendente, puede utilizarse la función desc().Nótese que los valores NA se ubican al final de cualquier ordenamiento.La función across() aplica una función en múltiples columnas.","code":"\n# Ordenamiento ascendente por las columnas 'bill_lenght_mm' y 'bill_depth_mm'\npenguins %>%\n  arrange(bill_length_mm, bill_depth_mm)\n#> # A tibble: 344 × 8\n#>    species island    bill_length_mm bill_depth_mm\n#>    <fct>   <fct>              <dbl>         <dbl>\n#>  1 Adelie  Dream               32.1          15.5\n#>  2 Adelie  Dream               33.1          16.1\n#>  3 Adelie  Torgersen           33.5          19  \n#>  4 Adelie  Dream               34            17.1\n#>  5 Adelie  Torgersen           34.1          18.1\n#>  6 Adelie  Torgersen           34.4          18.4\n#>  7 Adelie  Biscoe              34.5          18.1\n#>  8 Adelie  Torgersen           34.6          17.2\n#>  9 Adelie  Torgersen           34.6          21.1\n#> 10 Adelie  Biscoe              35            17.9\n#> # … with 334 more rows, and 4 more variables:\n#> #   flipper_length_mm <int>, body_mass_g <int>, sex <fct>,\n#> #   year <int>\n# Ordenamiento descendente por las columnas 'bill_lenght_mm' y 'bill_depth_mm'\npenguins %>%\n  arrange(desc(bill_length_mm), desc(bill_depth_mm))\n#> # A tibble: 344 × 8\n#>    species   island bill_length_mm bill_depth_mm\n#>    <fct>     <fct>           <dbl>         <dbl>\n#>  1 Gentoo    Biscoe           59.6          17  \n#>  2 Chinstrap Dream            58            17.8\n#>  3 Gentoo    Biscoe           55.9          17  \n#>  4 Chinstrap Dream            55.8          19.8\n#>  5 Gentoo    Biscoe           55.1          16  \n#>  6 Gentoo    Biscoe           54.3          15.7\n#>  7 Chinstrap Dream            54.2          20.8\n#>  8 Chinstrap Dream            53.5          19.9\n#>  9 Gentoo    Biscoe           53.4          15.8\n#> 10 Chinstrap Dream            52.8          20  \n#> # … with 334 more rows, and 4 more variables:\n#> #   flipper_length_mm <int>, body_mass_g <int>, sex <fct>,\n#> #   year <int>\n# Ordenamiento ascendente por las columnas que empiezan con 'bill'\npenguins %>%\n  arrange(across(starts_with('bill')))\n#> # A tibble: 344 × 8\n#>    species island    bill_length_mm bill_depth_mm\n#>    <fct>   <fct>              <dbl>         <dbl>\n#>  1 Adelie  Dream               32.1          15.5\n#>  2 Adelie  Dream               33.1          16.1\n#>  3 Adelie  Torgersen           33.5          19  \n#>  4 Adelie  Dream               34            17.1\n#>  5 Adelie  Torgersen           34.1          18.1\n#>  6 Adelie  Torgersen           34.4          18.4\n#>  7 Adelie  Biscoe              34.5          18.1\n#>  8 Adelie  Torgersen           34.6          17.2\n#>  9 Adelie  Torgersen           34.6          21.1\n#> 10 Adelie  Biscoe              35            17.9\n#> # … with 334 more rows, and 4 more variables:\n#> #   flipper_length_mm <int>, body_mass_g <int>, sex <fct>,\n#> #   year <int>\n# Ordenamiento ascendente por las columnas que contienen la hilera 'lenght'\npenguins %>%\n  arrange(across(contains('length')))\n#> # A tibble: 344 × 8\n#>    species island    bill_length_mm bill_depth_mm\n#>    <fct>   <fct>              <dbl>         <dbl>\n#>  1 Adelie  Dream               32.1          15.5\n#>  2 Adelie  Dream               33.1          16.1\n#>  3 Adelie  Torgersen           33.5          19  \n#>  4 Adelie  Dream               34            17.1\n#>  5 Adelie  Torgersen           34.1          18.1\n#>  6 Adelie  Torgersen           34.4          18.4\n#>  7 Adelie  Biscoe              34.5          18.1\n#>  8 Adelie  Torgersen           34.6          17.2\n#>  9 Adelie  Torgersen           34.6          21.1\n#> 10 Adelie  Biscoe              35            17.9\n#> # … with 334 more rows, and 4 more variables:\n#> #   flipper_length_mm <int>, body_mass_g <int>, sex <fct>,\n#> #   year <int>"},{"path":"dplyr-gramática-para-manipulación-de-datos.html","id":"mutate","chapter":"11 dplyr: gramática para manipulación de datos","heading":"11.6.4 mutate()","text":"La función mutate() crea o modifica columnas en un data frame.La función group_by() agrupa una o más columnas.","code":"\n# Creación de la columna 'body_mass_kg' con el valor de 'body_mass_g' expresado en kg\npenguins %>%\n  select(species, body_mass_g) %>%\n  mutate(body_mass_kg = body_mass_g/1000)\n#> # A tibble: 344 × 3\n#>    species body_mass_g body_mass_kg\n#>    <fct>         <int>        <dbl>\n#>  1 Adelie         3750         3.75\n#>  2 Adelie         3800         3.8 \n#>  3 Adelie         3250         3.25\n#>  4 Adelie           NA        NA   \n#>  5 Adelie         3450         3.45\n#>  6 Adelie         3650         3.65\n#>  7 Adelie         3625         3.62\n#>  8 Adelie         4675         4.68\n#>  9 Adelie         3475         3.48\n#> 10 Adelie         4250         4.25\n#> # … with 334 more rows\n# Creación de la columnas 'body_mass_g_mean' (promedio de masa) \n# y 'body_mass_g_normalized' (proporción con respecto al promedio)\npenguins %>%\n  select(species, body_mass_g) %>%\n  mutate(body_mass_g_mean = mean(body_mass_g, na.rm = TRUE)) %>%\n  mutate(body_mass_g_normalized = body_mass_g / body_mass_g_mean)\n#> # A tibble: 344 × 4\n#>    species body_mass_g body_mass_g_mean body_mass_g_normali…\n#>    <fct>         <int>            <dbl>                <dbl>\n#>  1 Adelie         3750            4202.                0.892\n#>  2 Adelie         3800            4202.                0.904\n#>  3 Adelie         3250            4202.                0.773\n#>  4 Adelie           NA            4202.               NA    \n#>  5 Adelie         3450            4202.                0.821\n#>  6 Adelie         3650            4202.                0.869\n#>  7 Adelie         3625            4202.                0.863\n#>  8 Adelie         4675            4202.                1.11 \n#>  9 Adelie         3475            4202.                0.827\n#> 10 Adelie         4250            4202.                1.01 \n#> # … with 334 more rows\n# Creación de la columnas 'body_mass_g_mean_species' (promedio de masa de la especie) \n# y 'body_mass_g_species_normalized' (proporción con respecto al promedio de masa de la especie)\npenguins %>%\n  select(species, body_mass_g) %>%\n  group_by(species) %>%\n  mutate(body_mass_g_mean_species = mean(body_mass_g, na.rm = TRUE)) %>%\n  mutate(body_mass_g_species_normalized = body_mass_g / body_mass_g_mean_species)\n#> # A tibble: 344 × 4\n#> # Groups:   species [3]\n#>    species body_mass_g body_mass_g_mean_sp… body_mass_g_spe…\n#>    <fct>         <int>                <dbl>            <dbl>\n#>  1 Adelie         3750                3701.            1.01 \n#>  2 Adelie         3800                3701.            1.03 \n#>  3 Adelie         3250                3701.            0.878\n#>  4 Adelie           NA                3701.           NA    \n#>  5 Adelie         3450                3701.            0.932\n#>  6 Adelie         3650                3701.            0.986\n#>  7 Adelie         3625                3701.            0.980\n#>  8 Adelie         4675                3701.            1.26 \n#>  9 Adelie         3475                3701.            0.939\n#> 10 Adelie         4250                3701.            1.15 \n#> # … with 334 more rows"},{"path":"dplyr-gramática-para-manipulación-de-datos.html","id":"summarise","chapter":"11 dplyr: gramática para manipulación de datos","heading":"11.6.5 summarise()","text":"La función summarise() crea un nuevo data frame con una (o más filas), correspondientes combinaciones de las columnas usadas en una agrupación. Esta función frecuentemente se usa en combinación con group_by(). Si hay agrupación, se retorna una sola fila que sumariza todas las observaciones de la entrada.Sumarización sin agrupamiento:La función n() cuenta la cantidad de filas en un grupo.Sumarización con agrupamiento:","code":"\n# Creación de un data frame con las columnas sumarizadas 'body_mass_g_mean' (promedio de masa) \n# y 'n' (cantidad de individuos)\npenguins %>%\n  summarise(body_mass_g_mean = mean(body_mass_g, na.rm = TRUE),\n            n = n())\n#> # A tibble: 1 × 2\n#>   body_mass_g_mean     n\n#>              <dbl> <int>\n#> 1            4202.   344\n# Creación de un data frame con las columnas sumarizadas de mínimo, máximo y promedio de masa,\n# y cantidad de individuos para cada especie\npenguins %>%\n  group_by(species) %>%\n  summarise(\n    body_mass_g_min = min(body_mass_g, na.rm = TRUE),\n    body_mass_g_max = max(body_mass_g, na.rm = TRUE),\n    body_mass_g_mean = mean(body_mass_g, na.rm = TRUE),\n    n = n()\n  )\n#> # A tibble: 3 × 5\n#>   species   body_mass_g_min body_mass_g_max body_mass_g_mean\n#>   <fct>               <int>           <int>            <dbl>\n#> 1 Adelie               2850            4775            3701.\n#> 2 Chinstrap            2700            4800            3733.\n#> 3 Gentoo               3950            6300            5076.\n#> # … with 1 more variable: n <int>"},{"path":"dplyr-gramática-para-manipulación-de-datos.html","id":"otras","chapter":"11 dplyr: gramática para manipulación de datos","heading":"11.6.6 Otras","text":"","code":""},{"path":"dplyr-gramática-para-manipulación-de-datos.html","id":"count","chapter":"11 dplyr: gramática para manipulación de datos","heading":"11.6.6.1 count()","text":"Una forma alternativa (summarise()) de realizar un conteo es con la función count():","code":"\n# Creación de un data frame con el conteo de individuos por especie\npenguins %>%\n  count(species)\n#> # A tibble: 3 × 2\n#>   species       n\n#>   <fct>     <int>\n#> 1 Adelie      152\n#> 2 Chinstrap    68\n#> 3 Gentoo      124"},{"path":"dplyr-gramática-para-manipulación-de-datos.html","id":"ejercicios-14","chapter":"11 dplyr: gramática para manipulación de datos","heading":"11.7 Ejercicios","text":"En el data frame penguins, cree:\nUna columna llamada “body_mass_g_mean_species_sex” con el promedio de masa para la especie y el sexo los que pertenece cada individuo.\nUna columna llamada “body_mass_g_species_sex_normalized” con la proporción de la masa de cada individuo con respecto al promedio de masa para la especie y el sexo los que pertenece.\nUna columna llamada “body_mass_g_mean_species_sex” con el promedio de masa para la especie y el sexo los que pertenece cada individuo.Una columna llamada “body_mass_g_species_sex_normalized” con la proporción de la masa de cada individuo con respecto al promedio de masa para la especie y el sexo los que pertenece.Agrupe el data frame penguins por especie y sexo y obtenga el promedio de masa y la cantidad de individuos para cada grupo.","code":""},{"path":"dplyr-gramática-para-manipulación-de-datos.html","id":"recursos-de-interés-9","chapter":"11 dplyr: gramática para manipulación de datos","heading":"11.8 Recursos de interés","text":"Canelón, S. (2020). Antarctic Tour Tidyverse. https://spcanelon.github.io/tour---tidyverse/R- Ladies Global. (2020). R-Ladies Chicago (English)—Antarctic Tour Tidyverse—Silvia Canelón. https://www.youtube.com/watch?v=m_ZoMmAIx-oRStudio. (2017). Data transformation dplyr::Cheat Sheet. https://github.com/rstudio/cheatsheets/blob/45c1e642468695830fd8b724587ccfe8901e2185/data-transformation.pdfWickham, H., & Grolemund, G. (s. f.). R para Ciencia de Datos. Recuperado 14 de mayo de 2022, de https://es.r4ds.hadley.nz/","code":""},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"paquetes-de-r-para-graficación-estadística","chapter":"12 Paquetes de R para graficación estadística","heading":"12 Paquetes de R para graficación estadística","text":"","code":""},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"opciones-generales","chapter":"12 Paquetes de R para graficación estadística","heading":"12.1 Opciones generales","text":"Se configuran opciones generales de la sesión R.","code":"\n# Configuración de la notación científica\noptions(scipen = 7)"},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"trabajo-previo-7","chapter":"12 Paquetes de R para graficación estadística","heading":"12.2 Trabajo previo","text":"","code":""},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"lecturas-5","chapter":"12 Paquetes de R para graficación estadística","heading":"12.2.1 Lecturas","text":"Chang, W. (2018). R graphics cookbook: Practical recipes visualizing data. O’Reilly. https://r-graphics.org/Wickham, H., & Grolemund, G. (2017). R Data Science: Import, Tidy, Transform, Visualize, Model Data (capítulo 3). O’Reilly Media. https://r4ds..co.nz/","code":""},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"resumen-11","chapter":"12 Paquetes de R para graficación estadística","heading":"12.3 Resumen","text":"R proporciona una gran cantidad de funciones para la elaboración de gráficos estadísticos. En este capítulo, se describen algunos de los paquetes que contienen estas funciones y se ejemplifican varios tipos de gráficos.","code":""},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"paquetes-2","chapter":"12 Paquetes de R para graficación estadística","heading":"12.4 Paquetes","text":"Se presentan ejemplos de los paquetes graphics, ggplot2 y plotly.","code":""},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"graphics","chapter":"12 Paquetes de R para graficación estadística","heading":"12.4.1 graphics","text":"graphics forma parte de la instalación base de R. Es muy versátil y permite construir una gran cantidad de tipos de gráficos. Sin embargo, estos graficos son estáticos y ofrecen posibilidades de interacción con el usuario.","code":""},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"ggplot2","chapter":"12 Paquetes de R para graficación estadística","heading":"12.4.2 ggplot2","text":"ggplot2 es un sistema para la creación declarativa de gráficos, basado en el libro Grammar Graphics, de Wilkinson et al.. El programador proporciona los datos, indica cuales variables mapear las propiedades visuales (estéticas o aesthetics) de las geometrías y ggplot2 trata de encargarse del resto de los detalles.De acuerdo con Grammar Graphics, los componentes de un gráfico son:Un conjunto de datos y un mapeo de sus variables elementos visuales o aesthetics (x, y, color tamaño, forma, etc.).Una o más capas, cada una con un objeto geométrico, una transformación estadística, un ajuste de posición y, opcionalmente, su propio conjunto de datos y de mapeos elementos visuales.Una escala para cada mapeo de elementos visuales.Un sistema de coordenadas.Una especificación de facets.ggplot2 implementa estos componentes por medio de la función ggplot(), cuya sintaxis puede resumirse de la siguiente forma:ggplot2 provee más de 40 tipos de geometrías para gráficos (puntos, líneas, barras, histogramas, cajas, etc.) y los paquetes de extensión proporcionan aún más (ej. https://exts.ggplot2.tidyverse.org/gallery/). Para una explicación resumida de ggplot2, se recomienda Data visualization ggplot2::Cheat Sheet.","code":"ggplot(data = <DATA>, mapping = aes(<MAPPINGS>)) + \n  <GEOM_FUNCTION>(\n     mapping = aes(<MAPPINGS>),\n     stat = <STAT>, \n     position = <POSITION>\n  ) +\n  <COORDINATE_FUNCTION> +\n  <FACET_FUNCTION>"},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"plotly","chapter":"12 Paquetes de R para graficación estadística","heading":"12.4.3 plotly","text":"plotly R es una biblioteca para gráficos interactivos que forma parte de la familia de Plotly, la cual incluye bibliotecas para otros lenguajes como JavaScript, Python, Julia, F# y MATLAB. Es adecuada, por ejemplo, cuando los gráficos van utilizarse en la Web. Incluye una función llamada ggplotly() que permite convertir gráficos de ggplot2 plotly.","code":""},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"instalación-y-carga-2","chapter":"12 Paquetes de R para graficación estadística","heading":"12.4.4 Instalación y carga","text":"Seguidamente, se muestran las instrucciones para instalar y cargar estos paquetes. El paquete graphics forma parte de la instalación base de R, por lo que necesita ser instalado ni cargado explícitamente.Adicionalmente, se cargan otros paquetes para importación y transformación de datos.Existen muchos otros paquetes de R para graficación, entre los que pueden mencionarse:lattice: es especialmente utilizado para datos multivariados.ggvis: agrega interactividad los gráficos de ggplot2.rgl: para gráficos en 3D.","code":"\n# Instalación de paquetes de graficación\ninstall.packages(\"ggplot2\")\ninstall.packages(\"plotly\")\n# Carga de paquetes de graficación\nlibrary(ggplot2)\nlibrary(plotly)\n# Carga de otros paquetes\nlibrary(readr) # paquete para transformación de datos\nlibrary(dplyr) # paquete para transformación de datos"},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"conjuntos-de-datos-para-ejemplos","chapter":"12 Paquetes de R para graficación estadística","heading":"12.5 Conjuntos de datos para ejemplos","text":"Para ejemplificar el uso de estos paquetes de graficación, se utilizarán varios conjuntos de datos. En esta sección, el contenido de estos conjuntos se muestra con el paquete DT, el cual despliega data frames como tablas en HTML con capacidades de filtrado, paginación, ordenamiento y otras.Para cada conjunto de datos, se muestran los siguientes procesos del modelo de ciencia de datos: importación, transformación y visualización (en tablas).","code":"\n# Instalación del paquete DT\ninstall.packages(\"DT\")\n# Carga del paquete DT\nlibrary(DT)"},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"mtcars","chapter":"12 Paquetes de R para graficación estadística","heading":"12.5.1 mtcars","text":"mtcars: Motor Trend Car Road Tests contiene datos de aspectos de diseño y consumo de combustible para 32 modelos de automóviles. Es uno de los conjuntos de datos contenidos en la instalación base de R, por lo que es necesario importarlo desde una fuente externa.Transformación:Visualización en formato tabular:","code":"\n# Transformación de datos de mtcars\nmtcars <-\n  datasets::mtcars %>%\n  select(mpg, cyl, wt, gear)\n# Visualización de datos de mtcars en formato tabular\nmtcars %>%\n  datatable(options = list(\n    pageLength = 5,\n    language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')\n  ))"},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"covid-19","chapter":"12 Paquetes de R para graficación estadística","heading":"12.5.2 Covid-19","text":"Estos son datos publicados por el Ministerio de Salud de Costa Rica sobre la situación nacional de covid-19. Se distribuyen en archivos CSV, algunos correspondientes al nivel nacional y otros al nivel cantonal.","code":""},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"datos-nacionales","chapter":"12 Paquetes de R para graficación estadística","heading":"12.5.2.1 Datos nacionales","text":"Este conjunto de datos contiene una observación por fecha y variables correspondientes , entre otras, las cantidades de casos positivos, fallecidos, recuperados y activos nivel nacional.Importación:Transformación:Visualización en formato tabular:","code":"\n# Importación de datos nacionales de covid-19\ncovid_nacional <-\n  read_delim(\n    file = \"datos/ministerio-salud/covid/05_24_22_CSV_GENERAL.csv\",\n    delim = \";\",\n    col_select = c(\"FECHA\", \"positivos\", \"fallecidos\", \"RECUPERADOS\", \"activos\")\n  )\n# Transformación de datos nacionales de covid-19\ncovid_nacional <-\n  covid_nacional %>%\n  select(fecha = FECHA,\n         positivos,\n         fallecidos,\n         recuperados = RECUPERADOS,\n         activos) %>%\n  mutate(fecha = as.Date(fecha, format = \"%d/%m/%Y\"))\n# Visualización de datos nacionales de covid-19 en formato tabular\ncovid_nacional %>%\n  datatable(options = list(\n    pageLength = 5,\n    language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')\n  ))"},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"casos-positivos-por-cantón","chapter":"12 Paquetes de R para graficación estadística","heading":"12.5.2.2 Casos positivos por cantón","text":"Este conjunto de datos contiene una observación por cantón y variables correspondientes la cantidad de casos positivos para cada fecha. En los ejemplos siguientes, se utiliza solamente la variable correspondiente la fecha máxima.Importación:Transformación:Visualización en formato tabular:","code":"\n# Importación de casos positivos de covid-19 por cantón\ncovid_cantonal_positivos <-\n  read_delim(\n    file = \"datos/ministerio-salud/covid/05_24_22_CSV_POSITIVOS.csv\",\n    delim = \";\",\n    locale = locale(encoding = \"WINDOWS-1252\"), # esto es para resolver el problema con las tildes\n    col_select = c(\"canton\", \"24/05/2022\")\n  )\n# Transformación de casos positivos de covid-19 por cantón\ncovid_cantonal_positivos <-\n  covid_cantonal_positivos %>%\n  rename(positivos = '24/05/2022') %>% # renombramiento de columna\n  filter(!is.na(canton) & canton != \"Otros\") # borrado de filas con valor NA u \"Otros\" en la columna canton\n# Visualización de casos positivos de covid-19 por cantón en formato tabular\ncovid_cantonal_positivos %>%\n  datatable(options = list(\n    pageLength = 5,\n    language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')\n  ))"},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"diamonds","chapter":"12 Paquetes de R para graficación estadística","heading":"12.5.3 diamonds","text":"diamonds: Prices 50,000 round cut diamonds contiene los precios y otros atributos de casi 54000 diamantes. Este conjunto de datos está incluído en el paquete ggplot2.","code":"\n# Visualización de una muestra de 1000 observaciones de diamonds en formato tabular\ndiamonds %>%\n  sample_n(1000) %>%\n  datatable(options = list(\n    pageLength = 5,\n    language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')\n  ))"},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"tipos-de-gráficos-y-ejemplos","chapter":"12 Paquetes de R para graficación estadística","heading":"12.6 Tipos de gráficos y ejemplos","text":"En esta sección, se explican y ejemplifican varios tipos de gráficos estadísticos.","code":""},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"gráficos-de-dispersión-1","chapter":"12 Paquetes de R para graficación estadística","heading":"12.6.1 Gráficos de dispersión","text":"Un gráfico de dispersión o scatterplot despliega los valores de dos variables numéricas de un conjunto de datos, como puntos en un sistema de coordenadas. El valor de una variable se despliega en el eje X y el de la otra variable en el eje Y. Variables adicionales pueden ser mostradas mediante atributos de los puntos, tales como tamaño, color y forma.Los siguientes gráficos de dispersión presentan la relación entre las variables wt (peso en miles de libras) y mpg (rendimiento en millas por galón de combustible) del conjunto de datos mtcars.","code":""},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"graphics-1","chapter":"12 Paquetes de R para graficación estadística","heading":"12.6.1.1 graphics","text":"","code":"\n# graphics - gráfico de dispersión\nplot(\n  x = mtcars$wt,\n  y = mtcars$mpg,\n  main = \"Peso vs. rendimiento de automóviles\",\n  xlab = \"Peso (miles de libras)\",\n  ylab = \"Rendimiento (millas por galón de combustible)\",\n  col = mtcars$cyl\n)"},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"ggplot2-1","chapter":"12 Paquetes de R para graficación estadística","heading":"12.6.1.2 ggplot2","text":"El argumento text de aes() en geom_pont() permite especificar texto que se despliega al colocar el ratón sobre un punto, cuando se utiliza la función ggplotly().","code":"\n# ggplot2 - gráfico de dispersión\nggplot2_mtcars_dispersion <-\n  mtcars %>%\n  ggplot(aes(x = wt, y = mpg)) +\n  geom_point(aes(text = rownames(mtcars), color = factor(cyl))) +\n  ggtitle(\"Peso vs. rendimiento de automóviles\") +\n  xlab(\"Peso (miles de libras)\") +\n  ylab(\"Rendimiento (millas por galón de combustible)\") +\n  labs(color = \"Cilindros\")\n#> Warning: Ignoring unknown aesthetics: text\n\nggplot2_mtcars_dispersion"},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"ggplotly","chapter":"12 Paquetes de R para graficación estadística","heading":"12.6.1.3 ggplotly","text":"","code":"\n# ggplotly - gráfico de dispersión\nggplotly(ggplot2_mtcars_dispersion) %>% config(locale = 'es')"},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"plotly-1","chapter":"12 Paquetes de R para graficación estadística","heading":"12.6.1.4 plotly","text":"El argumento text de plot_ly() permite especificar texto que se despliega al colocar el ratón sobre un punto.","code":"\n# plotly - gráfico de dispersión\nmtcars %>%\n  plot_ly(x = ~ wt,\n          y = ~ mpg,\n          text = rownames(mtcars),\n          color = ~ factor(cyl)) %>% layout(\n            title = \"Peso vs. rendimiento de automóviles\",\n            xaxis = list(title = \"Peso (miles de libras)\"),\n            yaxis = list(title = \"Rendimiento (millas por galón de combustible)\")\n          ) %>% layout(legend = list(title = list(text = \"Cilindros\"))) %>% config(locale = 'es')"},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"gráficos-de-líneas","chapter":"12 Paquetes de R para graficación estadística","heading":"12.6.2 Gráficos de líneas","text":"Un gráfico de líneas muestra información en la forma de puntos de datos, llamados marcadores (markers), conectados por segmentos de líneas rectas. Es similar un gráfico de dispersión pero, además de los segmentos de línea, tiene la particularidad de que los datos están ordenados, usualmente con respecto al eje X. Los gráficos de línea son usados frecuentemente para mostrar tendencias través del tiempo.Los siguientes gráficos de línea muestran la evolución en el tiempo de los casos positivos, fallecidos, recuperados y activos de covid-19 en Costa Rica.","code":""},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"graphics-2","chapter":"12 Paquetes de R para graficación estadística","heading":"12.6.2.1 graphics","text":"","code":"\n# graphics - gráfico de línea\nplot(\n  covid_nacional$fecha,\n  covid_nacional$positivos,\n  type = \"l\",\n  xaxt = \"n\",\n  yaxt = \"n\",\n  main = \"Casos acumulados de covid-19 en Costa Rica\",\n  xlab = \"Fecha\",\n  ylab = \"Casos\",\n  col = \"blue\"\n)\n\n# Casos recuperados\nlines(covid_nacional$fecha, covid_nacional$recuperados, col=\"green\")\n\n# Casos activos\nlines(covid_nacional$fecha, covid_nacional$activos, col=\"red\")\n\n# Casos fallecidos\nlines(covid_nacional$fecha, covid_nacional$fallecidos, col=\"black\")\n\n# Leyenda\nlegend(\n  x = \"topleft\",\n  inset = 0.03,\n  legend = c(\"Positivos\", \"Recuperados\", \"Activos\", \"Fallecidos\"),\n  col = c(\"blue\", \"green\", \"red\", \"black\"),\n  lty = 1,\n  cex = 0.7)\n\n# Formato del eje X\naxis(side = 1,\n     covid_nacional$fecha,\n     tick = FALSE,\n     format(covid_nacional$fecha, \"%m-%y\"),\n     cex.axis = .7)\n\n# Formato del eje Y\naxis(\n  side = 2,\n  covid_nacional$positivos,\n  labels = TRUE,  \n  at = seq(0, 1000000, by = 200000),\n  cex.axis = .7\n)"},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"ggplot2-2","chapter":"12 Paquetes de R para graficación estadística","heading":"12.6.2.2 ggplot2","text":"","code":"\n# ggplot2 - gráfico de línea\nggplot2_covid_nacional_linea <-\n  covid_nacional %>%\n  ggplot(aes(x = fecha, y = value, color = variable)) +\n  ggtitle(\"Casos acumulados de covid-19 en Costa Rica\") +\n  xlab(\"Fecha\") +\n  ylab(\"Casos\") +\n  geom_line(aes(y = positivos, color = \"Positivos\")) +\n  geom_line(aes(y = recuperados, color = \"Recuperados\")) +\n  geom_line(aes(y = activos, color = \"Activos\")) +\n  geom_line(aes(y = fallecidos, color = \"Fallecidos\")) +\n  scale_colour_manual(\n    \"\",\n    values = c(\n      \"Positivos\" = \"blue\",\n      \"Recuperados\" = \"green\",\n      \"Activos\" = \"red\",\n      \"Fallecidos\" = \"black\"\n    )\n  )\n\nggplot2_covid_nacional_linea"},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"ggplotly-1","chapter":"12 Paquetes de R para graficación estadística","heading":"12.6.2.3 ggplotly","text":"","code":"\n# ggplotly - gráfico de línea\nggplotly(ggplot2_covid_nacional_linea) %>% layout(legend = list(x = 0.1, y = 0.9)) %>% config(locale = 'es')"},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"plotly-2","chapter":"12 Paquetes de R para graficación estadística","heading":"12.6.2.4 plotly","text":"","code":"\n# plotly - gráfico de línea\ncovid_nacional %>%\n  plot_ly(\n    x = ~ fecha,\n    y = ~ positivos,\n    name = 'Positivos',\n    type = 'scatter',\n    mode = 'lines',\n    line = list(color = \"blue\")\n  ) %>%\n  add_trace(\n    y = ~ recuperados,\n    name = 'Recuperados',\n    mode = 'lines',\n    line = list(color = \"green\")\n  ) %>%\n  add_trace(\n    y = ~ activos,\n    name = 'Activos',\n    mode = 'lines',\n    line = list(color = \"red\")\n  ) %>%\n  add_trace(\n    y = ~ fallecidos,\n    name = 'Fallecidos',\n    mode = 'lines',\n    line = list(color = \"black\")\n  ) %>%\n  layout(\n    title = \"\",\n    yaxis = list(title = \"Casos\"),\n    xaxis = list(title = \"Fecha\"),\n    legend = list(x = 0.1, y = 0.9),\n    hovermode = \"x unified\"\n  )"},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"gráficos-de-barras","chapter":"12 Paquetes de R para graficación estadística","heading":"12.6.3 Gráficos de barras","text":"Un gráfico de barras se compone de barras rectangulares con longitud proporcional estadísticas (ej. frecuencias, promedios, mínimos, máximos) asociadas una variable categórica. Las barras pueden ser horizontales o verticales y se recomienda que estén ordenadas según su longitud, menos que exista un orden inherente la variable categórica (ej. el orden de los días de la semana).Es uno de los tipos de gráficos estadísticos más antiguos y comunes y tiene la ventaja de ser muy fácil de comprender.","code":""},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"ggplot2---ggplotly","chapter":"12 Paquetes de R para graficación estadística","heading":"12.6.3.1 ggplot2 - ggplotly()","text":"En esta sección, se muestran ejemplos de gráficos de barras generados con el paquete ggplot2 y convertidos gráficos de plotly mediante la función ggplotly().","code":""},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"barras-con-transformaciones-estadísticas","chapter":"12 Paquetes de R para graficación estadística","heading":"12.6.3.1.1 Barras con transformaciones estadísticas","text":"Los gráficos de barras y otros tipos de gráficos (ej. histogramas, gráficos de caja, líneas de ajuste) pueden requerir de alguna transformación estadística antes de presentar la información. Por ejemplo, el siguiente gráfico muestra la cantidad de diamantes por tipo de corte (cut). Nótese que este conteo está presente en ninguna de las variables del conjunto de datos.El cálculo de la cantidad de diamantes por tipo de corte es un ejemplo de transformación estadística. La figura 12.1 muestra como se realiza este proceso para el gráfico anterior.\nFigure 12.1: Transformación estadística para un gráfico de barras de ggplot2. Imagen de Hadley Wickham.\nEl tipo de transformación se especifica en el argumento stat de geom_bar() el cual, por defecto, tiene el valor count. Es posible cambiar la transformación representada en el eje y, con la función stat().El siguiente gráfico muestra la cantidad proporcional de cada corte de diamantes mediante el uso del argumento y = stat(prop).Las barras pueden mostrar otras transformaciones estadísticas, como el promedio, con los argumentos stat = \"summary\" y fun.y = \"mean\" de geom_bar().continuación, se muestra el cálculo del precio promedio de diamantes por tipo de corte con la función summarise() y luego el gráfico de barras correspondiente.","code":"\n# ggplotly - Gráfico de barras simples con valores de conteo\nggplot2_barras_conteo <-\n  diamonds %>%\n  ggplot(aes(x = cut)) +\n  geom_bar() +\n  ggtitle(\"Cantidad de diamantes por tipo de corte\") +\n  xlab(\"Corte\") +\n  ylab(\"Cantidad\") +\n  theme_minimal()\n\nggplotly(ggplot2_barras_conteo) %>% config(locale = 'es')\n# ggplotly - Gráfico de barras simples con valores proporcionales\nggplot2_barras_proporcion <-\n  diamonds %>%\n  ggplot(aes(x = cut, y = stat(prop), group = 1)) +\n  geom_bar() +\n  ggtitle(\"Proporciones de tipos de corte de diamantes\") +\n  xlab(\"Corte\") +\n  ylab(\"Proporción\") +\n  theme_minimal()\n\nggplotly(ggplot2_barras_proporcion) %>% config(locale = 'es')\n# Precio promedio de diamantes por tipo de corte\ndiamonds %>%\n  group_by(clarity) %>%\n  summarise(\n    price_avg = mean(price, na.rm = TRUE),\n    n = n()\n  )\n#> # A tibble: 8 × 3\n#>   clarity price_avg     n\n#>   <ord>       <dbl> <int>\n#> 1 I1          3924.   741\n#> 2 SI2         5063.  9194\n#> 3 SI1         3996. 13065\n#> 4 VS2         3925. 12258\n#> 5 VS1         3839.  8171\n#> 6 VVS2        3284.  5066\n#> 7 VVS1        2523.  3655\n#> 8 IF          2865.  1790\n# ggplotly - Gráfico de barras simples con promedio de una variable\nggplot2_barras_promedio <-\n  diamonds %>%\n  ggplot(aes(x = cut, y = price)) +\n  geom_bar(stat = \"summary\", fun.y = \"mean\") +\n  ggtitle(\"Precio promedio de diamantes por tipo de corte\") +\n  xlab(\"Corte\") +\n  ylab(\"Precio promedio (dólares estadounidenses)\") +\n  theme_minimal()\n#> Warning: Ignoring unknown parameters: fun.y\n\nggplotly(ggplot2_barras_promedio) %>% config(locale = 'es')\n#> No summary function supplied, defaulting to `mean_se()`"},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"barras-sin-transformaciones-estadísticas","chapter":"12 Paquetes de R para graficación estadística","heading":"12.6.3.1.2 Barras sin transformaciones estadísticas","text":"En algunos conjuntos de datos, el valor que se quiere representar en la longitud de las barras ya está presente como una variable en el conjunto de datos, por lo que es necesario que ggplot2 realice una transformación estadística. En este caso, stat se le asigna el valor “identity” y al argumento y de aes() la variable que contiene el valor que quiere mostrarse en las barras.En el siguiente gráfico, se muestra en las barras la cantidad de casos positivos por cantón, tomada de la columna positivos del conjunto de datos covid_cantonal_positivos.","code":"\n# ggplotly - Gráfico de barras simples con valores de \"identity\"\nggplot2_barras_identity <-\ncovid_cantonal_positivos %>%\n  slice_max(positivos, n = 15) %>% # se seleccionan los 15 cantones con mayor cantidad de casos\n  ggplot(aes(x = reorder(canton, positivos), y = positivos)) +\n  geom_bar(stat = \"identity\") +\n  ggtitle(\"Cantidad de casos positivos de covid-19 por cantón\") +\n  xlab(\"Cantón\") +\n  ylab(\"Casos positivos\") +\n  coord_flip() + # se invierten los ejes para generar barras horizontales\n  theme_minimal()\n\nggplotly(ggplot2_barras_identity) %>% config(locale = 'es')"},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"barras-apiladas","chapter":"12 Paquetes de R para graficación estadística","heading":"12.6.3.1.3 Barras apiladas","text":"Al usar el argumento fill de aes() las barras pueden dividirse de acuerdo con una variable adicional, dando el efecto de barras apiladas.El argumento position = \"fill\" de geom_bar() también genera barras apiladas, pero le asigna todas las barras la misma longitud, facilitando así la comparación de proporciones.","code":"\n# ggplotly - Gráfico de barras apiladas de cantidades\nggplot2_barras_apiladas_cantidad <-\n  diamonds %>%\n  ggplot(aes(x = cut, fill = clarity)) +\n  geom_bar() +\n  ggtitle(\"Cantidad de diamantes por tipo de corte y claridad\") +\n  xlab(\"Corte\") +\n  ylab(\"Cantidad\") +\n  labs(fill = \"Claridad\") +\n  theme_minimal()\n\nggplotly(ggplot2_barras_apiladas_cantidad) %>% config(locale = 'es')\n# ggplotly - Gráfico de barras apiladas de proporciones\nggplot2_barras_apiladas_proporcion <-\n  diamonds %>%\n  ggplot(aes(x = cut, fill = clarity)) +\n  geom_bar(position = \"fill\") +\n  ggtitle(\"Proporciones de claridad por tipo de corte de diamantes\") +\n  xlab(\"Corte\") +\n  ylab(\"Proporción\") +\n  labs(fill = \"Claridad\") +\n  theme_minimal()\n\nggplotly(ggplot2_barras_apiladas_proporcion) %>% config(locale = 'es')"},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"barras-agrupadas","chapter":"12 Paquetes de R para graficación estadística","heading":"12.6.3.1.4 Barras agrupadas","text":"El argumento position = \"dodge\" de geom_bar() genera barras agrupadas, facilitando así la comparación de valores individuales.","code":"\n# ggplotly - Gráfico de barras agrupadas\nggplot2_barras_agrupadas <-\n  diamonds %>%\n  ggplot(aes(x = cut, fill = clarity)) +\n  geom_bar(position = \"dodge\") +\n  ggtitle(\"Cantidad de diamantes por tipo de corte y claridad\") +\n  xlab(\"Corte\") +\n  ylab(\"Cantidad\") +\n  labs(fill = \"Claridad\") +\n  theme_minimal()\n\nggplotly(ggplot2_barras_agrupadas) %>% config(locale = 'es')"},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"histogramas-1","chapter":"12 Paquetes de R para graficación estadística","heading":"12.6.4 Histogramas","text":"Un histograma es una representación gráfica de la distribución de una variable numérica en forma de barras (llamadas en inglés bins). La longitud de cada barra representa la frecuencia de un rango de valores de la variable. La graficación de la distribución de las variables es, frecuentemente, una de las primeras tareas que se realiza cuando se explora un conjunto de datos.","code":""},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"ggplot2---ggplotly-1","chapter":"12 Paquetes de R para graficación estadística","heading":"12.6.4.1 ggplot2 - ggplotly()","text":"Los siguientes histogramas muestran la distribución de las variables price (precio en dólares estadounidenses) y carat (peso en quilates).Debe tenerse en cuenta que los argumentos bins y binsize de geom_histogram() determinan en gran medida el aspecto del histograma, por lo que puede ser necesario probarlos con diferentes valores.Un mismo histograma puede presentar la distribución de varios valores de una variable categórica, como se muestra en el siguiente gráfico.","code":"\n# ggplotly - histograma\nggplot2_histograma_diamantes_precio <-\n  diamonds %>%\n  ggplot(aes(x = price)) +\n  geom_histogram(bins = 20) + # cantidad de barras (bins) +  \n  ggtitle(\"Distribución del precio de diamantes\") +\n  xlab(\"Precio (dólares estadounidenses)\") +\n  ylab(\"Frecuencia\") +\n  theme_minimal()\n\nggplotly(ggplot2_histograma_diamantes_precio) %>% config(locale = 'es')  \n# ggplotly - histograma\nggplot2_histograma_diamantes_peso <-\n  diamonds %>%\n  ggplot(aes(x = carat)) +\n  geom_histogram(binwidth = 0.5) + # ancho de las barras +  \n  ggtitle(\"Distribución del peso de diamantes\") +\n  xlab(\"Peso (quilates)\") +\n  ylab(\"Frecuencia\") +\n  theme_minimal()\n\nggplotly(ggplot2_histograma_diamantes_peso) %>% config(locale = 'es')  \n# ggplotly - histograma con distribución de dos valores de una variable\nggplot2_histograma_diamantes_precio_claridad <-\n  diamonds %>%\n  filter(clarity == \"SI2\" | clarity == \"VS1\") %>%\n  ggplot(aes(x = price, fill = clarity)) +\n  geom_histogram(position = \"identity\", alpha = 0.4) + # ancho de las barras\n  ggtitle(\"Distribución del precio de diamantes de claridad 'SI2' y 'VS1'\") +\n  xlab(\"Precio (dólares estadounidenses)\") +\n  ylab(\"Frecuencia\") +\n  theme_minimal()\n\nggplotly(ggplot2_histograma_diamantes_precio_claridad) %>% config(locale = 'es')  "},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"diagramas-de-caja-1","chapter":"12 Paquetes de R para graficación estadística","heading":"12.6.5 Diagramas de caja","text":"Un diagrama de caja muestra información de una variable numérica través de su mediana, sus cuartiles (Q1, Q2 y Q3) y sus valores atípicos.La figura 12.2 muestra los componentes de un diagrama de caja.\nFigure 12.2: Componentes de un diagrama de caja. Imagen de Onkel Dagobert.\n","code":""},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"ggplot2---ggplotly-2","chapter":"12 Paquetes de R para graficación estadística","heading":"12.6.5.1 ggplot2 - ggplotly()","text":"El siguiente diagrama de caja muestra los valores de Q1, Q2 (mediana), Q3, mínimo y máximo de la variable mpg (millas por galón).El argumento x de la función aes() puede utilizarse para mostrar el diagrama anterior categorizado por otra variable.","code":"\n# ggplot2 - diagrama de caja\nggplot2_diagrama_caja_mtcars_mpg <-\n  mtcars %>%\n  ggplot(aes(y = mpg)) +\n  geom_boxplot() +\n  ylab(\"Rendimiento (millas por galón de combustible)\") +  \n  theme_minimal()\n  \nggplotly(ggplot2_diagrama_caja_mtcars_mpg) %>% config(locale = 'es')  \n# ggplot2 - diagrama de caja categorizado\nggplot2_diagrama_caja_mtcars_mpg_marchas <-\n  mtcars %>%\n  ggplot(aes(x = factor(gear), y = mpg)) +\n  geom_boxplot() +\n  xlab(\"Cantidad de marchas\") +\n  ylab(\"Rendimiento (millas por galón de combustible)\") +\n  theme_minimal()\n\nggplotly(ggplot2_diagrama_caja_mtcars_mpg_marchas) %>% config(locale = 'es')"},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"gráficos-de-pastel","chapter":"12 Paquetes de R para graficación estadística","heading":"12.6.6 Gráficos de pastel","text":"Un gráfico de pastel representa porcentajes y porciones en secciones (slices) de un círculo. Son muy populares, pero también criticados debido la dificultad del cerebro humano de comparar áreas de sectores circulares, por lo que algunos expertos recomiendan sustituirlos por otros tipos de gráficos como, por ejemplo, gráficos de barras.En los siguientes ejemplos, se utiliza un data frame llamado diamonds_cut que contiene el porcentaje que representa la cantidad de diamantes de cada tipo de corte (cut) con respecto al total.Seguidamente, se presentan ejemplos de gráficos de pastel elaborados con ggplot2 y plotly.","code":"\nn <- nrow(diamonds)\n\ndiamonds_cut <-\n  diamonds %>%\n  group_by(cut) %>%\n  summarise(cut_count = n(), cut_pct = round(cut_count/n * 100, digits = 1))"},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"ggplot2-3","chapter":"12 Paquetes de R para graficación estadística","heading":"12.6.6.1 ggplot2","text":"es posible traducir un gráfico de pastel de ggplot2 plotly mediante ggplotly() debido que esa función aún cuenta con soporte para coord_polar().","code":"\n# ggplot2 - gráfico de pastel\ndiamonds_cut %>%\n  ggplot(aes(x = factor(1), y = cut_pct, fill = cut)) +\n  geom_bar(stat = \"identity\", width = 1) +\n  coord_polar(\"y\") +\n  geom_text(aes(label = paste(cut_pct, \"%\")), position = position_stack(vjust=0.5)) +\n  scale_fill_brewer(palette = \"Spectral\") +\n  theme_void()"},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"plotly-3","chapter":"12 Paquetes de R para graficación estadística","heading":"12.6.6.2 plotly","text":"","code":"\n# ggplot2 - gráfico de pastel\ndiamonds_cut %>%\n  plot_ly(\n    labels = ~ cut,\n    values = ~ cut_count,\n    type = 'pie',\n    textposition = 'inside',\n    textinfo = 'label+percent',\n    hoverinfo = 'text',\n    text = ~ paste(cut_count, ' diamantes')\n  ) %>%\n  layout(title = 'Proporciones de tipos de corte de diamantes') %>%\n  config(locale = 'es')"},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"facets","chapter":"12 Paquetes de R para graficación estadística","heading":"12.6.7 Facets","text":"La función aes() es una forma de introducir variables adicionales en gráficos. Otra forma es dividir el gráfico en facets, los cuales son subgráficos que despliegan subconjuntos de los datos.Los facets se implementan mediante las funciones facet_wrap() y facet_grid().","code":""},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"facet_wrap","chapter":"12 Paquetes de R para graficación estadística","heading":"12.6.7.1 facet_wrap()","text":"facet_wrap() divide el gráfico de acuerdo con una sola variable. El primer argumento es una formula, la cual se crea con el caracter ~ seguido por el nombre de una variable, la cual debe ser discreta.","code":"\ndiamonds %>%\n  ggplot(aes(x = carat, y = price)) +\n  geom_point() +\n  xlab(\"Peso (quilates)\") +\n  ylab(\"Precio (dólares estadounidenses)\") +\n  facet_wrap(~ cut, nrow = 2)"},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"facet_grid","chapter":"12 Paquetes de R para graficación estadística","heading":"12.6.7.2 facet_grid()","text":"facet_grid() genera los subgráficos con la combinación de dos variables. El primer argumento es también una fórmula, la cual contiene dos variables separadas por ~.","code":"\nggplot(data = diamonds) + \n  geom_point(mapping = aes(x = carat, y = price)) + \n  xlab(\"Peso (quilates)\") +\n  ylab(\"Precio (dólares estadounidenses)\") +  \n  facet_grid(cut ~ clarity)"},{"path":"paquetes-de-r-para-graficación-estadística.html","id":"recursos-de-interés-10","chapter":"12 Paquetes de R para graficación estadística","heading":"12.7 Recursos de interés","text":"DT: R interface DataTables library. (s. f.). Recuperado 21 de mayo de 2022, de https://rstudio.github.io/DT/Healy, Y. H. C. (s. f.). data Viz | Find graphic need. Recuperado 20 de marzo de 2022, de https://www.data--viz.com/RStudio. (2017). Data visualization ggplot2::Cheat Sheet. https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-visualization.pdfWickham, H. (2010). Layered Grammar Graphics. Journal Computational Graphical Statistics, 19(1), 3-28. https://doi.org/10.1198/jcgs.2009.07098","code":""},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"introducción-al-manejo-de-datos-geoespaciales-en-r","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13 Introducción al manejo de datos geoespaciales en R","text":"","code":""},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"resumen-12","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.1 Resumen","text":"El lenguaje de programación R cuenta con varios paquetes para manejo de datos geoespaciales, entre los que están el paquete sf para datos vectoriales, el paquete terra para datos raster y el paquete leaflet para mapas en la Web.","code":""},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"trabajo-previo-8","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.2 Trabajo previo","text":"","code":""},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"lecturas-6","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.2.1 Lecturas","text":"Lovelace, R., Nowosad, J., & Münchow, J. (2019). Geocomputation R (capítulos 1 y 2). CRC Press. https://geocompr.robinlovelace.net/","code":""},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"preparativos","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.3 Preparativos","text":"","code":""},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"carga-de-paquetes","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.3.1 Carga de paquetes","text":"","code":"\n# Paquete para transformación de datos\nlibrary(dplyr)"},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"introducción","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.4 Introducción","text":"La comunidad de programadores de R ha desarrollado un conjunto de paquetes para el manejo de datos geoespaciales, tanto en formatos vectoriales como raster. Algunos de los principales de estos paquetes son:El paquete sf. Ofrece un conjunto de funciones para el manejo de datos vectoriales, de acuerdo con el estándar Simple Features.El paquete sf. Ofrece un conjunto de funciones para el manejo de datos vectoriales, de acuerdo con el estándar Simple Features.El paquete terra. Implementa un conjunto de funciones para el manejo de datos raster. Es una reimplementación del paquete raster.El paquete terra. Implementa un conjunto de funciones para el manejo de datos raster. Es una reimplementación del paquete raster.El paquete leaflet. Es una implementación en R de la biblioteca Leaflet para el lenguaje JavaScript para la programación de mapas interactivos en páginas web.El paquete leaflet. Es una implementación en R de la biblioteca Leaflet para el lenguaje JavaScript para la programación de mapas interactivos en páginas web.Algunos paquetes de graficación estadística, como ggplot2 y plotly, también cuentan con capacidades para visualización de datos geoespaciales.En CRAN Task View: Analysis Spatial Data, puede encontrarse un resumen detallado de los paquetes geoespaciales de R.","code":""},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"datos-vectoriales","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.5 Datos vectoriales","text":"","code":""},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"el-modelo-vectorial","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.5.1 El modelo vectorial","text":"El modelo vectorial de datos está basado en puntos localizados en un sistema de referencia de coordenadas (CRS). Los puntos individuales pueden representar objetos independientes (ej. postes eléctricos, cabinas telefónicas) o pueden también agruparse para formar geometrías más complejas como líneas (ej. ríos, caminos) o polígonos (ej. fincas, países, provincias). Por lo general, los puntos tienen solo dos dimensiones (x, y), las que se les puede agregar una tercera dimensión z, usualmente correspondiente la altitud sobre el nivel del mar.","code":""},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"el-estándar-simple-features","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.5.2 El estándar Simple Features","text":"Simple Features (o Simple Feature Access) es un estándar abierto de la Organización Internacional de Estandarización (ISO) y del Open Geospatial Consortium (OGC) que especifica un modelo común de almacenamiento y acceso para geometrías de dos dimensiones (líneas, polígonos, multilíneas, multipolígonos, etc.). El estándar es implementado por muchas bibliotecas y bases de datos geoespaciales como sf, Fiona, GDAL, PostgreSQL/PostGIS, SQLite/SpatiaLite, Oracle Spatial y Microsoft SQL Server, entre muchas otras.La especificación define 17 tipos de geometrías, de las cuales siete son las más comúnmente utilizadas. Estas últimas se muestran en la figura 13.1.\nFigure 13.1: Tipos de geometrías de Simple Features más usadas. Imagen de Robin Lovelace et al.\n","code":""},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"el-paquete-sf","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.5.3 El paquete sf","text":"El paquete sf (de Simple Features) de R implementa los modelos de datos de las geometrías de tipo vectorial: puntos, líneas, polígonos, sus versiones múltiples y las colecciones de geometrías. Está basado en bibliotecas de sofware ampliamente utilizadas en aplicaciones geoespaciales:Geospatial Data Abstraction Library (GDAL): es una biblioteca para leer y escribir datos geoespaciales en varios formatos raster y vectoriales. Implementa un único modelo abstracto de datos raster y un único modelo abstracto de datos vectoriales, lo que permite programar aplicaciones geoespaciales sin tener que ocuparse de las particularidades de cada formato que se utilice (GeoTIFF, NetCDF, ESRI Shapefile, GeoJSON, etc.). pesar de que GDAL está programada en C/C++, cuenta con una interfaz de programación de aplicaciones (API) para varios lenguajes de programación, incluyendo C, C++, Python y Java. Además, ofrece un conjunto de utilitarios de línea de comandos cuyas distribuciones binarias están disponibles para varios sistemas operativos, incluyendo Windows, macOS y Linux.Geometry Engine, Open Source (GEOS): es una implementación en C++ de la biblioteca JTS Topology Suite (desarrollada en Java) y que implementa un conjunto de operaciones y predicados geoespaciales (ej. unión, intersección, distancia, área).PROJ: es una biblioteca que transforma coordenadas entre diferentes CRS, incluyendo tanto proyecciones cartográficas como transformaciones geodésicas.sf provee acceso, desde un mismo paquete de R, la funcionalidad de estas tres bibliotecas, proporcionando así una interfaz unificada para leer y escribir datos geoespaciales mediante GDAL, realizar operaciones con geometrías mediante GEOS y efectuar transformaciones entre sistemas de coordenadas mediante PROJ.En sf, los conjuntos de datos geoespaciales se almacenan en objetos de una clase también llamada sf, los cuales son data frames que contiene una columna especial para las geometrías. Esta columna se denomina generalmente geom o geometry (aunque pueden tener cualquier otro nombre). El manejo de datos geoespaciales como data frames permite manipularlos con las funciones ya desarrolladas para este tipo de datos y con la misma forma de referenciar las filas (observaciones) y las columnas (variables).","code":""},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"instalación-y-carga-3","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.5.3.1 Instalación y carga","text":"","code":"\n# Instalación de sf\ninstall.packages(\"sf\")\n# Carga de sf\nlibrary(sf)"},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"métodos","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.5.3.2 Métodos","text":"La lista de métodos (.e. funciones) de la clase sf puede obtenerse través de la función methods():Seguidamente, se describen y ejemplifican algunos de los métodos básicos de la clase sf.","code":"\n# Métodos de la clase sf\nmethods(class = \"sf\")\n#>  [1] [                     [[<-                 \n#>  [3] $<-                   aggregate            \n#>  [5] anti_join             arrange              \n#>  [7] as.data.frame         cbind                \n#>  [9] coerce                dbDataType           \n#> [11] dbWriteTable          distinct             \n#> [13] dplyr_reconstruct     filter               \n#> [15] full_join             group_by             \n#> [17] group_split           identify             \n#> [19] initialize            inner_join           \n#> [21] left_join             merge                \n#> [23] mutate                plot                 \n#> [25] print                 rbind                \n#> [27] rename                right_join           \n#> [29] rowwise               sample_frac          \n#> [31] sample_n              select               \n#> [33] semi_join             show                 \n#> [35] slice                 slotsFromS3          \n#> [37] st_agr                st_agr<-             \n#> [39] st_area               st_as_s2             \n#> [41] st_as_sf              st_as_sfc            \n#> [43] st_bbox               st_boundary          \n#> [45] st_buffer             st_cast              \n#> [47] st_centroid           st_collection_extract\n#> [49] st_convex_hull        st_coordinates       \n#> [51] st_crop               st_crs               \n#> [53] st_crs<-              st_difference        \n#> [55] st_drop_geometry      st_filter            \n#> [57] st_geometry           st_geometry<-        \n#> [59] st_inscribed_circle   st_interpolate_aw    \n#> [61] st_intersection       st_intersects        \n#> [63] st_is_valid           st_is                \n#> [65] st_join               st_line_merge        \n#> [67] st_m_range            st_make_valid        \n#> [69] st_nearest_points     st_node              \n#> [71] st_normalize          st_point_on_surface  \n#> [73] st_polygonize         st_precision         \n#> [75] st_reverse            st_sample            \n#> [77] st_segmentize         st_set_precision     \n#> [79] st_shift_longitude    st_simplify          \n#> [81] st_snap               st_sym_difference    \n#> [83] st_transform          st_triangulate       \n#> [85] st_union              st_voronoi           \n#> [87] st_wrap_dateline      st_write             \n#> [89] st_z_range            st_zm                \n#> [91] summarise             transform            \n#> [93] transmute             ungroup              \n#> see '?methods' for accessing help and source code"},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"st_read---lectura-de-datos","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.5.3.2.1 st_read() - lectura de datos","text":"El método st_read() lee datos vectoriales de una fuente en formato geoespacial (ej. shapefiles, archivos GeoJSON, bases de datos geoespaciales) y los recupera en un objeto sf.En el siguiente bloque de código en R, se utiliza el método st_read() para leer un archivo GeoJSON con los polígonos de las provincias de Costa Rica. Este archivo proviene de un geoservicio de tipo Web Feature Service (WFS) publicado por el Instituto Geográfico Nacional (IGN).st_read() también puede crear objetos sf partir de archivos de texto. Esta variante se utiliza principalmente cuando el archivo contiene coordenadas correspondientes geometrías de puntos.En el siguiente bloque de código, se utiliza st_read() para leer un archivo CSV con registros de presencia de felinos de Costa Rica, el cual contiene dos columnas llamadas decimalLongitude y decimalLatitude correspondientes la longitud decimal y latitud decimal en las que fue observado cada felino. Este archivo proviene de una consulta al portal de datos de la Infraestructura Mundial de Información en Biodiversidad (GBIF).Tanto provincias como felinos son objetos de la clase sf (y además de data.frame).Al escribirse el nombre de un objeto sf en la consola de R, se despliega información general sobre este.","code":"\n# Lectura de una capa vectorial (GeoJSON) de provincias de Costa Rica\nprovincias <-\n  st_read(\n    \"datos/ign/delimitacion-territorial-administrativa/provincias.geojson\",\n    quiet = TRUE # para evitar el despliegue de mensajes\n  )\n# Lectura de un archivo CSV con registros de presencia de felinos en Costa Rica\nfelinos <-\n  st_read(\n    \"datos/gbif/felinos.csv\",\n    options = c(\n      \"X_POSSIBLE_NAMES=decimalLongitude\", # columna de longitud decimal\n      \"Y_POSSIBLE_NAMES=decimalLatitude\"   # columna de latitud decimal\n    ),\n    quiet = TRUE\n  )\n# Clase del objeto provincias\nclass(provincias)\n#> [1] \"sf\"         \"data.frame\"\n\n# Clase del objeto felinos\nclass(felinos)\n#> [1] \"sf\"         \"data.frame\"\n# Información general sobre el objeto provincias\nprovincias\n#> Simple feature collection with 7 features and 7 fields\n#> Geometry type: MULTIPOLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: 156152 ymin: 608833.8 xmax: 658879.5 ymax: 1241118\n#> Projected CRS: CR05 / CRTM05\n#>                  gml_id cod_catalo cod_provin  provincia\n#> 1 limiteprovincial_5k.1     160103          6 Puntarenas\n#> 2 limiteprovincial_5k.2     160103          1   San José\n#> 3 limiteprovincial_5k.3     160103          7      Limón\n#> 4 limiteprovincial_5k.4     160103          3    Cartago\n#> 5 limiteprovincial_5k.5     160103          2   Alajuela\n#> 6 limiteprovincial_5k.6     160103          5 Guanacaste\n#> 7 limiteprovincial_5k.7     160103          4    Heredia\n#>                                                                                                                                                                                                                  ori_toponi\n#> 1 En documento de 1720, se menciona la llegada del pirata Chipperton a la zona, en el cual aparece la descripcíon referente a una embarcación pequeña en la Punta de Arena, adoptando con el tiempo el nombre de Puntarenas\n#> 2                                                                                                                                              Se remonta a la creación de la ermita dedicada al Patriarca San José en 1737\n#> 3                                                                                         El origen del nombre de la provincia se remonta a 1852, cuando por primera vez se cita en un documento oficial el puerto de Limón\n#> 4                                         Don Juan Vázques de Coronado escogió el sitio en el valle del Guarco para trasladar a la ciudad de Garcimuños, en 1563, bautizando al nuevo asentamiento con el nombre de Cartago\n#> 5                                                                                                                  Se remonta al paraje llamado La Lajuela que por primera vez se cita en los Protocolos de Cartago de 1657\n#> 6        En alegoria a un frondoso árbol de Guanacaste ubicado en la intersección de los caminos que se dirigían a Nicoya, Bagaces y Rivas, en lo que hoy día es el parque de Liberia. Esta referencia data del siglo XVIII\n#> 7                                        En correspondiencia al Presidente  de la Real Audiencia de Guatemala, Capitán General don Alonso Fernández de Heredia, de la Inmaculada Concepción de Cubujuquí a Villa de Heredia\n#>       area  version                       geometry\n#> 1 11298.51 20201222 MULTIPOLYGON (((159917.7 60...\n#> 2  4969.73 20201222 MULTIPOLYGON (((507877.9 11...\n#> 3  9176.96 20201222 MULTIPOLYGON (((535996.1 11...\n#> 4  3093.23 20201222 MULTIPOLYGON (((520206.6 11...\n#> 5  9772.27 20201222 MULTIPOLYGON (((473981.3 11...\n#> 6 10196.32 20201222 MULTIPOLYGON (((380807.3 11...\n#> 7  2663.46 20201222 MULTIPOLYGON (((482356.4 11..."},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"st_crs-y-st_transform---manejo-de-sistemas-de-coordenadas","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.5.3.2.2 st_crs() y st_transform() - manejo de sistemas de coordenadas","text":"El método st_crs() retorna el CRS de un objeto sf.st_crs() también puede asignar un CRS un objeto sf que lo tiene.El método st_transform() transforma un objeto sf un nuevo CRS.","code":"\n# Despliegue del CRS del objeto provincias\nst_crs(provincias)\n#> Coordinate Reference System:\n#>   User input: CR05 / CRTM05 \n#>   wkt:\n#> PROJCRS[\"CR05 / CRTM05\",\n#>     BASEGEOGCRS[\"CR05\",\n#>         DATUM[\"Costa Rica 2005\",\n#>             ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n#>                 LENGTHUNIT[\"metre\",1]]],\n#>         PRIMEM[\"Greenwich\",0,\n#>             ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>         ID[\"EPSG\",5365]],\n#>     CONVERSION[\"Costa Rica TM 2005\",\n#>         METHOD[\"Transverse Mercator\",\n#>             ID[\"EPSG\",9807]],\n#>         PARAMETER[\"Latitude of natural origin\",0,\n#>             ANGLEUNIT[\"degree\",0.0174532925199433],\n#>             ID[\"EPSG\",8801]],\n#>         PARAMETER[\"Longitude of natural origin\",-84,\n#>             ANGLEUNIT[\"degree\",0.0174532925199433],\n#>             ID[\"EPSG\",8802]],\n#>         PARAMETER[\"Scale factor at natural origin\",0.9999,\n#>             SCALEUNIT[\"unity\",1],\n#>             ID[\"EPSG\",8805]],\n#>         PARAMETER[\"False easting\",500000,\n#>             LENGTHUNIT[\"metre\",1],\n#>             ID[\"EPSG\",8806]],\n#>         PARAMETER[\"False northing\",0,\n#>             LENGTHUNIT[\"metre\",1],\n#>             ID[\"EPSG\",8807]]],\n#>     CS[Cartesian,2],\n#>         AXIS[\"northing (N)\",north,\n#>             ORDER[1],\n#>             LENGTHUNIT[\"metre\",1]],\n#>         AXIS[\"easting (E)\",east,\n#>             ORDER[2],\n#>             LENGTHUNIT[\"metre\",1]],\n#>     USAGE[\n#>         SCOPE[\"Cadastre, engineering survey, topographic mapping (large and medium scale).\"],\n#>         AREA[\"Costa Rica - onshore and offshore east of 86°30'W.\"],\n#>         BBOX[2.21,-86.5,11.77,-81.43]],\n#>     ID[\"EPSG\",5367]]\n\n# Despliegue CRS del objeto felinos\nst_crs(felinos)\n#> Coordinate Reference System: NA\n# Asignación de un CRS al objeto felinos\nst_crs(felinos) <- 4326\n# Transformación del CRS del objeto provincias a WGS84 (EPSG = 4326)\nprovincias <-\n  provincias %>%\n  st_transform(4326)"},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"plot---mapeo","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.5.3.2.3 plot() - mapeo","text":"El método plot() grafica objetos sf en un mapa.Los argumentos reset y add de plot() permiten generar un mapa con varias capas.Para conocer los valores del argumento pch, puede consultar R plot pch symbols.","code":"\n# Mapeo de las geometrías del objeto provincias\nplot(provincias$geometry)\n\n# Mapeo con argumentos adicionales de plot()\nplot(\n  provincias$geometry,\n  extent = st_bbox(c(xmin = -86.0, xmax = -82.3, ymin = 8.0, ymax = 11.3)),\n  main = \"Provincias de Costa Rica\",\n  axes = TRUE,\n  graticule = TRUE\n)\n# Primera capa del mapa\nplot(\n  provincias$geometry,\n  extent = st_bbox(c(xmin = -86.0, xmax = -82.3, ymin = 8.0, ymax = 11.3)),\n  main = \"Registros de presencia de felinos en Costa Rica\",\n  axes = TRUE,\n  graticule = TRUE,\n  reset = FALSE\n)\n\n# Segunda capa\nplot(felinos$geometry,\n     add = TRUE,     \n     pch = 16,\n     col = \"blue\")"},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"st_write---escritura-de-datos","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.5.3.2.4 st_write() - escritura de datos","text":"El método st_write() guarda en el disco un objeto sf en los diferentes formatos vectoriales de GDAL.","code":"\n# Especificación del directorio de trabajo (debe utilizarse una ruta existente)\nsetwd(\"/home/mfvargas\")\n\n# Escritura del objeto provincias en formato GPKG\nprovincias %>%\n  st_write(\"provincias.gpkg\")\n\n# Escritura del objeto felinos en formato KML\nfelinos %>%\n  st_write(\"felinos.kml\")"},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"otros-3","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.5.3.2.5 Otros","text":"","code":"\n# Cantidad de filas de un objeto sf\nnrow(provincias)\n#> [1] 7\n\n# Cantidad de columnas de un objeto sf\nncol(provincias)\n#> [1] 8\n\n# Resumen de la columna de geometría\nsummary(provincias$geometry)\n#>  MULTIPOLYGON     epsg:4326 +proj=long... \n#>             7             0             0"},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"mapeo-de-objetos-sf-con-otros-paquetes","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.5.4 Mapeo de objetos sf con otros paquetes","text":"","code":""},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"leaflet","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.5.4.1 leaflet","text":"El paquete leaflet genera mapas interactivos en lenguaje de marcado de hipertexto (HTML), el lenguaje de marcado utilizado para desarrollar páginas web.","code":""},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"instalación-y-carga-4","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.5.4.1.1 Instalación y carga","text":"","code":"\n# Instalación de leaflet\ninstall.packages(\"leaflet\")\n# Carga de leaflet\nlibrary(leaflet)"},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"ejemplos-1","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.5.4.1.2 Ejemplos","text":"Antes de mostrar la capa de provincias en leaflet, se simplifica para evitar un error que se produce al incluir el mapa en un documento bookdown. Es posible que este paso sea innecesario en otros casos, por lo que podría omitirse.El siguiente bloque de código muestra las capas de provincias (polígonos) y de registros de presencia de felinos (puntos) sobre una capa base de OpenStreetMap (OSM).","code":"\nprovincias <-\n  provincias %>%\n  st_transform(5367) %>%\n  st_simplify(dTolerance = 25) %>%\n  st_transform(4326)\n# Mapa leaflet básico de provincias y registros de presencia de felinos\nleaflet() %>%\n  addTiles() %>% # capa base de OSM\n  addPolygons( # capa de provincias (polígonos)\n    data = provincias,\n    color = \"black\",\n    fillColor = \"transparent\",\n    stroke = TRUE,\n    weight = 1.0,\n  ) %>%  \n  addCircleMarkers( # capa de registros de presencia (puntos)\n    data = felinos,\n    stroke = F,\n    radius = 4,\n    fillColor = 'blue',\n    fillOpacity = 1\n  )"},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"datos-raster","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.6 Datos raster","text":"","code":""},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"el-modelo-raster","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.6.1 El modelo raster","text":"El modelo de datos raster usualmente consiste de un encabezado y de una matriz con celdas (también llamadas pixeles) de un mismo tamaño. El encabezado define el CRS, la extensión y el punto de origen de una capa raster. Por lo general, el origen se ubica en la esquina inferior izquierda o en la esquina superior izquierda de la matriz. La extensión se define mediante el número de filas, el número de columnas y el tamaño (resolución) de la celda.Cada celda tiene una identificación (ID) y almacena un único valor, el cual puede ser numérico o categórico, como se muestra en la figura 13.2.\nFigure 13.2: El modelo raster: () ID de las celdas, (B) valores de las celdas, (C) mapa raster de colores. Imagen de Robin Lovelace et al.\ndiferencia del modelo vectorial, el modelo raster necesita almacenar todas las coordenadas de cada geometría (.e. las esquinas de las celdas), debido que la ubicación de cada celda puede calcularse partir de la información contenida en el encabezado. Esta simplicidad, en conjunto con el álgebra de mapas, permiten que el procesamiento de datos raster sea mucho más eficiente que el procesamiento de datos vectoriales. Por otra parte, el modelo vectorial es mucho más flexible en cuanto las posibilidades de representación de geometrías y almacenamiento de valores, por medio de múltiples elementos de datos.Los mapas raster generalmente almacenan fenómenos continuos como elevación, precipitación, temperatura, densidad de población y datos espectrales. También es posible representar mediante raster datos discretos, tales como tipos de suelo o clases de cobertura de la tierra, como se muestra en la figura 13.3.\nFigure 13.3: Ejemplos de mapas raster continuos y categóricos. Imagen de Robin Lovelace et al.\n","code":""},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"el-paquete-terra","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.6.2 El paquete terra","text":"El paquete terra implementa un conjunto de funciones para la lectura, escritura, manipulación, análisis y modelado de datos raster y vectoriales. Implementa la clase SpatRaster para manejar los objetos raster.","code":""},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"instalación-y-carga-5","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.6.2.1 Instalación y carga","text":"","code":"\n# Instalación de terra\ninstall.packages(\"terra\")\n# Carga de terra\nlibrary(terra)"},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"métodos-1","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.6.2.2 Métodos","text":"La función help() presenta la documentación del paquete terra, incluyendo sus métodos.Seguidamente, se describen y ejemplifican algunos de los métodos básicos para manejo de datos raster del paquete terra.","code":"\n# Ayuda sobre el paquete terra\nhelp(\"terra-package\")"},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"rast---lectura-de-datos","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.6.2.2.1 rast() - lectura de datos","text":"El método rast() lee datos raster.En el siguiente bloque de código en R, se utiliza el método rast()` para leer un archivo GeoTIFF correspondiente la altitud de Costa Rica. Este archivo proviene de WorldClim, un conjunto de capas climáticas disponibles en varias resoluciones espaciales.altitud es un objeto de la clase SpatRaster.Al escribirse el nombre de un objeto SpatRaster en la consola de R, se despliega información general sobre este.","code":"\n# Lectura de una capa raster de altitud\naltitud <-\n  rast(\n    \"datos/worldclim/altitud.tif\"\n  )\n# Clase del objeto altitud\nclass(altitud)\n#> [1] \"SpatRaster\"\n#> attr(,\"package\")\n#> [1] \"terra\"\n# Información general sobre el objeto altitud\naltitud\n#> class       : SpatRaster \n#> dimensions  : 687, 546, 1  (nrow, ncol, nlyr)\n#> resolution  : 0.008333333, 0.008333333  (x, y)\n#> extent      : -87.10189, -82.55189, 5.494651, 11.21965  (xmin, xmax, ymin, ymax)\n#> coord. ref. : lon/lat WGS 84 (EPSG:4326) \n#> source      : altitud.tif \n#> name        : altitud"},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"crs-y-project---manejo-de-sistemas-de-coordenadas","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.6.2.2.2 crs() y project() - manejo de sistemas de coordenadas","text":"El método crs() retorna el CRS de un objeto SpatRaster.crs() también puede asignar un CRS un objeto SpatRaster.El método project() reproyecta un objeto SpatRaster un nuevo CRS.","code":"\n# CRS del objeto altitud\ncrs(altitud)\n#> [1] \"GEOGCRS[\\\"WGS 84\\\",\\n    DATUM[\\\"World Geodetic System 1984\\\",\\n        ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n            LENGTHUNIT[\\\"metre\\\",1]]],\\n    PRIMEM[\\\"Greenwich\\\",0,\\n        ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    CS[ellipsoidal,2],\\n        AXIS[\\\"geodetic latitude (Lat)\\\",north,\\n            ORDER[1],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        AXIS[\\\"geodetic longitude (Lon)\\\",east,\\n            ORDER[2],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    ID[\\\"EPSG\\\",4326]]\"\n# Asignación de un CRS a una copia del objeto altitud\naltitud_crtm05 <- altitud\ncrs(altitud_crtm05) <- \"EPSG:5367\"\n\n# Consulta\ncrs(altitud_crtm05)\n#> [1] \"PROJCRS[\\\"CR05 / CRTM05\\\",\\n    BASEGEOGCRS[\\\"CR05\\\",\\n        DATUM[\\\"Costa Rica 2005\\\",\\n            ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n                LENGTHUNIT[\\\"metre\\\",1]]],\\n        PRIMEM[\\\"Greenwich\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        ID[\\\"EPSG\\\",5365]],\\n    CONVERSION[\\\"Costa Rica TM 2005\\\",\\n        METHOD[\\\"Transverse Mercator\\\",\\n            ID[\\\"EPSG\\\",9807]],\\n        PARAMETER[\\\"Latitude of natural origin\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8801]],\\n        PARAMETER[\\\"Longitude of natural origin\\\",-84,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8802]],\\n        PARAMETER[\\\"Scale factor at natural origin\\\",0.9999,\\n            SCALEUNIT[\\\"unity\\\",1],\\n            ID[\\\"EPSG\\\",8805]],\\n        PARAMETER[\\\"False easting\\\",500000,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8806]],\\n        PARAMETER[\\\"False northing\\\",0,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8807]]],\\n    CS[Cartesian,2],\\n        AXIS[\\\"northing (N)\\\",north,\\n            ORDER[1],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n        AXIS[\\\"easting (E)\\\",east,\\n            ORDER[2],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n    USAGE[\\n        SCOPE[\\\"Cadastre, engineering survey, topographic mapping (large and medium scale).\\\"],\\n        AREA[\\\"Costa Rica - onshore and offshore east of 86°30'W.\\\"],\\n        BBOX[2.21,-86.5,11.77,-81.43]],\\n    ID[\\\"EPSG\\\",5367]]\"\n# Transformación del CRS del objeto altitud\naltitud_utm17N <-\n  altitud %>%\n  project(\"EPSG:8910\")\n\n# Consulta\ncrs(altitud_utm17N)\n#> [1] \"PROJCRS[\\\"CR-SIRGAS / UTM zone 17N\\\",\\n    BASEGEOGCRS[\\\"CR-SIRGAS\\\",\\n        DATUM[\\\"CR-SIRGAS\\\",\\n            ELLIPSOID[\\\"GRS 1980\\\",6378137,298.257222101,\\n                LENGTHUNIT[\\\"metre\\\",1]]],\\n        PRIMEM[\\\"Greenwich\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        ID[\\\"EPSG\\\",8907]],\\n    CONVERSION[\\\"UTM zone 17N\\\",\\n        METHOD[\\\"Transverse Mercator\\\",\\n            ID[\\\"EPSG\\\",9807]],\\n        PARAMETER[\\\"Latitude of natural origin\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8801]],\\n        PARAMETER[\\\"Longitude of natural origin\\\",-81,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8802]],\\n        PARAMETER[\\\"Scale factor at natural origin\\\",0.9996,\\n            SCALEUNIT[\\\"unity\\\",1],\\n            ID[\\\"EPSG\\\",8805]],\\n        PARAMETER[\\\"False easting\\\",500000,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8806]],\\n        PARAMETER[\\\"False northing\\\",0,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8807]]],\\n    CS[Cartesian,2],\\n        AXIS[\\\"(E)\\\",east,\\n            ORDER[1],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n        AXIS[\\\"(N)\\\",north,\\n            ORDER[2],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n    USAGE[\\n        SCOPE[\\\"Oil and gas exploration and production.\\\"],\\n        AREA[\\\"Costa Rica - offshore - Caribbean sea.\\\"],\\n        BBOX[9.6,-83.6,11.77,-81.43]],\\n    ID[\\\"EPSG\\\",8910]]\""},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"plot---mapeo-1","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.6.2.2.3 plot() - mapeo","text":"El método plot() muestra objetos SpatRaster en un mapa.Los argumentos reset y add de plot() permiten generar un mapa con varias capas.","code":"\n# Mapa de la capa de altitud\nplot(altitud)\n# Primera capa del mapa (raster)\nplot(\n  altitud,\n  main = \"Registros de presencia de felinos en Costa Rica\",\n  axes = TRUE,\n  reset = FALSE\n)\n\n# Segunda capa (vectorial)\nplot(felinos$geometry,\n     add = TRUE,     \n     pch = 16,\n     col = \"blue\")"},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"writeraster---escritura-de-datos","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.6.2.2.4 writeRaster() - escritura de datos","text":"La función writeRaster() guarda en el disco un objeto SpatRaster en los diferentes formatos raster de GDAL.","code":"\n# Especificación del directorio de trabajo (debe utilizarse una ruta existente)\nsetwd(\"/home/mfvargas\")\n\n# Escritura del objeto altitud\naltitud %>%\n  writeRaster(\"altitud.asc\")"},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"otros-4","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.6.2.2.5 Otros","text":"","code":"\n# Cantidad de filas de un objeto SpatRaster\nnrow(altitud)\n#> [1] 687\n\n# Cantidad de columnas de un objeto SpatRaster\nncol(altitud)\n#> [1] 546\n\n# Resolución de un objeto SpatRaster\nres(altitud)\n#> [1] 0.008333333 0.008333333"},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"mapeo-de-objetos-spatraster-con-otros-paquetes","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.6.3 Mapeo de objetos SpatRaster con otros paquetes","text":"","code":""},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"leaflet-1","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.6.3.1 leaflet","text":"la fecha de escritura de este documento (2022-06-05), el paquete leaflet cuenta con soporte para objetos de tipo SpatRaster, pero sí para objetos de tipo RasterLayer del paquete raster (antecesor de terra). Por este motivo, se utiliza el método raster() de raster para realizar la conversión de SpatRaster RasterLayer y así mapear el objeto altitud con el método addRasterImage() de leaflet. Para más información sobre el tema de conversiones entre las diferentes clases espaciales de R, puede consultarse Conversions different spatial classes R.Entonces, primero se instala y carga el paquete raster. También debe cargarse e instalarse el paquete rgdal, como complemento de raster.Se muestran en un mapa leaflet las capas de altitud (raster), provincias (polígonos) y registros de presencia de felinos (puntos) sobre una capa base de OpenStreetMap (OSM).","code":"\n# Instalación de raster y rgdal\ninstall.packages(\"raster\")\ninstall.packages(\"rgdal\")\n# Carga de raster y rgdal\nlibrary(raster)\nlibrary(rgdal)\n# Mapa leaflet básico con capas de altitud, provincias y registros de presencia de felinos\nleaflet() %>%\n  addTiles() %>%\n  addRasterImage( # capa raster\n    raster(altitud), # conversión de SpatRaster a RasterLayer \n    opacity = 0.6\n  ) %>%    \n  addPolygons(\n    data = provincias,\n    color = \"black\",\n    fillColor = \"transparent\",\n    stroke = TRUE,\n    weight = 1.0,\n  ) %>%\n  addCircleMarkers(\n    data = felinos,\n    stroke = F,\n    radius = 4,\n    fillColor = 'blue',\n    fillOpacity = 1\n  )"},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"ejercicios-15","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.7 Ejercicios","text":"En un documento R Markdown incluya:Una tabla DT con las columnas del conjunto de datos de felinos de Costa Rica correspondientes especie (species), fecha (eventDate), provincia (stateProvince), localidad (locality), longitud (decimalLongitude) y latitud (decimalLatitude).\nLas columnas deben, si es necesario, convertirse al tipo de datos adecuado (ej. Date).\nLos encabezados de las columnas en la tabla deben desplegarse en español, pero deben alterarse los nombres de las columnas. Sugerencia: utilice el argumento colnames de la función datatable().\nLos controles de la tabla deben estar en español.\nLas columnas deben, si es necesario, convertirse al tipo de datos adecuado (ej. Date).Los encabezados de las columnas en la tabla deben desplegarse en español, pero deben alterarse los nombres de las columnas. Sugerencia: utilice el argumento colnames de la función datatable().Los controles de la tabla deben estar en español.Un gráfico de barras, generado con gglot2 y traducido plotly con ggplotly(), que muestre la cantidad de registros para cada especie de felinos.\nLas barras deben estar ordenadas de mayor menor.\nTodos los controles y etiquetas del gráfico deben estar en español.\nLas barras deben estar ordenadas de mayor menor.Todos los controles y etiquetas del gráfico deben estar en español.Un mapa leaflet con las siguientes capas:\nCapa base de OpenStreetMap (OSM).\nProvincias de Costa Rica (polígonos).\nRegistros de presencia de felinos (puntos).\nCapa base de OpenStreetMap (OSM).Provincias de Costa Rica (polígonos).Registros de presencia de felinos (puntos).Publique el documento como un sitio web en GitHub Pages.","code":""},{"path":"introducción-al-manejo-de-datos-geoespaciales-en-r.html","id":"recursos-de-interés-11","chapter":"13 Introducción al manejo de datos geoespaciales en R","heading":"13.8 Recursos de interés","text":"Bivand, R. (2022). CRAN Task View: Analysis Spatial Data. https://CRAN.R-project.org/view=SpatialR-Ladies Madrid. (2021). R-Ladies Madrid (español)—Analiza datos espaciales—Stephanie Orellana. https://www.youtube.com/watch?v=59tO2ARvVVU","code":""},{"path":"operaciones-con-datos-de-atributos.html","id":"operaciones-con-datos-de-atributos","chapter":"14 Operaciones con datos de atributos","heading":"14 Operaciones con datos de atributos","text":"","code":""},{"path":"operaciones-con-datos-de-atributos.html","id":"resumen-13","chapter":"14 Operaciones con datos de atributos","heading":"14.1 Resumen","text":"Se les llama atributos los elementos de datos espaciales o geométricos de un conjunto de datos geoespaciales. Estos datos pueden ser de tipos numéricos o textuales, entre otros. Un conjunto de datos vectoriales puede tener asociados varios campos de atributos, mientras que un conjunto de datos raster tiene solamente uno.Las operaciones con atributos en datos vectoriales incluyen creación de subconjuntos, agregación y cruce de datos. Estas operaciones pueden ejecutarse con funciones del paquete base de R o con las de paquetes de Tidyverse. Por su parte, las operaciones con atributos en datos raster incluyen creación de subconjuntos y resumen de información.","code":""},{"path":"operaciones-con-datos-de-atributos.html","id":"trabajo-previo-9","chapter":"14 Operaciones con datos de atributos","heading":"14.2 Trabajo previo","text":"","code":""},{"path":"operaciones-con-datos-de-atributos.html","id":"lecturas-7","chapter":"14 Operaciones con datos de atributos","heading":"14.2.1 Lecturas","text":"Lovelace, R., Nowosad, J., & Münchow, J. (2019). Geocomputation R (capítulo 3). CRC Press. https://geocompr.robinlovelace.net/","code":""},{"path":"operaciones-con-datos-de-atributos.html","id":"preparativos-1","chapter":"14 Operaciones con datos de atributos","heading":"14.3 Preparativos","text":"","code":""},{"path":"operaciones-con-datos-de-atributos.html","id":"carga-de-paquetes-1","chapter":"14 Operaciones con datos de atributos","heading":"14.3.1 Carga de paquetes","text":"","code":"\n# Carga de paquetes\n\nlibrary(stringi) # manejo de hileras de texto\nlibrary(readr) # lectura de archivos CSV\nlibrary(readxl) # lectura de archivos XLS\nlibrary(dplyr) # transformación de datos\nlibrary(DT) # tablas interactivas\nlibrary(sf) # manejo de datos vectoriales\nlibrary(terra) # manejo de datos raster\nlibrary(leaflet) # mapas interactivos"},{"path":"operaciones-con-datos-de-atributos.html","id":"conjuntos-de-datos-para-ejemplos-1","chapter":"14 Operaciones con datos de atributos","heading":"14.3.2 Conjuntos de datos para ejemplos","text":"","code":""},{"path":"operaciones-con-datos-de-atributos.html","id":"provincias-de-costa-rica","chapter":"14 Operaciones con datos de atributos","heading":"14.3.2.1 Provincias de Costa Rica","text":"Es un archivo GeoJSON con los polígonos de las provincias de Costa Rica. Este archivo proviene de un geoservicio de tipo Web Feature Service (WFS) publicado por el Instituto Geográfico Nacional (IGN). Se transforma WGS84 para posteriormente desplegarlo más fácilmente en leaflet.","code":"\n# Lectura, transformación y visualización de datos geoespaciales de provincias\n\n# Lectura\nprovincias <-\n  st_read(\n    dsn = \"datos/ign/delimitacion-territorial-administrativa/provincias.geojson\",\n    quiet = TRUE\n  ) %>%\n  st_transform(4326) # transformación a WGS84\n\n# Transformación\nprovincias <-\n  provincias %>%\n  st_transform(5367) %>%\n  st_simplify(dTolerance = 100) %>% # simplificación de geometrías\n  st_transform(4326)\n\n# Visualización en un mapa\nplot(\n  provincias$geometry,\n  extent = st_bbox(c(xmin = -86.0, xmax = -82.3, ymin = 8.0, ymax = 11.3)),\n  main = \"Provincias de Costa Rica\",\n  axes = TRUE,\n  graticule = TRUE\n)"},{"path":"operaciones-con-datos-de-atributos.html","id":"cantones-de-costa-rica","chapter":"14 Operaciones con datos de atributos","heading":"14.3.2.2 Cantones de Costa Rica","text":"Es un archivo GeoJSON con los polígonos de los cantones de Costa Rica. Este archivo proviene de un geoservicio de tipo Web Feature Service (WFS) publicado por el Instituto Geográfico Nacional (IGN). Se transforma WGS84 para posteriormente desplegarlo más fácilmente en leaflet.","code":"\n# Lectura, transformación y visualización de datos geoespaciales de cantones\n\n# Lectura\ncantones <-\n  st_read(\n    dsn = \"datos/ign/delimitacion-territorial-administrativa/cantones.geojson\",\n    quiet = TRUE\n  ) %>%\n  st_transform(4326) # transformación a WGS84\n\n# Transformación\ncantones <-\n  cantones %>%\n  st_transform(5367) %>%\n  st_simplify(dTolerance = 100) %>% # simplificación de geometrías\n  st_transform(4326)\n\n# Visualización en un mapa\nplot(\n  cantones$geometry,\n  extent = st_bbox(c(xmin = -86.0, xmax = -82.3, ymin = 8.0, ymax = 11.3)),\n  main = \"Cantones de Costa Rica\",\n  axes = TRUE,\n  graticule = TRUE\n)"},{"path":"operaciones-con-datos-de-atributos.html","id":"distritos-de-costa-rica","chapter":"14 Operaciones con datos de atributos","heading":"14.3.2.3 Distritos de Costa Rica","text":"Es un archivo GeoJSON con los polígonos de los distritos de Costa Rica. Este archivo proviene de un geoservicio de tipo Web Feature Service (WFS) publicado por el Instituto Geográfico Nacional (IGN). Se transforma WGS84 para posteriormente desplegarlo más fácilmente en leaflet.","code":"\n# Lectura, transformación y visualización de datos geoespaciales de distritos\n\n# Lectura\ndistritos <-\n  st_read(\n    dsn = \"datos/ign/delimitacion-territorial-administrativa/distritos.geojson\",\n    quiet = TRUE\n  ) %>%\n  st_transform(4326) # transformación a WGS84\n\n# Transformación\ndistritos <-\n  distritos %>%\n  st_transform(5367) %>%\n  st_simplify(dTolerance = 100) %>% # simplificación de geometrías\n  st_transform(4326)\n\n# Visualización en un mapa\nplot(\n  distritos$geometry,\n  extent = st_bbox(c(xmin = -86.0, xmax = -82.3, ymin = 8.0, ymax = 11.3)),\n  main = \"Distritos de Costa Rica\",\n  axes = TRUE,\n  graticule = TRUE\n)"},{"path":"operaciones-con-datos-de-atributos.html","id":"casos-positivos-acumulados-de-covid-en-cantones-de-costa-rica","chapter":"14 Operaciones con datos de atributos","heading":"14.3.2.4 Casos positivos acumulados de covid en cantones de Costa Rica","text":"Es un archivo CSV con el acumulado de casos positivos de covid-19 en cada cantón. Es publicado regularmente por el Ministerio de Salud en el sitio web Situación Nacional COVID-19.","code":"\n# Lectura, transformación y visualización de casos positivos acumulados de covid-19 en cantones de Costa Rica\n\n# Lectura\ncovid_positivos <-\n  read_delim(file = \"datos/ministerio-salud/covid/05_30_22_CSV_POSITIVOS.csv\",\n             locale = locale(encoding = \"WINDOWS-1252\"), # para desplegar correctamente acentos y otros caracteres\n             col_select = c(\"cod_canton\", \"canton\", \"30/05/2022\"))\n\n# Transformación\ncovid_positivos <-\n  covid_positivos %>%\n  rename(positivos = '30/05/2022') # renombramiento de columna\n\n# Visualización en una tabla\ncovid_positivos %>%\n  arrange(desc(positivos)) %>%\n  datatable(options = list(\n    pageLength = 10,\n    language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')\n  ))"},{"path":"operaciones-con-datos-de-atributos.html","id":"delitos-ocurridos-en-costa-rica-en-el-año-2021","chapter":"14 Operaciones con datos de atributos","heading":"14.3.2.5 Delitos ocurridos en Costa Rica en el año 2021","text":"Es un archivo XLS con registros de delitos. Es publicado regularmente por el Organismo de Investigación Judicial (OIJ) en el sitio web Datos abiertos del OIJ.","code":"\n# Lectura, transformación y visualización de delitos\n\n# Lectura\ndelitos <-\n  read_xls(path = \"datos/oij/estadisticas-policiales/estadisticaspoliciales2021.xls\")\n\n# Visualización en una tabla\ndelitos %>%\n  select(Delito, Fecha, Victima, Provincia, Canton, Distrito) %>%\n  datatable(options = list(\n    pageLength = 10,\n    language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')\n  ))"},{"path":"operaciones-con-datos-de-atributos.html","id":"introducción-1","chapter":"14 Operaciones con datos de atributos","heading":"14.4 Introducción","text":"Se les llama atributos los elementos de datos espaciales o geométricos de un conjunto de datos geográficos. Estos datos pueden ser de tipos numéricos o textuales, entre otros. Un conjunto de datos vectoriales puede tener asociados varios campos de atributos, mientras que un conjunto de datos raster tiene solamente uno.","code":""},{"path":"operaciones-con-datos-de-atributos.html","id":"datos-vectoriales-1","chapter":"14 Operaciones con datos de atributos","heading":"14.5 Datos vectoriales","text":"Las operaciones con atributos en datos vectoriales incluyen:Creación de subconjuntos (subsetting).Agregación de datos (aggregation).Unión de datos (joining).Seguidamente, se explicará como maneja estas operaciones el paquete sf.","code":""},{"path":"operaciones-con-datos-de-atributos.html","id":"manejo-de-datos-de-atributos-con-el-paquete-sf","chapter":"14 Operaciones con datos de atributos","heading":"14.6 Manejo de datos de atributos con el paquete sf","text":"Como se mencionó en capítulos anteriores, el paquete sf define una clase, llamada sf, la cual extiende la clase data.frame del paquete base de R. Los objetos de la clase sf tienen una fila (o feature) por cada observación y una columna por cada atributo. También tienen una columna especial para almacenar las geometrías (puntos, líneas, polígonos, etc.), la cual generalmente se denomina geometry o geom. Esto permite que sf utilice métodos (.e. funciones) de la clase data.frame, tales como plot() y summary(), entre otros.Además de data.frame, sf es compatible con clases como las del paquete tibble, las cuales pueden manipularse mediante los métodos de dplyr. Esto que permite un manejo tidy (.e. ordenado, organizado) de los datos geoespaciales, de acuerdo con el enfoque de Tidyverse.En la secciones siguientes, se explicará el manejo de datos de atributos tanto mediante funciones y operaciones del paquete base de R, como mediante Tidyverse.","code":""},{"path":"operaciones-con-datos-de-atributos.html","id":"funciones-básicas-para-manejo-de-data-frames-y-objetos-sf","chapter":"14 Operaciones con datos de atributos","heading":"14.6.1 Funciones básicas para manejo de data frames y objetos sf","text":"Las siguientes son algunas de las funciones disponibles para obtener información básica de un objeto sf.La función st_drop_geometry() remueve la columna de geometría de un objeto sf. Puede ser útil cuando, por ejemplo, solo se necesita trabajar con los atributos o cuando la columna con la geometría consume demasiados recursos del computador.Para algunas operaciones, también es posible ocultar la columna de geometría de un conjunto de datos (sin borrarla) mediante el argumento drop = TRUE.","code":"\n# Funciones básicas para manejo de objetos tipo data.frame y sf\n\n# Clase de cantones\nclass(cantones)\n#> [1] \"sf\"         \"data.frame\"\n\n# Dimensiones (cantidad de filas y de columnas)\ndim(cantones)\n#> [1] 82 11\n\n# Cantidad de filas (i.e. observaciones)\nnrow(cantones)\n#> [1] 82\n\n# Cantidad de columnas (i.e. variables)\nncol(cantones)\n#> [1] 11\n\n# Nombres de las columnas\nnames(cantones)\n#>  [1] \"gml_id\"     \"gmlid\"      \"cod_catalo\" \"cod_canton\"\n#>  [5] \"canton\"     \"ori_toponi\" \"area\"       \"cod_provin\"\n#>  [9] \"provincia\"  \"version\"    \"geometry\"\n\n# Estructura del conjunto de datos\nglimpse(cantones)\n#> Rows: 82\n#> Columns: 11\n#> $ gml_id     <chr> \"limitecantonal_5k.1\", \"limitecantonal_…\n#> $ gmlid      <chr> \"limitecantonal_5k.1\", \"limitecantonal_…\n#> $ cod_catalo <chr> \"160104\", \"160104\", \"160104\", \"160104\",…\n#> $ cod_canton <int> 610, 607, 608, 605, 603, 119, 606, 704,…\n#> $ canton     <chr> \"Corredores\", \"Golfito\", \"Coto Brus\", \"…\n#> $ ori_toponi <chr> \"Tiene su origen en el topónimo del río…\n#> $ area       <dbl> 623.61, 1752.75, 944.24, 1932.70, 2382.…\n#> $ cod_provin <int> 6, 6, 6, 6, 6, 1, 6, 7, 6, 1, 1, 6, 1, …\n#> $ provincia  <chr> \"Puntarenas\", \"Puntarenas\", \"Puntarenas…\n#> $ version    <chr> \"20201222\", \"20201222\", \"20201222\", \"20…\n#> $ geometry   <GEOMETRY [°]> POLYGON ((-82.94161 8.42039...…\n# Ejemplos de uso de st_drop_geometry()\n\n# Remoción de la columna de geometría\ncantones_df <- st_drop_geometry(cantones)\n\n# Nombres de las columnas (nótese que ya no está la columna de geometría)\nnames(cantones_df)\n#>  [1] \"gml_id\"     \"gmlid\"      \"cod_catalo\" \"cod_canton\"\n#>  [5] \"canton\"     \"ori_toponi\" \"area\"       \"cod_provin\"\n#>  [9] \"provincia\"  \"version\"\n\n# Clase de df_cantones (nótese como no se muestra ya la clase sf)\nclass(cantones_df)\n#> [1] \"data.frame\"\n\n# Tamaño del conjunto de datos original (tipo sf)\nprint(object.size(cantones), units=\"Kb\")\n#> 402.1 Kb\n\n# Tamaño del conjunto de datos sin geometrías (tipo data.frame)\nprint(object.size(cantones_df), units=\"Kb\")\n#> 42.5 Kb\n# Ejemplos de uso del argumento drop\n\n# Sin drop = TRUE\ncantones[1:10, c(\"canton\", \"area\")]\n#> Simple feature collection with 10 features and 2 fields\n#> Geometry type: GEOMETRY\n#> Dimension:     XY\n#> Bounding box:  xmin: -84.55536 ymin: 8.040247 xmax: -82.55287 ymax: 9.767524\n#> Geodetic CRS:  WGS 84\n#>           canton    area                       geometry\n#> 1     Corredores  623.61 POLYGON ((-82.94161 8.42039...\n#> 2        Golfito 1752.75 MULTIPOLYGON (((-83.32383 8...\n#> 3      Coto Brus  944.24 POLYGON ((-82.90501 8.77424...\n#> 4            Osa 1932.70 POLYGON ((-83.83946 9.25534...\n#> 5   Buenos Aires 2382.94 POLYGON ((-83.32101 9.38409...\n#> 6  Pérez Zeledón 1901.08 POLYGON ((-83.77329 9.59825...\n#> 7         Quepos  557.85 POLYGON ((-84.17009 9.42779...\n#> 8      Talamanca 2792.23 POLYGON ((-82.89452 9.76752...\n#> 9        Parrita  483.22 POLYGON ((-84.30298 9.64968...\n#> 10       Tarrazú  291.27 POLYGON ((-83.98178 9.71801...\n\n# Con drop = TRUE\ncantones[1:10, c(\"canton\", \"area\"), drop = TRUE]\n#>           canton    area\n#> 1     Corredores  623.61\n#> 2        Golfito 1752.75\n#> 3      Coto Brus  944.24\n#> 4            Osa 1932.70\n#> 5   Buenos Aires 2382.94\n#> 6  Pérez Zeledón 1901.08\n#> 7         Quepos  557.85\n#> 8      Talamanca 2792.23\n#> 9        Parrita  483.22\n#> 10       Tarrazú  291.27"},{"path":"operaciones-con-datos-de-atributos.html","id":"creación-de-subconjuntos","chapter":"14 Operaciones con datos de atributos","heading":"14.6.2 Creación de subconjuntos","text":"Frecuentemente, es necesario extrer subconjuntos del conjunto de datos original, para facilidad de manejo y para atender requerimientos específicos de un análisis. En esta sección, se explican las diferentes opciones para creación de subconjuntos, tanto con el paquete base de R como con dplyr. En resumen, estas son las opciones:Con el paquete base:\nLa notación de [] y $\nLa función subset()\nLa notación de [] y $La función subset()Con el paquete dplyr:\nLa función select()\nLa función slice()\nLa función filter()\nLa función select()La función slice()La función filter()","code":""},{"path":"operaciones-con-datos-de-atributos.html","id":"notaciones-y-funciones-del-paquete-base","chapter":"14 Operaciones con datos de atributos","heading":"14.6.2.1 Notaciones y funciones del paquete base","text":"","code":""},{"path":"operaciones-con-datos-de-atributos.html","id":"la-notación-de-y","chapter":"14 Operaciones con datos de atributos","heading":"14.6.2.1.1 La notación de [] y $","text":"La notación de paréntesis cuadrados ([]) y el signo de dólar ($) permite crear subconjuntos con base en la posición de filas y de columnas, por medio de nombres de columnas y través de la especificación de condiciones (.e. expresiones lógicas).Especificación mediante una condición (.e. expresión lógica):","code":"\n# Ejemplos de uso de la notación []\n\n# Subconjunto especificado por posiciones de filas\ncantones[1:10, ]\n\n# Subconjunto especificado por posiciones de columnas\ncantones[, 8:10]\n\n# Subconjunto especificado por nombres de columnas\ncantones[, c(\"canton\", \"area\", \"provincia\")]\n# Ejemplos de uso de la notación $\n\n# Cantones de la provincia de Cartago\ncantones[cantones$provincia == \"Cartago\", c(\"canton\", \"provincia\"), drop = TRUE]\n#>       canton provincia\n#> 19 El Guarco   Cartago\n#> 20   Cartago   Cartago\n#> 22   Paraíso   Cartago\n#> 23   Jiménez   Cartago\n#> 24 Turrialba   Cartago\n#> 26  Oreamuno   Cartago\n#> 29  La Unión   Cartago\n#> 34  Alvarado   Cartago"},{"path":"operaciones-con-datos-de-atributos.html","id":"la-función-subset","chapter":"14 Operaciones con datos de atributos","heading":"14.6.2.1.2 La función subset()","text":"La función subset() también retorna un subconjunto cuyos registros cumplen una condición.Los operadores lógicos y de comparación que pueden utilizarse en las condiciones de la función subset(), y en expresiones lógicas en general, se listan en la siguiente tabla:","code":"\n# Ejemplos de uso de subset()\n\n# Cantones con área >= 2000 km2\nsubset(cantones[, c(\"canton\", \"area\"), drop = TRUE],\n       area >= 2000)\n#>          canton    area\n#> 5  Buenos Aires 2382.94\n#> 8     Talamanca 2792.23\n#> 70       Pococí 2408.76\n#> 71   San Carlos 3352.33\n#> 74    Sarapiquí 2144.38"},{"path":"operaciones-con-datos-de-atributos.html","id":"métodos-del-paquete-dplyr","chapter":"14 Operaciones con datos de atributos","heading":"14.6.2.2 Métodos del paquete dplyr","text":"Las funciones del paquete base de R son confiables y ampliamente usadas. Sin embargo, el enfoque más moderno de dplyr permite flujos de trabajo más intuitivos y es más rápido, debido que se apoya en código escrito en el lenguaje C++. Esto es útil, por ejemplo, cuando se trabaja con conjuntos de datos grandes (big data) y cuando se necesita integración con bases de datos. Los principales métodos de dplyr para creación de subconjuntos son select(), slice() y filter().","code":""},{"path":"operaciones-con-datos-de-atributos.html","id":"el-método-select","chapter":"14 Operaciones con datos de atributos","heading":"14.6.2.2.1 El método select()","text":"dplyr::select() permite seleccionar y renombrar columnas de un conjunto de datos.","code":"\n# Ejemplos de uso de dplyr::select()\n\n# Selección de columnas\ncantones %>%\n  dplyr::select(canton, provincia) # se especifica el nombre del paquete para evitar un conflicto con raster::select\n#> Simple feature collection with 82 features and 2 fields\n#> Geometry type: GEOMETRY\n#> Dimension:     XY\n#> Bounding box:  xmin: -87.09455 ymin: 5.498567 xmax: -82.55287 ymax: 11.21964\n#> Geodetic CRS:  WGS 84\n#> First 10 features:\n#>           canton  provincia                       geometry\n#> 1     Corredores Puntarenas POLYGON ((-82.94161 8.42039...\n#> 2        Golfito Puntarenas MULTIPOLYGON (((-83.32383 8...\n#> 3      Coto Brus Puntarenas POLYGON ((-82.90501 8.77424...\n#> 4            Osa Puntarenas POLYGON ((-83.83946 9.25534...\n#> 5   Buenos Aires Puntarenas POLYGON ((-83.32101 9.38409...\n#> 6  Pérez Zeledón   San José POLYGON ((-83.77329 9.59825...\n#> 7         Quepos Puntarenas POLYGON ((-84.17009 9.42779...\n#> 8      Talamanca      Limón POLYGON ((-82.89452 9.76752...\n#> 9        Parrita Puntarenas POLYGON ((-84.30298 9.64968...\n#> 10       Tarrazú   San José POLYGON ((-83.98178 9.71801...\n\n# Selección y cambio de nombre de columnas\ncantones %>%\n  dplyr::select(canton, area_km2 = area, provincia)\n#> Simple feature collection with 82 features and 3 fields\n#> Geometry type: GEOMETRY\n#> Dimension:     XY\n#> Bounding box:  xmin: -87.09455 ymin: 5.498567 xmax: -82.55287 ymax: 11.21964\n#> Geodetic CRS:  WGS 84\n#> First 10 features:\n#>           canton area_km2  provincia\n#> 1     Corredores   623.61 Puntarenas\n#> 2        Golfito  1752.75 Puntarenas\n#> 3      Coto Brus   944.24 Puntarenas\n#> 4            Osa  1932.70 Puntarenas\n#> 5   Buenos Aires  2382.94 Puntarenas\n#> 6  Pérez Zeledón  1901.08   San José\n#> 7         Quepos   557.85 Puntarenas\n#> 8      Talamanca  2792.23      Limón\n#> 9        Parrita   483.22 Puntarenas\n#> 10       Tarrazú   291.27   San José\n#>                          geometry\n#> 1  POLYGON ((-82.94161 8.42039...\n#> 2  MULTIPOLYGON (((-83.32383 8...\n#> 3  POLYGON ((-82.90501 8.77424...\n#> 4  POLYGON ((-83.83946 9.25534...\n#> 5  POLYGON ((-83.32101 9.38409...\n#> 6  POLYGON ((-83.77329 9.59825...\n#> 7  POLYGON ((-84.17009 9.42779...\n#> 8  POLYGON ((-82.89452 9.76752...\n#> 9  POLYGON ((-84.30298 9.64968...\n#> 10 POLYGON ((-83.98178 9.71801..."},{"path":"operaciones-con-datos-de-atributos.html","id":"el-método-slice","chapter":"14 Operaciones con datos de atributos","heading":"14.6.2.2.2 El método slice()","text":"slice() es el equivalente de select() para filas. Crea un subconjunto con base en las posiciones de las filas.","code":"\n# Ejemplos de uso de slice()\n\n# Subconjunto especificado mediante un rango de filas\ncantones %>%\n  slice(1:10)"},{"path":"operaciones-con-datos-de-atributos.html","id":"el-método-filter","chapter":"14 Operaciones con datos de atributos","heading":"14.6.2.2.3 El método filter()","text":"filter() es el equivalente en dplyr de la función subset() del paquete base. Retorna los registros que cumplen con una condición.","code":"\n# Androides de \"La Guerra de las Galaxias\"\nstarwars %>%\n  filter(species == \"Droid\")\n#> # A tibble: 6 × 14\n#>   name   height  mass hair_color skin_color  eye_color\n#>   <chr>   <int> <dbl> <chr>      <chr>       <chr>    \n#> 1 C-3PO     167    75 <NA>       gold        yellow   \n#> 2 R2-D2      96    32 <NA>       white, blue red      \n#> 3 R5-D4      97    32 <NA>       white, red  red      \n#> 4 IG-88     200   140 none       metal       red      \n#> 5 R4-P17     96    NA none       silver, red red, blue\n#> 6 BB8        NA    NA none       none        black    \n#> # … with 8 more variables: birth_year <dbl>, sex <chr>,\n#> #   gender <chr>, homeworld <chr>, species <chr>,\n#> #   films <list>, vehicles <list>, starships <list>"},{"path":"operaciones-con-datos-de-atributos.html","id":"el-operador-pipe","chapter":"14 Operaciones con datos de atributos","heading":"14.6.2.2.4 El operador pipe (%>%)","text":"Los métodos del paquete dplyr (y otros) suelen ser utilizados conjuntamente con el operador pipe (%>%), el cual posibilita el “encadenamiento” (chaining) de funciones: la salida de la función previa se convierte en el primer argumento de la siguiente función. En el siguiente ejemplo, el conjunto de datos starwars se pasa como entrada al método filter(), para filtrar los personajes humanos. Seguidamente, el resultado se pasa select(), para seleccionar las columnas name, homeworld y species. Finalmente, slice() reduce el resultado las 10 primeras filas.Una alternativa al uso de pipes es el “anidamiento” (nesting) de las funciones:Ejercicio: mediante las funciones select() y filter() de dplyr, cree un nuevo objeto sf que contenga los cantones de Puntarenas y Guanacaste con área mayor o igual 2000 km2. Incluya las columnas de provincia, cantón y área.","code":"\n# Encadenamiento de funciones mediante pipes (%>%)\n\nstarwars %>%\n  filter(species == \"Human\") %>%\n  dplyr::select(name, homeworld, species) %>%\n  slice(1:10)\n#> # A tibble: 10 × 3\n#>    name               homeworld species\n#>    <chr>              <chr>     <chr>  \n#>  1 Luke Skywalker     Tatooine  Human  \n#>  2 Darth Vader        Tatooine  Human  \n#>  3 Leia Organa        Alderaan  Human  \n#>  4 Owen Lars          Tatooine  Human  \n#>  5 Beru Whitesun lars Tatooine  Human  \n#>  6 Biggs Darklighter  Tatooine  Human  \n#>  7 Obi-Wan Kenobi     Stewjon   Human  \n#>  8 Anakin Skywalker   Tatooine  Human  \n#>  9 Wilhuff Tarkin     Eriadu    Human  \n#> 10 Han Solo           Corellia  Human\n# Anidamiento de funciones\nslice(\n  dplyr::select(\n    filter(\n      starwars,\n      species==\"Human\"\n    ),\n    name, homeworld, species\n  ),\n  1:10\n)\n#> # A tibble: 10 × 3\n#>    name               homeworld species\n#>    <chr>              <chr>     <chr>  \n#>  1 Luke Skywalker     Tatooine  Human  \n#>  2 Darth Vader        Tatooine  Human  \n#>  3 Leia Organa        Alderaan  Human  \n#>  4 Owen Lars          Tatooine  Human  \n#>  5 Beru Whitesun lars Tatooine  Human  \n#>  6 Biggs Darklighter  Tatooine  Human  \n#>  7 Obi-Wan Kenobi     Stewjon   Human  \n#>  8 Anakin Skywalker   Tatooine  Human  \n#>  9 Wilhuff Tarkin     Eriadu    Human  \n#> 10 Han Solo           Corellia  Human"},{"path":"operaciones-con-datos-de-atributos.html","id":"agregación-de-datos","chapter":"14 Operaciones con datos de atributos","heading":"14.6.3 Agregación de datos","text":"Las operaciones de agregación realizan cálculos (suma, promedio, etc.) partir de la agrupación de valores de variables. En esta sección, se explican funciones de agregación contenidas en los paquetes stats, sf y dplyr, las cuales son:Del paquete stats:\nLa función aggregate()\nLa función aggregate()Del paquete sf:\nEl método aggregate()\nEl método aggregate()Del paquete dplyr:\nEl método summarize()\nEl método summarize()","code":""},{"path":"operaciones-con-datos-de-atributos.html","id":"la-función-aggregate-de-stats","chapter":"14 Operaciones con datos de atributos","heading":"14.6.3.1 La función aggregate() de stats","text":"La función aggregate() del paquete stats aplica una función de agregación (ej. suma, promedio, mínimo, máximo) sobre una columna. El resultado es un objeto de tipo data.frame.","code":"\n# Ejemplos de uso de stats::agregate()\n\n# Suma de áreas de cantones por provincia\naggregate(\n  data = cantones, \n  area ~ provincia, \n  FUN = sum, \n  na.rm = TRUE\n)\n#>    provincia     area\n#> 1   Alajuela  9772.26\n#> 2    Cartago  3093.23\n#> 3 Guanacaste 10196.30\n#> 4    Heredia  2663.45\n#> 5      Limón  9176.97\n#> 6 Puntarenas 11298.51\n#> 7   San José  4969.73"},{"path":"operaciones-con-datos-de-atributos.html","id":"el-método-aggregate-de-sf","chapter":"14 Operaciones con datos de atributos","heading":"14.6.3.2 El método aggregate() de sf","text":"aggregate() es una función genérica, lo que significa que puede comportarse de manera diferente, dependiendo de los valores de entrada. El paquete sf también provee una versión de aggregate(), la cual se activa cuando recibe un objeto sf`` y se usa el argumentoby. El resultado es un objeto de tiposf`.","code":"\n# Ejemplos de uso de sf::agregate()\n\n# Suma de áreas de cantones por provincia\naggregate(\n  cantones[\"area\"], \n  by = list(cantones$provincia), \n  FUN = sum, \n  na.rm = TRUE\n)\n#> Simple feature collection with 7 features and 2 fields\n#> Attribute-geometry relationship: 0 constant, 1 aggregate, 1 identity\n#> Geometry type: GEOMETRY\n#> Dimension:     XY\n#> Bounding box:  xmin: -87.09455 ymin: 5.498567 xmax: -82.55287 ymax: 11.21964\n#> Geodetic CRS:  WGS 84\n#>      Group.1     area                       geometry\n#> 1   Alajuela  9772.26 POLYGON ((-84.46238 9.92400...\n#> 2    Cartago  3093.23 POLYGON ((-83.81609 10.0836...\n#> 3 Guanacaste 10196.30 MULTIPOLYGON (((-85.45258 9...\n#> 4    Heredia  2663.45 POLYGON ((-84.10945 9.96124...\n#> 5      Limón  9176.97 POLYGON ((-82.85462 9.74693...\n#> 6 Puntarenas 11298.51 MULTIPOLYGON (((-87.03717 5...\n#> 7   San José  4969.73 POLYGON ((-84.15748 9.62847..."},{"path":"operaciones-con-datos-de-atributos.html","id":"el-método-summarise-de-dplyr","chapter":"14 Operaciones con datos de atributos","heading":"14.6.3.3 El método summarise() de dplyr","text":"summarise() es el equivalente de aggregate() en el paquete dplyr. Suele utilizarse conjuntamente con group_by(), que especifica la variable agrupar.summarize() permite renombrar las variables, como se muestra seguidamente.El siguiente ejemplo utiliza otras funciones del paquete dplyr para encontrar las tres provincias más grandes y sus respectivas áreas, con base en los datos disponibles en la capa de cantones.Ejercicio: mediante summarize(), y otras funciones de dplyr, despliegue el área y la cantidad de cantones de las dos provincias más pequeñas.","code":"\n# Ejemplos de uso de de summarise()\n\n# Suma de áreas de cantones por provincia\ncantones %>%\n  group_by(provincia) %>%\n  summarise(area_km2 = sum(area, na.rm = TRUE))\n#> Simple feature collection with 7 features and 2 fields\n#> Geometry type: GEOMETRY\n#> Dimension:     XY\n#> Bounding box:  xmin: -87.09455 ymin: 5.498567 xmax: -82.55287 ymax: 11.21964\n#> Geodetic CRS:  WGS 84\n#> # A tibble: 7 × 3\n#>   provincia  area_km2                               geometry\n#>   <chr>         <dbl>                         <GEOMETRY [°]>\n#> 1 Alajuela      9772. POLYGON ((-85.2428 11.06558, -85.2432…\n#> 2 Cartago       3093. POLYGON ((-83.99753 9.876007, -83.999…\n#> 3 Guanacaste   10196. MULTIPOLYGON (((-85.08991 10.16697, -…\n#> 4 Heredia       2663. POLYGON ((-84.16108 10.29794, -84.161…\n#> 5 Limón         9177. POLYGON ((-83.6764 10.90648, -83.6762…\n#> 6 Puntarenas   11299. MULTIPOLYGON (((-85.1659 10.01118, -8…\n#> 7 San José      4970. POLYGON ((-83.93287 10.18958, -83.934…\n# Ejemplo de renombramiento de variables con summarise()\n\n# Suma total de las áreas de cantones\ncantones %>%\n  summarize(area_km2 = sum(area, na.rm = TRUE),\n            cantidad_cantones = n())\n#> Simple feature collection with 1 feature and 2 fields\n#> Geometry type: MULTIPOLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: -87.09455 ymin: 5.498567 xmax: -82.55287 ymax: 11.21964\n#> Geodetic CRS:  WGS 84\n#>   area_km2 cantidad_cantones                       geometry\n#> 1 51170.45                82 MULTIPOLYGON (((-84.8775 9....\n# Área y cantidad de cantones de las tres provincias más grandes\ncantones %>%\n  st_drop_geometry() %>%  \n  dplyr::select(area, provincia) %>%\n  group_by(provincia) %>%\n  summarise(area = sum(area, na.rm = TRUE),\n            cantidad_cantones = n()) %>%\n  arrange(desc(area)) %>%\n  top_n(n = 3, wt = area)\n#> # A tibble: 3 × 3\n#>   provincia    area cantidad_cantones\n#>   <chr>       <dbl>             <int>\n#> 1 Puntarenas 11299.                11\n#> 2 Guanacaste 10196.                11\n#> 3 Alajuela    9772.                16"},{"path":"operaciones-con-datos-de-atributos.html","id":"unión-de-datos","chapter":"14 Operaciones con datos de atributos","heading":"14.6.4 Unión de datos","text":"La combinación de datos ubicados en diferentes fuentes es una tarea común en análisis de información. Este tipo de operaciones se realizan con base en atributos que son comunes en los conjuntos de datos que se desea “unir” (join). El paquete dplyr proporciona varios métodos para realizar uniones de datos, entre los que se encuentran:left_join(): mantiene todas las filas del conjunto de datos del lado izquierdo y les agrega las columnas del conjunto de datos del lado derecho, en las filas en las que hay coincidencia.inner_join(): incluye las filas que coinciden en ambos conjuntos de datos.right_join(): mantiene todas las filas del conjunto de datos del lado derecho y agrega las columnas del conjunto de datos del lado izquierdo, en las filas en las que hay coincidencia.full_join(): incluye todas las filas de ambos conjuntos de datos.Todos los tipos de joins requieren de una o varias columnas que sean comunes ambos conjuntos de datos, llamadas join keys, en inglés. Esas columnas se especifican con el argumento . Por ejemplo, = codigo, si la columna común se llama codigo en ambos conjuntos de datos. Si tienen diferentes nombres, se utiliza un vector (ej. = c(\"codigo_1\" = \"codigo_2\"), en donde codigo_1 es el nombre de la columna en el conjunto de datos de la izquierda y codigo_2 en el de la derecha. Si hay columnas con nombres iguales en ambos conjuntos de datos, utiliza esos nombres por defecto.","code":""},{"path":"operaciones-con-datos-de-atributos.html","id":"ejemplos-2","chapter":"14 Operaciones con datos de atributos","heading":"14.6.4.1 Ejemplos","text":"","code":""},{"path":"operaciones-con-datos-de-atributos.html","id":"casos-positivos-acumulados-de-covid-en-cantones","chapter":"14 Operaciones con datos de atributos","heading":"14.6.4.1.1 Casos positivos acumulados de covid en cantones","text":"En este caso, se unen los datos geoespaciales de cantones con los datos de casos positivos acumulados de covid-19 en los cantones de Costa Rica. La columna común (join key) se llama cod_canton en ambos conjuntos de datos y contiene el código de cantón asignado por el IGN.Con el data frame resultante del join, se generan mapas de coropletas que muestran la cantidad de casos positivos de covid en los cantones. Para estos mapas, se crea un paleta de colores.El resultado se muestra en un mapa generado con plot().Y en un mapa generado con leaflet().","code":"\n# Unión de los datos geoespaciales de cantones con los de casos positivos de covid. \n# Ambas tablas comparten la columna \"cod_canton\".\ncantones_covid_positivos <-\n  cantones %>%\n  left_join(\n    dplyr::select(covid_positivos, cod_canton, positivos), # el select() es para no llevar columnas innecesarias a la unión\n    by = \"cod_canton\", # campo común para realizar la unión\n    copy = FALSE, # para no copiar todos los campos del data frame derecho en el data frame izquierdo\n    keep = FALSE # # para no copiar el campo de unión\n  )\n# Paleta de colores para los mapas\ncolores_cantones_covid_positivos <-\n  colorNumeric(palette = \"Reds\",\n               domain = cantones_covid_positivos$positivos,\n               na.color = \"transparent\")\n# Visualización en un mapa generado con plot()\nplot(\n  cantones_covid_positivos[\"positivos\"],\n  extent = st_bbox(c(xmin = -86.0, xmax = -82.3, ymin = 8.0, ymax = 11.3)),\n  col = colores_cantones_covid_positivos(cantones_covid_positivos$positivos),\n  main = \"Casos positivos acumulados de covid en cantones de Costa Rica\",\n  axes = TRUE,\n  graticule = TRUE\n)\n# Visualización en un mapa generado con leaflet()\nleaflet() %>%\n  setView(# centro y nivel inicial de acercamiento\n    lng = -84.19452,\n    lat = 9.572735,\n    zoom = 7) %>%\n  addTiles(group = \"OpenStreetMap\") %>% # capa base\n  addPolygons(\n    # capa de polígonos\n    data = cantones_covid_positivos,\n    fillColor = ~ colores_cantones_covid_positivos(cantones_covid_positivos$positivos),\n    fillOpacity = 0.8,\n    color = \"black\",\n    stroke = TRUE,\n    weight = 1.0,\n    popup = paste(\n      # ventana emergente\n      paste(\n        \"<strong>Cantón:<\/strong>\",\n        cantones_covid_positivos$canton\n      ),\n      paste(\n        \"<strong>Casos:<\/strong>\",\n        cantones_covid_positivos$positivos\n      ),\n      sep = '<br/>'\n    ),\n    group = \"Casos positivos acumulados de covid en cantones\"\n  ) %>%\n  addLayersControl(\n    # control de capas\n    baseGroups = c(\"OpenStreetMap\"),\n    overlayGroups = c(\"Casos positivos acumulados de covid en cantones\")\n  ) %>%\n  addLegend(\n    # leyenda\n    position = \"bottomleft\",\n    pal = colores_cantones_covid_positivos,\n    values = cantones_covid_positivos$positivos,\n    group = \"Casos positivos acumulados de covid en cantones\",\n    title = \"Cantidad de casos\"\n  )"},{"path":"operaciones-con-datos-de-atributos.html","id":"delitos","chapter":"14 Operaciones con datos de atributos","heading":"14.6.4.1.2 Delitos","text":"En este ejemplo, se unen los datos geoespaciales de provincias, cantones y distritos con los datos de delitos ocurridos en Costa Rica en el año 2021. El data frame de delitos tiene columnas correspondientes al nombre de la provincia, cantón y distrito en donde ocurrió cada uno. Sin embargo, por exactitud y eficiencia, se prefieren los códigos del IGN los nombres, por lo que se incluyen través de uniones con los conjuntos de datos de provincias, cantones y distritos.","code":""},{},{},{},{"path":"operaciones-con-datos-de-atributos.html","id":"datos-raster-1","chapter":"14 Operaciones con datos de atributos","heading":"14.7 Datos raster","text":"Las operaciones con atributos en datos raster incluyen:Creación de subconjuntos (subsetting).Resumen de información (summarizing).Seguidamente, se explicará como maneja estas operaciones el paquete terra.","code":""},{"path":"operaciones-con-datos-de-atributos.html","id":"manejo-de-datos-de-atributos-con-el-paquete-terra","chapter":"14 Operaciones con datos de atributos","heading":"14.8 Manejo de datos de atributos con el paquete terra","text":"","code":""},{"path":"operaciones-con-datos-de-atributos.html","id":"funciones-básicas-para-manejo-de-objetos-spatraster","chapter":"14 Operaciones con datos de atributos","heading":"14.8.1 Funciones básicas para manejo de objetos SpatRaster","text":"El siguiente bloque de código crea y mapea un objeto SpatRaster llamado elevacion.Los objetos SpatRaster también pueden contener valores categóricos de tipo logical o factor. El siguiente bloque de código crea y mapea un objeto SpatRaster con información sobre tipos de granos (.e. partículas) de una porción de suelo.Ambos objetos pueden guardados en el disco con la función writeRaster().La función levels() puede utilizarse para consultar la Raster Attribute Table (RAT) de un objeto SpatRaster, la cual contiene información sobre sus factores y niveles. También puede emplearse para asignar nuevos factores un objeto.Los raster categóricos también pueden almacenar información relacionada con los colores de cada valor, mediante una tabla. La tabla de colores es un data frame con tres (red, green, blue) o cuatro (alpha) columnas, en la que cada fila corresponde un valor. Las tablas de colores en terra pueden consultarse o modificarse con la función coltab().","code":"\n# Creación de un objeto SpatRaster\nelevacion <- rast(\n  nrows = 6,\n  ncols = 6,\n  resolution = 0.5,\n  xmin = -1.5,\n  xmax = 1.5,\n  ymin = -1.5,\n  ymax = 1.5,\n  vals = 1:36\n)\n\n# Mapeo\nplot(elevacion)\n# Tipos de granos\ngrano_tipo <- c(\"arcilla\", \"limo\", \"arena\")\n\n# Lista de granos generada aleatoriamente\nlista_granos <- sample(grano_tipo, 36, replace = TRUE)\nlista_granos\n#>  [1] \"arcilla\" \"limo\"    \"limo\"    \"limo\"    \"arena\"  \n#>  [6] \"arena\"   \"arcilla\" \"arena\"   \"arcilla\" \"arena\"  \n#> [11] \"arena\"   \"arena\"   \"arcilla\" \"arcilla\" \"arcilla\"\n#> [16] \"arena\"   \"limo\"    \"limo\"    \"arena\"   \"arcilla\"\n#> [21] \"arcilla\" \"limo\"    \"arena\"   \"limo\"    \"arena\"  \n#> [26] \"arena\"   \"limo\"    \"arena\"   \"arcilla\" \"limo\"   \n#> [31] \"limo\"    \"limo\"    \"limo\"    \"arena\"   \"limo\"   \n#> [36] \"arcilla\"\n\n# Factor de tipos de granos\ngrano_factor <- factor(lista_granos, levels = grano_tipo)\n\n# Objeto SpatRaster de tipos de granos\ngrano <- rast(\n  nrows = 6,\n  ncols = 6,\n  resolution = 0.5,\n  xmin = -1.5,\n  xmax = 1.5,\n  ymin = -1.5,\n  ymax = 1.5,\n  vals = grano_factor\n)\n\n# Mapeo\nplot(grano)\n# Especificación del directorio de trabajo (debe ser una ruta existente)\nsetwd(\"/home/mfvargas\")\n\n# Escritura de los objetos raster\nwriteRaster(elevacion, \"elevacion.asc\")\nwriteRaster(grano, \"grano.asc\")\n# Consulta de la RAT\nlevels(grano)\n#> [[1]]\n#> [1] \"arcilla\" \"limo\"    \"arena\"\n\n# Nuevo factor\nlevels(grano) = data.frame(value = c(0, 1, 2), wetness = c(\"mojado\", \"húmedo\", \"seco\"))\n\n# Consulta de la RAT\nlevels(grano)\n#> [[1]]\n#> [1] \"mojado\" \"húmedo\" \"seco\""},{"path":"operaciones-con-datos-de-atributos.html","id":"creación-de-subconjuntos-1","chapter":"14 Operaciones con datos de atributos","heading":"14.8.2 Creación de subconjuntos","text":"Los subconjuntos se crean en objetos SpatRaster con el operador [, el cual acepta varios tipos de entradas.Índices de filas y columnas.ID de celdas.Coordenadas.Otros objetos espaciales.En este capítulo, solo se tratarán las dos primeras opciones. Las restantes se cubrirán en las secciones sobre operaciones espaciales.Las dos primeras opciones se ilustran en el siguiente bloque de código, en el que se consulta la celda (también llamada pixel) ubicada en la esquina superior izquierda del objeto de elevación.La totalidad de los valores de un objeto SpatRaster puede consultarse con las función values().El operador [ también puede utilizarse para modificar los valores de las celdas un objeto SpatRaster.","code":"\n# Celda en la fila 1, columna 1\nelevacion[1, 1]\n#>   lyr.1\n#> 1     1\nelevacion[]\n#>       lyr.1\n#>  [1,]     1\n#>  [2,]     2\n#>  [3,]     3\n#>  [4,]     4\n#>  [5,]     5\n#>  [6,]     6\n#>  [7,]     7\n#>  [8,]     8\n#>  [9,]     9\n#> [10,]    10\n#> [11,]    11\n#> [12,]    12\n#> [13,]    13\n#> [14,]    14\n#> [15,]    15\n#> [16,]    16\n#> [17,]    17\n#> [18,]    18\n#> [19,]    19\n#> [20,]    20\n#> [21,]    21\n#> [22,]    22\n#> [23,]    23\n#> [24,]    24\n#> [25,]    25\n#> [26,]    26\n#> [27,]    27\n#> [28,]    28\n#> [29,]    29\n#> [30,]    30\n#> [31,]    31\n#> [32,]    32\n#> [33,]    33\n#> [34,]    34\n#> [35,]    35\n#> [36,]    36\n\n# Celda con ID = 1\nelevacion[1]\n#>   lyr.1\n#> 1     1\n# Valores de un objeto raster\nvalues(elevacion)\n#>       lyr.1\n#>  [1,]     1\n#>  [2,]     2\n#>  [3,]     3\n#>  [4,]     4\n#>  [5,]     5\n#>  [6,]     6\n#>  [7,]     7\n#>  [8,]     8\n#>  [9,]     9\n#> [10,]    10\n#> [11,]    11\n#> [12,]    12\n#> [13,]    13\n#> [14,]    14\n#> [15,]    15\n#> [16,]    16\n#> [17,]    17\n#> [18,]    18\n#> [19,]    19\n#> [20,]    20\n#> [21,]    21\n#> [22,]    22\n#> [23,]    23\n#> [24,]    24\n#> [25,]    25\n#> [26,]    26\n#> [27,]    27\n#> [28,]    28\n#> [29,]    29\n#> [30,]    30\n#> [31,]    31\n#> [32,]    32\n#> [33,]    33\n#> [34,]    34\n#> [35,]    35\n#> [36,]    36\n# Modificación de una celda\nelevacion[1, 1] = 0\n\n# Consulta de todos los valores del raster (equivalente a values())\nelevacion[]\n#>       lyr.1\n#>  [1,]     0\n#>  [2,]     2\n#>  [3,]     3\n#>  [4,]     4\n#>  [5,]     5\n#>  [6,]     6\n#>  [7,]     7\n#>  [8,]     8\n#>  [9,]     9\n#> [10,]    10\n#> [11,]    11\n#> [12,]    12\n#> [13,]    13\n#> [14,]    14\n#> [15,]    15\n#> [16,]    16\n#> [17,]    17\n#> [18,]    18\n#> [19,]    19\n#> [20,]    20\n#> [21,]    21\n#> [22,]    22\n#> [23,]    23\n#> [24,]    24\n#> [25,]    25\n#> [26,]    26\n#> [27,]    27\n#> [28,]    28\n#> [29,]    29\n#> [30,]    30\n#> [31,]    31\n#> [32,]    32\n#> [33,]    33\n#> [34,]    34\n#> [35,]    35\n#> [36,]    36\n\n# Modificación de rangos de celdas\nelevacion[1, c(1, 2)] = 0\n\nelevacion[1, 1:6] = 0\nelevacion[2, 1:6] = 10\nelevacion[3, 1:6] = 15\nelevacion[4, 1:6] = 15\nelevacion[5, 1:6] = 20\nelevacion[6, 1:6] = 35\n\n# Consulta de los valores\nelevacion[]\n#>       lyr.1\n#>  [1,]     0\n#>  [2,]     0\n#>  [3,]     0\n#>  [4,]     0\n#>  [5,]     0\n#>  [6,]     0\n#>  [7,]    10\n#>  [8,]    10\n#>  [9,]    10\n#> [10,]    10\n#> [11,]    10\n#> [12,]    10\n#> [13,]    15\n#> [14,]    15\n#> [15,]    15\n#> [16,]    15\n#> [17,]    15\n#> [18,]    15\n#> [19,]    15\n#> [20,]    15\n#> [21,]    15\n#> [22,]    15\n#> [23,]    15\n#> [24,]    15\n#> [25,]    20\n#> [26,]    20\n#> [27,]    20\n#> [28,]    20\n#> [29,]    20\n#> [30,]    20\n#> [31,]    35\n#> [32,]    35\n#> [33,]    35\n#> [34,]    35\n#> [35,]    35\n#> [36,]    35"},{"path":"operaciones-con-datos-de-atributos.html","id":"resumen-y-sumarización-de-información","chapter":"14 Operaciones con datos de atributos","heading":"14.8.3 Resumen y sumarización de información","text":"La escritura del nombre de un objeto SpatRaster en la consola imprime información general sobre ese objeto. La función summary() proporciona algunas estadísticas descriptivas (mínimo, máximo, cuartiles, etc.). Otras estadísticas pueden ser calculadas con la función global().Adicionalmente, la función freq() retorna la tabla de frecuencias de valores categóricos.Las estadísticas pueden ser visualizadas con funciones como hist() y density().","code":"\n# Información general\nelevacion\n#> class       : SpatRaster \n#> dimensions  : 6, 6, 1  (nrow, ncol, nlyr)\n#> resolution  : 0.5, 0.5  (x, y)\n#> extent      : -1.5, 1.5, -1.5, 1.5  (xmin, xmax, ymin, ymax)\n#> coord. ref. : lon/lat WGS 84 \n#> source      : memory \n#> name        : lyr.1 \n#> min value   :     0 \n#> max value   :    35\n\n# Resumen de un raster de una capa\nsummary(elevacion)\n#>      lyr.1      \n#>  Min.   : 0.00  \n#>  1st Qu.:10.00  \n#>  Median :15.00  \n#>  Mean   :15.83  \n#>  3rd Qu.:20.00  \n#>  Max.   :35.00\n\n# Desviación estándar\nglobal(elevacion, sd)\n#>             sd\n#> lyr.1 10.72381\n# Tabla de frecuencias\nfreq(grano)\n#>   layer  value count\n#> 1     1 mojado    10\n#> 2     1 húmedo    13\n#> 3     1   seco    13\n# Histograma\nhist(elevacion)\n\n# Densidad\ndensity(elevacion)"},{"path":"operaciones-con-datos-espaciales.html","id":"operaciones-con-datos-espaciales","chapter":"15 Operaciones con datos espaciales","heading":"15 Operaciones con datos espaciales","text":"","code":""},{"path":"operaciones-con-datos-espaciales.html","id":"resumen-14","chapter":"15 Operaciones con datos espaciales","heading":"15.1 Resumen","text":"Las operaciones espaciales para datos vectoriales incluyen creación de subconjuntos espaciales, unión de datos espaciales, agregación de datos espaciales y relaciones de distancia, entre otras. Por su parte, las operaciones espaciales para datos raster incluyen creación de subconjuntos espaciales y álgebra de mapas, entre otras.","code":""},{"path":"operaciones-con-datos-espaciales.html","id":"trabajo-previo-10","chapter":"15 Operaciones con datos espaciales","heading":"15.2 Trabajo previo","text":"","code":""},{"path":"operaciones-con-datos-espaciales.html","id":"lecturas-8","chapter":"15 Operaciones con datos espaciales","heading":"15.2.1 Lecturas","text":"Lovelace, R., Nowosad, J., & Münchow, J. (2019). Geocomputation R (capítulo 4). CRC Press. https://geocompr.robinlovelace.net/","code":""},{"path":"operaciones-con-datos-espaciales.html","id":"preparativos-2","chapter":"15 Operaciones con datos espaciales","heading":"15.3 Preparativos","text":"","code":""},{"path":"operaciones-con-datos-espaciales.html","id":"carga-de-paquetes-2","chapter":"15 Operaciones con datos espaciales","heading":"15.3.1 Carga de paquetes","text":"Datos de ejemplo de Lovelace et al.:También se utiliza el paquete raster y con sus métodos:raster::raster(): para convertir objetos SpatRaster RasterLayer y así poder desplegarlos con leaflet::addRasterImage(), que solo acepta objetos RasterLayer.raster::aggregate(): para reducir el tamaño de objetos RasterLayer y así poder desplegarlos con leaflet::addRasterImage(), que despliega objetos muy grandes.raster se carga en este capítulo con la función library(). Sus métodos se llaman con la notación paquete::metodo(). raster requiere la instalación del paquete rgdal.","code":"\n# Carga de paquetes\n\nlibrary(dplyr) # transformación de datos\nlibrary(sf) # manejo de datos vectoriales\nlibrary(terra) # manejo de datos raster\nlibrary(DT) # tablas interactivas\nlibrary(leaflet) # mapas interactivos\nlibrary(leaflet.extras) # funciones adicionales de leaflet\nlibrary(leafem) # funciones adicionales de leaflet\n# Instalación de paquete de datos de ejemplo de Lovelace et al.\ninstall.packages(\"spData\")\ninstall.packages(\"spDataLarge\", repos = \"https://nowosad.r-universe.dev\")\n# Carga de paquete de datos de ejemplo de Lovelace et al.\nlibrary(spData)\nlibrary(spDataLarge)"},{"path":"operaciones-con-datos-espaciales.html","id":"conjuntos-de-datos-para-ejemplos-2","chapter":"15 Operaciones con datos espaciales","heading":"15.3.2 Conjuntos de datos para ejemplos","text":"","code":""},{"path":"operaciones-con-datos-espaciales.html","id":"provincias-de-costa-rica-1","chapter":"15 Operaciones con datos espaciales","heading":"15.3.2.1 Provincias de Costa Rica","text":"Es un archivo GeoJSON con los polígonos de las provincias de Costa Rica. Este archivo proviene de un geoservicio de tipo Web Feature Service (WFS) publicado por el Instituto Geográfico Nacional (IGN). Se transforma WGS84 para combinarlo más fácilmente con otros conjuntos de datos.","code":"\n# Lectura y visualización de datos geoespaciales de provincias\n\n# Lectura\nprovincias <-\n  st_read(\n    dsn = \"datos/ign/delimitacion-territorial-administrativa/provincias.geojson\",\n    quiet = TRUE\n  ) %>%\n  st_transform(4326) # transformación a WGS84\n\n# Transformación\nprovincias <-\n  provincias %>%\n  st_transform(5367) %>%\n  st_simplify(dTolerance = 100) %>% # simplificación de geometrías\n  st_transform(4326)\n\n# Visualización en un mapa\nplot(\n  provincias$geometry,\n  extent = st_bbox(c(xmin = -86.0, xmax = -82.3, ymin = 8.0, ymax = 11.3)),\n  main = \"Provincias de Costa Rica\",\n  axes = TRUE,\n  graticule = TRUE\n)"},{"path":"operaciones-con-datos-espaciales.html","id":"cantones-de-costa-rica-1","chapter":"15 Operaciones con datos espaciales","heading":"15.3.2.2 Cantones de Costa Rica","text":"Es un archivo GeoJSON con los polígonos de los cantones de Costa Rica. Este archivo proviene de un geoservicio de tipo Web Feature Service (WFS) publicado por el Instituto Geográfico Nacional (IGN). Se transforma WGS84 para combinarlo más fácilmente con otros conjuntos de datos.","code":"\n# Lectura y visualización de datos geoespaciales de cantones\n\n# Lectura\ncantones <-\n  st_read(\n    dsn = \"datos/ign/delimitacion-territorial-administrativa/cantones.geojson\",\n    quiet = TRUE\n  ) %>%\n  st_transform(4326) # transformación a WGS84\n\n# Transformación\ncantones <-\n  cantones %>%\n  st_transform(5367) %>%\n  st_simplify(dTolerance = 100) %>% # simplificación de geometrías\n  st_transform(4326)\n\n# Visualización en un mapa\nplot(\n  cantones$geometry,\n  extent = st_bbox(c(xmin = -86.0, xmax = -82.3, ymin = 8.0, ymax = 11.3)),\n  main = \"Cantones de Costa Rica\",\n  axes = TRUE,\n  graticule = TRUE\n)"},{"path":"operaciones-con-datos-espaciales.html","id":"aeródromos-de-costa-rica","chapter":"15 Operaciones con datos espaciales","heading":"15.3.2.3 Aeródromos de Costa Rica","text":"Es un archivo GeoJSON con las geometrías de puntos de los aeródromos de Costa Rica. Este archivo proviene de un geoservicio de tipo Web Feature Service (WFS) publicado por el Instituto Geográfico Nacional (IGN). Se transforma WGS84 para combinarlo más fácilmente con otros conjuntos de datos.","code":"\n# Lectura y visualización de datos geoespaciales de aeródromos\n\n# Lectura\naerodromos <-\n  st_read(\n    dsn = \"datos/ign/infraestructura/aerodromos.geojson\",\n    quiet = TRUE\n  ) %>%\n  st_transform(4326) # transformación a WGS84\n\n# Visualización en un mapa\nplot(\n  aerodromos$geometry,\n  pch = 16,\n  main = \"Aeródromos de Costa Rica\",\n  axes = TRUE,\n  graticule = TRUE\n)"},{"path":"operaciones-con-datos-espaciales.html","id":"cabeceras-de-cantones-y-provincias-de-costa-rica","chapter":"15 Operaciones con datos espaciales","heading":"15.3.2.4 Cabeceras de cantones y provincias de Costa Rica","text":"Se origina en un filtro un archivo GeoJSON con las geometrías de puntos de los poblados de Costa Rica. Este archivo proviene de un geoservicio de tipo Web Feature Service (WFS) publicado por el Instituto Geográfico Nacional (IGN). Se transforma WGS84 para combinarlo más fácilmente con otros conjuntos de datos.","code":"\n# Lectura y visualización de datos geoespaciales de cabeceras de cantones y provincias\n\n# Lectura\ncabeceras_cantones_provincias <-\n  st_read(dsn = \"datos/ign/nombres-geograficos/poblados.geojson\",\n          quiet = TRUE) %>%\n  filter(\n    tipo == \"Cabecera de cantón y distrito\" |\n      tipo == \"Cabecera de provincia - cantón y distrito\" |\n      tipo == \"Capital y cabecera de provincia\"\n  ) %>%\n  st_transform(4326) # transformación a WGS84\n\n# Visualización en un mapa\nplot(\n  cabeceras_cantones_provincias$geometry,\n  pch = 16,\n  main = \"Cabeceras de cantones y provincias de Costa Rica\",\n  axes = TRUE,\n  graticule = TRUE\n)"},{"path":"operaciones-con-datos-espaciales.html","id":"vipéridos-de-costa-rica","chapter":"15 Operaciones con datos espaciales","heading":"15.3.2.5 Vipéridos de Costa Rica","text":"Es un archivo CSV con registros de presencia de la familia Viperidae (serpientes venenosas) de Costa Rica. Este archivo proviene de una consulta al portal de datos de la Infraestructura Mundial de Información en Biodiversidad (GBIF).","code":"\n# Lectura y visualización de datos geoespaciales de aeródromos\n\n# Lectura\nviperidos <-\n  st_read(\n    \"datos/gbif/viperidos.csv\",\n    options = c(\n      \"X_POSSIBLE_NAMES=decimalLongitude\", # columna de longitud decimal\n      \"Y_POSSIBLE_NAMES=decimalLatitude\"   # columna de latitud decimal\n    ),\n    quiet = TRUE\n  )\n\n# Asignación del CRS WGS84\nst_crs(viperidos) <- 4326\n\n# Visualización en un mapa\nplot(\n  viperidos$geometry,\n  pch = 16,\n  main = \"Vipéridos de Costa Rica\",\n  axes = TRUE,\n  graticule = TRUE\n)"},{"path":"operaciones-con-datos-espaciales.html","id":"altitud-de-costa-rica","chapter":"15 Operaciones con datos espaciales","heading":"15.3.2.6 Altitud de Costa Rica","text":"Es un archivo GeoTIFF correspondiente la altitud de Costa Rica, en resolución de 30 x 30 segundos. Este archivo proviene de WorldClim, un conjunto de capas climáticas disponibles en varias resoluciones espaciales.","code":"\n# Lectura y visualización de datos geoespaciales de altitud de Costa Rica\n\n# Lectura\naltitud <-\n  rast(\n    \"datos/worldclim/altitud.tif\"\n  )\n\n# Visualización en un mapa\nterra::plot(\n  altitud,\n  main = \"Altitud de Costa Rica\"\n)"},{"path":"operaciones-con-datos-espaciales.html","id":"introducción-2","chapter":"15 Operaciones con datos espaciales","heading":"15.4 Introducción","text":"Esta lección brinda una visión general de las operaciones espaciales para datos vectoriales implementadas en el paquete sf, y para datos raster implementadas en el paquete terra.","code":""},{"path":"operaciones-con-datos-espaciales.html","id":"datos-vectoriales-2","chapter":"15 Operaciones con datos espaciales","heading":"15.5 Datos vectoriales","text":"Las operaciones espaciales para datos vectoriales incluyen:Creación de subconjuntos espaciales (spatial subsetting).Unión de datos espaciales (spatial joining).Agregación de datos espaciales (spatial aggregation).Relaciones de distancia.Seguidamente, se explicará como maneja estas operaciones el paquete sf.","code":""},{"path":"operaciones-con-datos-espaciales.html","id":"manejo-de-datos-espaciales-con-el-paquete-sf","chapter":"15 Operaciones con datos espaciales","heading":"15.6 Manejo de datos espaciales con el paquete sf","text":"","code":""},{"path":"operaciones-con-datos-espaciales.html","id":"creación-de-subconjuntos-espaciales","chapter":"15 Operaciones con datos espaciales","heading":"15.6.1 Creación de subconjuntos espaciales","text":"Es el proceso de selección de objetos espaciales con base en su relación con otros objetos espaciales. Estas relaciones se expresan como predicados espaciales, los cuales están implementados como métodos de sf.La creación de subconjuntos espaciales es análoga la creación de subconjuntos por datos de atributos. Puede realizarse través de los operadores [ y $ del paquete base de R o por medio de la función filter() de dplyr.En los dos ejemplos siguientes, se utiliza el método st_within() para filtrar los puntos contenidos en un polígono.Primero, se utilizan los operadores del paquete base.Mapa leaflet.El mismo resultado se obtiene con las funciones y operadores de Tidyverse.En el anterior llamado filter(), la expresión x = . es equivalente x = aerodromos. Para una explicación sobre el argumento sparse, por favor lea la sección 4.2.2. del libro “Geocomputation R” de R. Lovelace et. al..Mapa leaflet.Además de st_within(), sf implementa predicados espaciales como, entre otros, st_contains(), st_intersects() y st_disjoint(), entre otros.","code":"\n# Selección de la provincia de Limón (por atributos)\nlimon <- provincias[provincias$provincia == \"Limón\",]\n\n# Selección de los aeródromos ubicados en Limón (espacial)\naerodromos_limon <- aerodromos[limon, , op = st_within]\n# Mapa leaflet\nleaflet() %>%\n  addTiles() %>% # capa base de OSM\n  addPolygons( # capa de provincias (polígonos)\n    data = limon,\n    color = \"black\",\n    fillColor = \"transparent\",\n    stroke = TRUE,\n    weight = 1.0,\n  ) %>%  \n  addCircleMarkers( # capa de registros de presencia (puntos)\n    data = aerodromos_limon,\n    stroke = F,\n    radius = 4,\n    fillColor = 'brown',\n    fillOpacity = 1\n  )\n# Selección de la provincia de Limón (por atributos)\nlimon <-\n  provincias %>%\n  filter(provincia == \"Limón\")\n\n# Selección de los aeródromos ubicados en Limón (espacial)\naerodromos_limon <-\n  aerodromos %>%\n  filter(st_within(x = ., y = limon, sparse = FALSE))\n# Mapa leaflet\nleaflet() %>%\n  addTiles() %>% # capa base de OSM\n  addPolygons( # capa de provincias (polígonos)\n    data = limon,\n    color = \"black\",\n    fillColor = \"transparent\",\n    stroke = TRUE,\n    weight = 1.0,\n  ) %>%  \n  addCircleMarkers( # capa de registros de presencia (puntos)\n    data = aerodromos_limon,\n    stroke = F,\n    radius = 4,\n    fillColor = 'black',\n    fillOpacity = 1\n  )"},{"path":"operaciones-con-datos-espaciales.html","id":"unión-de-datos-espaciales","chapter":"15 Operaciones con datos espaciales","heading":"15.6.2 Unión de datos espaciales","text":"La unión “espacial” de dos conjuntos de datos se basa en uno o varios campos (llamados llaves o keys) que están presentes en ambos conjuntos. Las uniones espaciales se basan en un principio similar pero, en lugar de campos, la relación entre los conjuntos se realiza través de una operación topológica, veces llamada spatial overlay. Al igual que con los datos de atributos, la unión espacial, ejecutada con el método st_join(), agrega una o varias columnas al conjunto de datos destino (.e. el argumento x de la función), provenientes del objeto fuente (.e. el argumento y). La operación topológica que ejecuta por defecto st_join() es st_intersects().","code":""},{"path":"operaciones-con-datos-espaciales.html","id":"ejemplos-3","chapter":"15 Operaciones con datos espaciales","heading":"15.6.2.1 Ejemplos","text":"","code":""},{"path":"operaciones-con-datos-espaciales.html","id":"vipéridos-de-costa-rica-1","chapter":"15 Operaciones con datos espaciales","heading":"15.6.2.1.1 Vipéridos de Costa Rica","text":"","code":""},{},{},{},{},{"path":"operaciones-con-datos-espaciales.html","id":"agregación-de-datos-espaciales","chapter":"15 Operaciones con datos espaciales","heading":"15.6.3 Agregación de datos espaciales","text":"De manera similar al caso de la agregación de atributos, la agregación espacial es una forma de “condensar” o “resumir” datos. Los datos agregados muestran estadísticas de una variable (ej. promedio, suma) en relación con una variable de agrupación. Esto puede lograrse con el método agregate() de sf o con los métodos group_by() y summarise() de dplyr, utilizados en combinación con st_join().En el siguiente bloque de código, se utiliza summarise() para mostrar el promedio de altitud de los puntos más altos de Nueva Zelanda (NZ) en cada región del país. Los datos de los puntos más altos están en el objeto nz_height y los de las regiones de Nueva Zelanda en el objeto nz.Los resultados se muestran en un mapa leaflet.","code":"\n# Promedio de altitud de puntos más altos para cada región de NZ\nnz_regiones_altitud_promedio_puntos_altos <-\n  nz_height %>%\n  aggregate(by = nz, FUN = mean)\n# Paleta de colores\ncolores_nz_regiones_altitud_promedio_puntos_altos <-\n  colorNumeric(palette = \"Blues\",\n               domain = nz_regiones_altitud_promedio_puntos_altos$elevation,\n               na.color = \"transparent\")\n\n# Mapa leaflet\nleaflet() %>%\n  addTiles(group = \"OpenStreetMap\") %>% # capa base de OSM\n  addPolygons(\n    # capa de regiones de NZ (polígonos)\n    data = st_transform(nz_regiones_altitud_promedio_puntos_altos, 4326),\n    color = \"black\",\n    fillColor = ~ colores_nz_regiones_altitud_promedio_puntos_altos(\n      nz_regiones_altitud_promedio_puntos_altos$elevation\n    ),\n    fillOpacity = 0.8,\n    stroke = TRUE,\n    weight = 1.0,\n    popup = paste(\n      \"<strong>Altitud de la región:<\/strong>\",\n      nz_regiones_altitud_promedio_puntos_altos$elevation,\n      \"m\"\n    ),\n    group = \"Regiones de NZ\"\n  ) %>%\n  addCircleMarkers(\n    # capa de puntos altos de NZ\n    data = st_transform(nz_height, 4326),\n    stroke = F,\n    radius = 4,\n    fillColor = 'brown',\n    fillOpacity = 1,\n    popup = paste(\n      \"<strong>Altitud del punto:<\/strong>\",\n      nz_height$elevation,\n      \"m\"\n    ),    \n    group = \"Puntos altos\"\n  ) %>%\n  addLayersControl(\n    baseGroups = c(\"OpenStreetMap\"),\n    overlayGroups = c(\n      \"Regiones de NZ\",\n      \"Puntos altos\"\n    )\n  ) %>%\n  addLegend(\n    position = \"bottomleft\",\n    pal = colores_nz_regiones_altitud_promedio_puntos_altos,\n    values = nz_regiones_altitud_promedio_puntos_altos$elevation,\n    group = \"Regiones de NZ\",\n    title = \"Altitud promedio\"\n  )"},{"path":"operaciones-con-datos-espaciales.html","id":"relaciones-de-distancia","chapter":"15 Operaciones con datos espaciales","heading":"15.6.4 Relaciones de distancia","text":"La distancia entre dos objetos sf se calcula con el método st_distance(). En el siguiente ejemplo, se calcula la distancia entre los puntos correspondientes varias cabeceras de provincias y cantones de Costa Rica.Mapa leaflet de cabeceras de cantones y provincias.","code":"\n# Cálculo de distancias entre cabeceras de cantones y provincias\n\ncat(\"Distancia entre San José y La Cruz:\",\n    round(st_distance(\n      filter(cabeceras_cantones_provincias, nombre == \"San José\"),\n      filter(cabeceras_cantones_provincias, nombre == \"La Cruz\")\n    ) / 1000, 2),\n    \"km\",\n    \"\\n\")\n#> Distancia entre San José y La Cruz: 212.12 km\n\ncat(\"Distancia entre San José y Neily:\",\n    round(st_distance(\n      filter(cabeceras_cantones_provincias, nombre == \"San José\"),\n      filter(cabeceras_cantones_provincias, nombre == \"Neily\")\n    ) / 1000, 2),\n    \"km\",\n    \"\\n\")\n#> Distancia entre San José y Neily: 189.5 km\n\ncat(\"Distancia entre San José y Bribrí:\",\n    round(st_distance(\n      filter(cabeceras_cantones_provincias, nombre == \"San José\"),\n      filter(cabeceras_cantones_provincias, nombre == \"Bribrí\")\n    ) / 1000, 2),\n    \"km\",\n    \"\\n\")\n#> Distancia entre San José y Bribrí: 140.72 km\n\ncat(\"Distancia entre Heredia y Alajuela:\",\n    round(st_distance(\n      filter(cabeceras_cantones_provincias, nombre == \"Heredia\"),\n      filter(cabeceras_cantones_provincias, nombre == \"Alajuela\")\n    ) / 1000, 2),\n    \"km\",\n    \"\\n\")\n#> Distancia entre Heredia y Alajuela: 10.81 km\n\ncat(\"Distancia entre Alajuela y Cartago:\",\n    round(st_distance(\n      filter(cabeceras_cantones_provincias, nombre == \"Alajuela\"),\n      filter(cabeceras_cantones_provincias, nombre == \"Cartago\")\n    ) / 1000, 2),\n    \"km\",\n    \"\\n\")\n#> Distancia entre Alajuela y Cartago: 36.23 km\n# Mapa de cabeceras de cantones y provincias\nleaflet() %>%\n  addTiles(group = \"OpenStreetMap\") %>% # capa base de OSM\n  addCircleMarkers(\n    # capa de puntos altos de NZ\n    data = cabeceras_cantones_provincias,\n    stroke = F,\n    radius = 4,\n    fillColor = 'brown',\n    fillOpacity = 1,\n    popup = cabeceras_cantones_provincias$nombre,\n    group = \"Cabeceras de cantones y provincias\"\n  ) %>%\n  addLayersControl(\n    baseGroups = c(\"OpenStreetMap\"),\n    overlayGroups = c(\"Cabeceras de cantones y provincias\")\n  ) %>%\n  addScaleBar(position = \"bottomright\", options = scaleBarOptions(imperial = FALSE))"},{"path":"operaciones-con-datos-espaciales.html","id":"datos-raster-2","chapter":"15 Operaciones con datos espaciales","heading":"15.7 Datos raster","text":"Las operaciones espaciales para datos raster incluyen:Creación de subconjuntos espaciales (spatial subsetting).Álgebra de mapas (map algebra).","code":""},{"path":"operaciones-con-datos-espaciales.html","id":"manejo-de-datos-espaciales-con-el-paquete-terra","chapter":"15 Operaciones con datos espaciales","heading":"15.8 Manejo de datos espaciales con el paquete terra","text":"En los siguientes ejemplos, se utilizarán los conjuntos de datos elevacion y grano que se crearon en la lección sobre datos de atributos, los cuales están también incluidos en el paquete spData.También se utilizará la capa de altitud de Costa Rica.","code":"\n# Creación de objetos SpatRaster\nelevacion <-  rast(system.file(\"raster/elev.tif\", package = \"spData\"))\ngrano <- rast(system.file(\"raster/grain.tif\", package = \"spData\"))\n\n# Mapeo de los conjuntos de datos de ejemplo\n\n# Elevación\nplot(elevacion)\n\n# Tipos de granos\nplot(grano)"},{"path":"operaciones-con-datos-espaciales.html","id":"creación-de-subconjuntos-espaciales-1","chapter":"15 Operaciones con datos espaciales","heading":"15.8.1 Creación de subconjuntos espaciales","text":"En la lección sobre operaciones con atributos, se explicó como recuperar subconjuntos de objetos raster, ya sea mediante su ID o su posición en filas y columnas. Los subconjuntos de objetos raster también pueden obtenerse mediante la especificación de coordenadas o de otros objetos espaciales.El siguiente bloque de código retorna el valor en la capa de altitud de Costa Rica correspondiente varios pares de coordenadas (x, y).También es posible consultar las celdas contenidas en la extensión (.e. los límites) otro raster.Los métodos explicados anteriormente solo retornan ID y valores de celdas. Con el operador [ y el argumento drop = FALSE pueden retornarse objetos raster.El método crop() recorta un objeto SpatRaster de acuerdo con el contorno de otro objeto espacial, raster o vectorial. El siguiente bloque de código recorta la capa de altitud de Costa Rica con base en un objeto raster ubicado en el centro del país.Seguidamente, la misma capa de altitud se recorta siguiendo el contorno de una capa vectorial de la clase SpatVector de terra, correspondiente la provincia de Heredia. El polígono de Heredia debe convertirse SpatVector mediante el método vect().El siguiente mapa leaflet muestra la capa de altitud de Costa Rica y los recortes efectuados en esta.También es posible obtener subconjuntos raster mediante la aplicación en un objeto raster de una “máscara” (mask) con la misma extensión y resolución, y que contenga valores lógicos o NA. Esta operación puede realizarse con el método mask().","code":"\n# La función cellFromXY() retorna el ID de la celda correspondiente a una coordenada\nid <- cellFromXY(elevacion, xy = matrix(c(0.1, 0.1), ncol = 2))\nelevacion[id]\n#>   elev\n#> 1   16\n\n# El mismo resultado puede obtenerse con terra::extract()\nterra::extract(elevacion, data.frame(x = 0.1, y = 0.1))\n#>   ID elev\n#> 1  1   16\n# Altitud del punto en (-84, 10)\naltitud[cellFromXY(altitud, xy = matrix(c(-84, 10), ncol = 2))]\n#>   altitud\n#> 1    1451\n\n# Altitud del Cerro Chirripó\naltitud[cellFromXY(altitud, xy = matrix(c(-83.488667, 9.484083), ncol = 2))]\n#>   altitud\n#> 1    3664\n\n# Altitud de la Catedral Metropolitana de San José\naltitud[cellFromXY(altitud, xy = matrix(c(-84.078758, 9.932684), ncol = 2))]\n#>   altitud\n#> 1    1156\n# Objeto raster para hacer un recorte (\"clip\") de otro raster\nclip <- rast(\n  xmin = 0.9,\n  xmax = 1.8,\n  ymin = -0.45,\n  ymax = 0.45,\n  resolution = 0.3,\n  vals = rep(1, 9)\n)\n\n# Celdas de elev contenidas en la extensión de clip\nelevacion[clip]\n#>      elev\n#> [1,]   18\n#> [2,]   24\n# Objeto raster creado a partir de un rango de ID de celdas\nr1 <- elevacion[1:2, drop = FALSE]\nplot(r1)\n\n# Objeto raster creado a partir de posiciones de filas y columnas\nr2 <- elevacion[1:3, 1:3, drop = FALSE]\nplot(r2)\n# Creación de un raster ubicado en el centro del país, alrededor de (-84, 10)\nclip_centro_cr <-\n  rast(\n    xmin = -84.10,\n    xmax = -83.90,\n    ymin = 9.90,\n    ymax = 10.10,\n    res = 0.10\n  )\n\n# Recorte de la capa de altitud con base en el raster del centro del país\naltitud_centro_cr <- crop(altitud, clip_centro_cr)\nplot(altitud_centro_cr)\n# Polígono de la provincia de Heredia\nheredia <-\n  provincias %>%\n  filter(provincia == \"Heredia\")\n\n# Recorte de la capa de altitud\naltitud_heredia <-\n  altitud %>%\n  crop(vect(heredia)) %>%\n  mask(vect(heredia))\n\nplot(altitud_heredia)\n# Paleta de colores de altitud de Costa Rica\ncolores_altitud <-\n  colorNumeric(terrain.colors(25),\n               values(altitud),\n               na.color = \"transparent\")\n\n# Mapa leaflet\nleaflet() %>%\n  setView(# centro y nivel inicial de acercamiento\n    lng = -84.19452,\n    lat = 9.572735,\n    zoom = 7) %>%\n  addTiles(group = \"OpenStreetMap\") %>%\n  addRasterImage(\n    raster::raster(altitud),\n    colors = colores_altitud,\n    opacity = 0.8,\n    group = \"Altitud de Costa Rica\"\n  ) %>%\n  addRasterImage(\n    raster::raster(altitud_heredia),\n    colors = colores_altitud,\n    opacity = 0.8,\n    group = \"Altitud de Heredia\"\n  ) %>%\n  addRasterImage(\n    raster::raster(altitud_centro_cr),\n    colors = colores_altitud,\n    opacity = 0.8,\n    group = \"Altitud del centro de Costa Rica\"\n  ) %>%\n  addLayersControl(\n    baseGroups = c(\"OpenStreetMap\"),\n    overlayGroups = c(\n      \"Altitud de Costa Rica\",\n      \"Altitud de Heredia\",\n      \"Altitud del centro de Costa Rica\"\n    )\n  ) %>%\n  addLegend(\n    title = \"Altitud de Costa Rica\",\n    values = values(altitud),\n    pal = colores_altitud,\n    position = \"bottomleft\",\n    group = \"Altitud de Costa Rica\"\n  ) %>%\n  addLegend(\n    title = \"Altitud de Heredia\",\n    values = values(altitud_heredia),\n    pal = colores_altitud,\n    position = \"bottomleft\",\n    group = \"Altitud de Heredia\"\n  ) %>%\n  addLegend(\n    title = \"Altitud del centro de Costa Rica\",\n    values = values(altitud_centro_cr),\n    pal = colores_altitud,\n    position = \"bottomright\",\n    group = \"Altitud del centro de Costa Rica\"\n  )  %>%\n  hideGroup(\"Altitud de Heredia\") %>%\n  hideGroup(\"Altitud del centro de Costa Rica\")  \n# Creación de una \"máscara\"\nmascara <- elevacion \nvalues(mascara) <- sample(c(NA, TRUE), 36, replace = TRUE)\nplot(mascara)\n\n# Creación de subconjuntos espaciales mediante la máscara\nelevacion_mascara <- mask(elevacion, mascara)                   \nplot(elevacion_mascara)  "},{"path":"operaciones-con-datos-espaciales.html","id":"álgebra-de-mapas","chapter":"15 Operaciones con datos espaciales","heading":"15.8.2 Álgebra de mapas","text":"El álgebra de mapas divide las operaciones raster en cuatro clases (Lovelace et al.):Operaciones locales o de “celda por celda”.Operaciones focales o de “vecindario” (neighborhood). Generalmente, el valor de salida de cada celda proviene de un bloque de entrada de 3 x 3 celdas.Operaciones zonales. Son similares las focales, pero el bloque de entrada puede tener tamaños y formas irregulares.Operaciones globales. Los valores de salida de cada celda provienen de uno o varios objetos raster completos.Esta clasificación se basa en la cantidad o forma de las celdas utilizadas por cada pixel durante el procesamiento. Otras clasificaciones pueden estar basadas en el área de aplicación del análisis (ej. terreno, hidrología, teledetección).","code":""},{"path":"operaciones-con-datos-espaciales.html","id":"operaciones-locales","chapter":"15 Operaciones con datos espaciales","heading":"15.8.2.1 Operaciones locales","text":"Son operaciones realizadas celda por celda en una o varias capas raster. Por ejemplo, la reclasificación de una capa mediante el método classify().También operaciones aritméticas, similares las que se realizan con matrices algebraicas.El siguiente bloque de código calcula el Índice de vegetación de diferencia normalizada (NDVI, en inglés, Normalized difference vegetation index) en una imagen Landsat. El NDVI se utiliza para estimar la cantidad, calidad y desarrollo de la vegetación con base la medición de la intensidad de la radiación de ciertas bandas del espectro electromagnético que la vegetación emite o refleja. El valor del NDVI varía entre -1.0 y +1.0.El resultado se aprecia mejor en un mapa leaflet. Nótese el uso del método raster::aggregate() para reducir el tamaño del objeto raster_ndvi, el cual puede ser muy grande para desplegarse con leaflet::addRasterImage().","code":"\n# Reclasificación de una capa raster\nrcl <-  matrix(c(0, 12, 1, 12, 24, 2, 24, 36, 3), ncol = 3, byrow = TRUE)\nrecl <- classify(elevacion, rcl = rcl)\nplot(recl)\n# Álgebra raster con operadores aritméticos y de comparación\n\n# Operación aritmética\nelevacion_doble <- elevacion + elevacion\nplot(elevacion_doble)\n\n# Operación aritmética\nelevacion_cuadrado <- elevacion * elevacion\nplot(elevacion_cuadrado)\n\n# Expresión lógica de comparación\nelevacion_mayor_30 <- elev > 30\nplot(elevacion_mayor_30)\n# Cálculo del NDVI\n\n# Imagen Landsat de 4 bandas (4 = red, 3 = infraroja cercana)\narchivo_imagen_landsat = system.file(\"raster/landsat.tif\", package = \"spDataLarge\")\nimagen_landsat = rast(archivo_imagen_landsat)\n\nplot(imagen_landsat)\n\n# Función para calcular el NDVI (red = banda roja, nir = banda infraroja cercana)\nndvi <- function(nir, red) {\n  (nir - red) / (nir + red)\n}\n\n# Se aplica ndvi() sobre todas las celdas de la capa raster\nraster_ndvi = lapp(imagen_landsat[[c(4, 3)]], fun = ndvi)\n\nplot(raster_ndvi)\n# Paleta de colores de NDVI\ncolores_ndvi <-\n  colorNumeric(rev(grDevices::terrain.colors(25)),\n               values(raster_ndvi),\n               na.color = \"transparent\")\n\n# Mapa leaflet\nleaflet() %>%\n  addTiles(group = \"OpenStreetMap\") %>%\n  addRasterImage(\n    raster::aggregate(raster::raster(raster_ndvi), fact = 2, fun = mean),\n    colors = colores_ndvi,\n    opacity = 0.8,\n    group = \"NDVI\"\n  ) %>%\n  addLayersControl(baseGroups = c(\"OpenStreetMap\"),\n                   overlayGroups = c(\"NDVI\")) %>%\n  addLegend(\n    title = \"NDVI\",\n    values = values(raster_ndvi),\n    pal = colores_ndvi,\n    position = \"bottomleft\",\n    group = \"NDVI\"\n  )  "},{"path":"operaciones-con-datos-espaciales.html","id":"operaciones-focales","chapter":"15 Operaciones con datos espaciales","heading":"15.8.2.2 Operaciones focales","text":"En este tipo de operaciones, el valor de salida de cada pixel procesado depende de un bloque compuesto por una celda central y sus vecinas. Este “vecindario” (también llamado kernel, filtro o “ventana móvil”) es típicamente de 3 x 3 celdas, pero puede tomar otras formas y tamaños. Una operación focal aplica una función de agregación (ej. promedio, mínimo, máximo) todas las celdas del vecindario, utiliza la salida como nuevo valor de la celda central correspondiente y se mueve la celda siguiente.Las operaciones focales tienen aplicaciones en áreas como procesamiento de imágenes (ej. remoción de valores extremos) o análisis de terreno (ej. cálculo de pendiente o dirección de flujo).","code":"\n# Uso de focal() para obtener el valor mínimo en un vecindario de 3 x 3\nminimo_ventana <- focal(elevacion, w = matrix(1, nrow = 3, ncol = 3), fun = min)\nplot(minimo_ventana)"},{"path":"operaciones-con-datos-espaciales.html","id":"operaciones-zonales","chapter":"15 Operaciones con datos espaciales","heading":"15.8.2.3 Operaciones zonales","text":"De manera similar las focales, las operaciones zonales aplicación de agregación múltiples celdas raster. Sin embargo, en el caso de las zonales, generalmente se usa un raster categórico que define las zonas, diferencia de la ventana predefinida que se emplea en las focales. Por lo tanto, las celdas que definen el filtro zonal deben ser necesariamente vecinas.","code":"\n# Uso de zonal() para encontrar la elevación promedio de cada tipo de grano\nzonal(elevacion, grano, fun = \"mean\") %>%\n  as.data.frame()\n#>   grain     elev\n#> 1  clay 14.80000\n#> 2  silt 21.15385\n#> 3  sand 18.69231"},{"path":"operaciones-con-datos-espaciales.html","id":"operaciones-globales","chapter":"15 Operaciones con datos espaciales","heading":"15.8.2.4 Operaciones globales","text":"Las operaciones globales pueden considerarse un caso particular de las operaciones zonales, en las cuales un raster completo corresponde una zona. Las operaciones globales más comunes incluyen estadísticas descriptivas para todo un conjunto raster.Otras operaciones globales incluyen cálculos de distancia y rasters de “peso” (weight rasters) (ej. distancia de cada celda una celda objetivo, costo en combustible de cada celda una celda objetivo).","code":"\n# Resumen\nterra::summary(altitud)\n#> Warning: [summary] used a sample\n#>     altitud      \n#>  Min.   :   1.0  \n#>  1st Qu.:  63.0  \n#>  Median : 254.0  \n#>  Mean   : 561.3  \n#>  3rd Qu.: 852.0  \n#>  Max.   :3628.0  \n#>  NA's   :83907\n\n# Histograma\nterra::hist(altitud)"},{"path":"operaciones-con-geometrías.html","id":"operaciones-con-geometrías","chapter":"16 Operaciones con geometrías","heading":"16 Operaciones con geometrías","text":"","code":""},{"path":"operaciones-con-geometrías.html","id":"resumen-15","chapter":"16 Operaciones con geometrías","heading":"16.1 Resumen","text":"Las operaciones con geometrías para datos vectoriales incluyen simplificación, creación de centroides, creación de áreas de amortiguamiento (buffers), recortes (clipping) y uniones de geometrías, entre otras. Por su parte, las operaciones con geometrías para datos raster incluyen intersecciones geométricas, agregación y desagregación, entre otras.","code":""},{"path":"operaciones-con-geometrías.html","id":"trabajo-previo-11","chapter":"16 Operaciones con geometrías","heading":"16.2 Trabajo previo","text":"","code":""},{"path":"operaciones-con-geometrías.html","id":"lecturas-9","chapter":"16 Operaciones con geometrías","heading":"16.2.1 Lecturas","text":"Lovelace, R., Nowosad, J., & Münchow, J. (2019). Geocomputation R (capítulo 5). CRC Press. https://geocompr.robinlovelace.net/","code":""},{"path":"operaciones-con-geometrías.html","id":"preparativos-3","chapter":"16 Operaciones con geometrías","heading":"16.3 Preparativos","text":"","code":""},{"path":"operaciones-con-geometrías.html","id":"carga-de-paquetes-3","chapter":"16 Operaciones con geometrías","heading":"16.3.1 Carga de paquetes","text":"Paquete rmapshaper, para la edición y simplificación de geometrías:","code":"\n# Carga de paquetes\n\nlibrary(dplyr) # transformación de datos\nlibrary(sf) # manejo de datos vectoriales\nlibrary(terra) # manejo de datos raster\nlibrary(DT) # tablas interactivas\nlibrary(leaflet) # mapas interactivos\nlibrary(leaflet.extras) # funciones adicionales de leaflet\nlibrary(leafem) # funciones adicionales de leaflet\nlibrary(spData) # datos de ejemplo\nlibrary(spDataLarge) # datos de ejemplo\n# Instalación de rmapshaper\ninstall.packages(\"rmapshaper\")\n# Carga de rmapshaper\nlibrary(rmapshaper)"},{"path":"operaciones-con-geometrías.html","id":"conjuntos-de-datos-para-ejemplos-3","chapter":"16 Operaciones con geometrías","heading":"16.3.2 Conjuntos de datos para ejemplos","text":"","code":""},{"path":"operaciones-con-geometrías.html","id":"provincias-de-costa-rica-2","chapter":"16 Operaciones con geometrías","heading":"16.3.2.1 Provincias de Costa Rica","text":"Es un archivo GeoJSON con los polígonos de las provincias de Costa Rica. Este archivo proviene de un geoservicio de tipo Web Feature Service (WFS) publicado por el Instituto Geográfico Nacional (IGN).","code":"\n# Lectura y visualización de datos geoespaciales de provincias\n\n# Lectura\nprovincias <-\n  st_read(\n    dsn = \"datos/ign/delimitacion-territorial-administrativa/provincias.geojson\",\n    quiet = TRUE\n  )\n\n# Visualización en un mapa\nplot(\n  provincias$geometry,\n  extent = st_bbox(c(xmin = 280000, xmax = 660000, ymin = 880000, ymax= 1250000)),\n  main = \"Provincias de Costa Rica\",\n  axes = TRUE,\n  graticule = TRUE\n)"},{"path":"operaciones-con-geometrías.html","id":"cantones-de-costa-rica-2","chapter":"16 Operaciones con geometrías","heading":"16.3.2.2 Cantones de Costa Rica","text":"Es un archivo GeoJSON con los polígonos de los cantones de Costa Rica. Este archivo proviene de un geoservicio de tipo Web Feature Service (WFS) publicado por el Instituto Geográfico Nacional (IGN). Se transforma WGS84 para combinarlo más fácilmente con otros conjuntos de datos.","code":"\n# Lectura y visualización de datos geoespaciales de cantones\n\n# Lectura\ncantones <-\n  st_read(\n    dsn = \"datos/ign/delimitacion-territorial-administrativa/cantones.geojson\",\n    quiet = TRUE\n  ) %>%\n  st_transform(4326) # transformación a WGS84\n\n# Transformación\ncantones <-\n  cantones %>%\n  st_transform(5367) %>%\n  st_simplify(dTolerance = 100) %>% # simplificación de geometrías\n  st_transform(4326)\n\n# Visualización en un mapa\nplot(\n  cantones$geometry,\n  extent = st_bbox(c(xmin = -86.0, xmax = -82.3, ymin = 8.0, ymax = 11.3)),\n  main = \"Cantones de Costa Rica\",\n  axes = TRUE,\n  graticule = TRUE\n)"},{"path":"operaciones-con-geometrías.html","id":"red-vial-de-costa-rica","chapter":"16 Operaciones con geometrías","heading":"16.3.2.3 Red vial de Costa Rica","text":"Es un archivo GeoJSON con las líneas de la red vial de Costa Rica. Este archivo proviene de un geoservicio de tipo Web Feature Service (WFS) publicado por el Instituto Geográfico Nacional (IGN).","code":"\n# Lectura y visualización de datos geoespaciales de la red vial\n\n# Lectura\nred_vial <-\n  st_read(\n    dsn = \"datos/ign/infraestructura/redvial.geojson\",\n    quiet = TRUE\n  )\n\n# Visualización en un mapa\nplot(\n  red_vial$geometry,\n  extent = st_bbox(c(xmin = 280000, xmax = 660000, ymin = 880000, ymax= 1250000)),\n  main = \"Red vial de Costa Rica\",\n  axes = TRUE,\n  graticule = TRUE\n)"},{"path":"operaciones-con-geometrías.html","id":"mamíferos-de-costa-rica","chapter":"16 Operaciones con geometrías","heading":"16.3.2.4 Mamíferos de Costa Rica","text":"Es un archivo CSV con registros de presencia de la clase Mammalia (mamíferos) de Costa Rica. Este archivo proviene de una consulta al portal de datos de la Infraestructura Mundial de Información en Biodiversidad (GBIF).","code":"\n# Lectura y visualización de datos geoespaciales de mamíferos\n\n# Lectura\nmamiferos <-\n  st_read(\n    \"datos/gbif/mamiferos.csv\",\n    options = c(\n      \"X_POSSIBLE_NAMES=decimalLongitude\", # columna de longitud decimal\n      \"Y_POSSIBLE_NAMES=decimalLatitude\"   # columna de latitud decimal\n    ),\n    quiet = TRUE\n  )\n\n# Asignación del CRS WGS84\nst_crs(mamiferos) <- 4326\n\n# Visualización en un mapa\nplot(\n  mamiferos$geometry,\n  pch = 16,\n  main = \"Mamíferos de Costa Rica\",\n  axes = TRUE,\n  graticule = TRUE\n)"},{"path":"operaciones-con-geometrías.html","id":"altitud-de-costa-rica-1","chapter":"16 Operaciones con geometrías","heading":"16.3.2.5 Altitud de Costa Rica","text":"Es un archivo GeoTIFF correspondiente la altitud de Costa Rica, en resolución de 30 x 30 segundos. Este archivo proviene de WorldClim, un conjunto de capas climáticas disponibles en varias resoluciones espaciales.","code":"\n# Lectura y visualización de datos geoespaciales de altitud de Costa Rica\n\n# Lectura\naltitud <-\n  rast(\n    \"datos/worldclim/altitud.tif\"\n  )\n\n# Visualización en un mapa\nterra::plot(\n  altitud,\n  main = \"Altitud de Costa Rica\"\n)"},{"path":"operaciones-con-geometrías.html","id":"introducción-3","chapter":"16 Operaciones con geometrías","heading":"16.4 Introducción","text":"Esta lección brinda una visión general de las operaciones con geometrías en datos vectoriales implementadas en el paquete sf y en datos raster implementadas en el paquete terra. Estas operaciones trabajan con la columna de geometrías (ej. geometry, geom) del paquete sf, para el caso de los datos vectoriales, y con la localización geográfica de los pixeles para el caso de los datos raster. En la sección final, se muestran varias operaciones de interacción entre los modelos raster y vectorial.","code":""},{"path":"operaciones-con-geometrías.html","id":"datos-vectoriales-3","chapter":"16 Operaciones con geometrías","heading":"16.5 Datos vectoriales","text":"Las operaciones con geometrías en datos vectoriales incluyen:Simplificación.Centroides.Áreas de amortiguamiento (buffers).Recortes (clipping).Uniones de geometrías.","code":""},{"path":"operaciones-con-geometrías.html","id":"operaciones-con-geometrías-con-el-paquete-sf","chapter":"16 Operaciones con geometrías","heading":"16.6 Operaciones con geometrías con el paquete sf","text":"Estas operaciones modifican las geometrías de objetos vectoriales.","code":""},{"path":"operaciones-con-geometrías.html","id":"simplificación","chapter":"16 Operaciones con geometrías","heading":"16.6.1 Simplificación","text":"La simplificación puede realizarse en geometrías de líneas y polígonos. Reduce la cantidad de memoria, disco y ancho de banda que utilizan las geometrías. Para simplificar geometrías, el paquete sf incluye el método st_simplify(), basado en el algoritmo de Douglas-Peucker, el cual recibe el argumento dTolerance para controlar el nivel de generalización de las unidades del mapa. Este argumento se expresa en las unidades de medida del CRS de la capa, por lo que es conveniente utilizar un CRS con unidades de medida de distancias (ej. metros).El siguiente bloque de código simplifica la capa de provincias, primero sin preservar su topología y luego preservándola.La función ms_simplify() del paquete `rmapshaper`` proporciona un método alternativo para la simplificación de geometrías, el cual preserva la topología.","code":"\n# Simplificación de la capa de provincias\n\n# Simplificación sin preservación de topología\nprovincias_simplificado <-\n  provincias %>%\n  st_simplify(dTolerance = 5000, preserveTopology = FALSE)\n\n# Mapa de la capa de provincias con simplificación y sin preservación de topología\nplot(\n  provincias_simplificado$geometry,\n  extent = st_bbox(c(xmin = 280000, xmax = 660000, ymin = 880000, ymax= 1250000)),  \n  main = \"Provincias simplificadas sin preservación de topología\",\n  axes = TRUE,\n  graticule = TRUE)\n\n# Simplificación con preservación de topología\nprovincias_simplificado_topologia <-\n  provincias %>%\n  st_simplify(dTolerance = 5000, preserveTopology = TRUE)\n\n# Mapa de la capa de provincias con simplificación y con preservación de topología\nplot(\n  provincias_simplificado_topologia$geometry,\n  extent = st_bbox(c(xmin = 280000, xmax = 660000, ymin = 880000, ymax= 1250000)),  \n  main = \"Provincias simplificadas con preservación de topología\",\n  axes = TRUE,\n  graticule = TRUE)\n\n# Tamaño de la capa original\nobject.size(provincias)\n#> 12144488 bytes\n\n# Tamaño de la capa simplificada sin preservación de topología\nobject.size(provincias_simplificado)\n#> 18720 bytes\n\n# Tamaño de la capa simplificada con preservación de topología\nobject.size(provincias_simplificado_topologia)\n#> 70608 bytes\n# Simplificación con ms_simplify()\nprovincias_simplificado_rmapshaper <-\n  provincias %>%\n  ms_simplify(keep = 0.1, keep_shapes = TRUE)\n\n# Mapa de la capa de provincias con simplificación mediante ms_simplify()\nplot(\n  provincias_simplificado_rmapshaper$geometry,\n  extent = st_bbox(c(xmin = 280000, xmax = 660000, ymin = 880000, ymax= 1250000)),  \n  main = \"Provincias simplificadas con ms_simplify()\",\n  axes = TRUE,\n  graticule = TRUE)\n\n# Tamaño de la capa simplificada con ms_simplify()\nobject.size(provincias_simplificado_rmapshaper)\n#> 1447832 bytes"},{"path":"operaciones-con-geometrías.html","id":"centroides","chapter":"16 Operaciones con geometrías","heading":"16.6.2 Centroides","text":"Un centroide es un punto que identifica el centro de un objeto geográfico. Puede calcularse para geometrías de líneas y de polígonos y se utilizan para brindar una representación simplificada de geometrías más complejas. Existen varios métodos para calcularlos.El paquete sf incluye la función st_centroid(), la cual calcula el centroide geográfico (comúnmente llamado “el centroide”). Es posible que el centroide geográfico se ubique fuera de la geometría “padre” (ej. en el caso de una geometría con forma de anillo). Para evitar este resultado, la función st_point_on_surface() se asegura de que el centroide esté siempre dentro de la geometría “padre”.El siguiente bloque de código calcula los centroides para Costa Rica, mediante las dos funciones mencionadas.El siguiente bloque de código calcula los centroides de las provincias de Costa Rica, mediante las dos funciones mencionadas.El siguiente bloque de código calcula los centroides para la ruta 32, mediante las dos funciones mencionadas.","code":"\n# Costa Rica y sus centroides calculados con st_centroid() y st_point_on_surface()\n\n# Mapa de provincias\nplot(\n  st_union(provincias), # unión de los polígonos de provincias\n  main = \"Centroides de CR: st_centroid (rojo) y st_point_on_surface (verde)\",\n  axes = TRUE,\n  graticule = TRUE)\n\n# Mapa del centroide calculado con st_centroid()\nplot(st_centroid(st_union(provincias)),\n     add = TRUE,\n     pch = 16,\n     col = \"red\")\n\n# Mapa del centroide calculado con st_point_on_surface()\nplot(\n  st_point_on_surface(st_union(provincias)),\n  add = TRUE,\n  pch = 16,\n  col = \"green\")\n\n# Coordenadas del centroide calculado con st_centroid()\n# CRTM05\nst_coordinates(st_centroid(st_union(provincias)))\n#>          X       Y\n#> 1 478674.5 1102735\n# WGS84\nst_coordinates(st_transform(st_centroid(st_union(provincias)), crs = 4326))\n#>           X        Y\n#> 1 -84.19451 9.972732\n\n# Coordenadas del centroide calculado con st_point_on_surface()\n# CRTM05\nst_coordinates(st_point_on_surface(st_union(provincias)))\n#>          X       Y\n#> 1 539373.5 1065147\n# WGS84\nst_coordinates(st_transform(st_point_on_surface(st_union(provincias)), crs = 4326))\n#>           X        Y\n#> 1 -83.64124 9.632735\n# Provincias de Costa Rica y sus centroides calculados con st_centroid() y st_point_on_surface()\n\n# Mapa de provincias\nplot(\n  provincias$geometry,\n  extent = st_bbox(c(xmin = 280000, xmax = 660000, ymin = 880000, ymax= 1250000)),  \n  main = \"Centroides de provincias: st_centroid (rojo) y st_point_on_surface (verde)\",\n  axes = TRUE,\n  graticule = TRUE)\n\n# Mapa de los centroides calculados con st_centroid()\nplot(st_centroid(provincias),\n     add = TRUE,\n     pch = 16,\n     col = \"red\")\n\n# Mapa de los centroides calculados con st_point_on_surface()\nplot(\n  st_point_on_surface(provincias),\n  add = TRUE,\n  pch = 16,\n  col = \"green\")\n# Ruta 32 y sus centroides calculados con st_centroid() y st_point_on_surface()\n\n# Polígonos de San José, Heredia y Limón\nsanjose_heredia_limon <-\n  provincias %>%\n  filter(provincia == \"San José\" | provincia == \"Heredia\" | provincia == \"Limón\")\n\n# Línea de la ruta 32\nruta_32 <-\n  red_vial %>%\n  filter(num_ruta == \"32\")\n\n# Mapa de San José, Heredia y Limón\nplot(\n  sanjose_heredia_limon$geometry,\n  main = \"Centroides de la ruta 32: st_centroid (rojo) y st_point_on_surface (verde)\",\n  axes = TRUE,\n  graticule = TRUE)\n\n# Mapa de la ruta 32\nplot(\n  ruta_32$geometry,\n  add = TRUE,\n  lwd = 2,\n  col = \"blue\")\n\n# Mapa del centroide calculado con st_centroid()\nplot(\n  st_centroid(st_union(ruta_32)),\n  add = TRUE,\n  pch = 16,\n  col = \"red\")\n\n# Mapa del centroide calculado con st_point_on_surface()\nplot(\n  st_point_on_surface(st_union(ruta_32)),\n  add = TRUE,\n  pch = 16,\n  col = \"green\")"},{"path":"operaciones-con-geometrías.html","id":"áreas-de-amortiguamiento-buffers","chapter":"16 Operaciones con geometrías","heading":"16.6.3 Áreas de amortiguamiento (buffers)","text":"Los buffers son polígonos creados alrededor de otra geometría, ya sea otro polígono, una línea o un punto. El paquete sf incluye la función st_buffer() para la generación de buffers.","code":"\n# Buffer alrededor de la ruta 32\n\n# Buffer que rodea la ruta 32\nplot(\n  st_buffer(st_union(ruta_32), 5000),\n  main = \"Buffer que rodea la ruta 32\",\n  axes = TRUE,\n  graticule = TRUE)\n\n# Línea de la ruta 32\nplot(\n  ruta_32$geometry,\n  col = \"blue\",\n  add = TRUE\n)"},{"path":"operaciones-con-geometrías.html","id":"ejemplos-4","chapter":"16 Operaciones con geometrías","heading":"16.6.3.1 Ejemplos","text":"","code":""},{"path":"operaciones-con-geometrías.html","id":"especies-de-mamíferos-en-riesgo-de-atropello-en-las-cercanías-de-la-ruta-32","chapter":"16 Operaciones con geometrías","heading":"16.6.3.1.1 Especies de mamíferos en riesgo de atropello en las cercanías de la ruta 32","text":"Es común el uso de buffers en análisis de datos, para responder preguntas como, por ejemplo, “¿cuántos puntos hay alrededor de una línea?” o “¿cuáles especies pueden encontrarse en las márgenes de un río?”. En este ejemplo, se utiliza un buffer para identificar las especies de mamíferos en riesgo de ser atropellados en las cercanías de la ruta 32.Lista de especies y cantidad de registros de presencia:Mapa leaflet:","code":"\n# Registros de presencia de mamíferos no voladores ubicados alrededor de la ruta 32\n\n# Registros de presencia de mamíferos no voladores\nmamiferos_no_voladores <-\n  mamiferos %>%\n  filter(taxonRank == \"SPECIES\" | taxonRank == \"SUBSPECIES\") %>% # para excluir identificaciones a género o superiores\n  filter(order != \"Chiroptera\") # se excluyen los murciélagos\n\n# Línea de la ruta 32\nruta_32 <-\n  red_vial %>%\n  filter(num_ruta == \"32\") %>%\n  st_transform(4326)\n\n# Buffer de la ruta 32\nbuffer_ruta_32 <-\n  ruta_32 %>%\n  st_buffer(dist = 5000) %>%\n  st_transform(4326)\n\n# Registros de presencia dentro del buffer\nmamiferos_buffer_ruta_32 <-\n  st_join(mamiferos_no_voladores, buffer_ruta_32) %>%\n  filter(!is.na(codigo))\n\n# Mapa\nplot(\n  st_union(buffer_ruta_32),\n  main = \"Mamíferos terrestres alrededor de la ruta 32\",\n  axes = TRUE,\n  graticule = TRUE\n)\n\nplot(ruta_32$geometry,\n     col = \"blue\",\n     add = TRUE)\n\nplot(\n  mamiferos_buffer_ruta_32,\n  pch = 16,\n  col = \"orange\",\n  add = TRUE\n)\n# Lista de especies\nlista_especies <-\n  mamiferos_buffer_ruta_32 %>%\n  st_drop_geometry() %>%\n  filter(!is.na(species) & species != \"\") %>%\n  group_by(species) %>%\n  summarise(registros = n()) %>%\n  arrange(desc(registros)) %>%\n  rename(especie = species)\n\n# Tabla\nlista_especies %>%\n  datatable(options = list(\n    pageLength = 10,\n    language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')\n  ))\n# Mapa de mamíferos cerca de la ruta 32\nleaflet() %>%\n  addTiles(group = \"OpenStreetMap\") %>%\n  addPolygons(data = st_union(buffer_ruta_32),\n              group = \"Buffer\") %>%\n  addHeatmap(\n    data = mamiferos_buffer_ruta_32,\n    lng = ~ decimalLongitude,\n    lat = ~ decimalLatitude,\n    radius = 10,\n    blur = 20,\n    group = \"Mapa de calor\"\n  ) %>%\n  addPolylines(data = ruta_32,\n               group = \"Ruta 32\") %>%\n  addCircleMarkers(\n    data = mamiferos_buffer_ruta_32,\n    radius = 1,\n    color = \"black\",\n    popup = paste(\n      mamiferos_buffer_ruta_32$species,\n      paste0(\n        \"<a href='\",\n        mamiferos_buffer_ruta_32$occurrenceID,\n        \"'>Más información<\/a>\"\n      ),\n      sep = '<br/>'\n    ),\n    clusterOptions = markerClusterOptions(),\n    group = \"Registros de presencia\"\n  ) %>%\n  addLayersControl(\n    baseGroups = c(\"OpenStreetMap\"),\n    overlayGroups = c(\"Buffer\", \"Mapa de calor\", \"Ruta 32\", \"Registros de presencia\")\n  ) %>%\n  addScaleBar(position = \"bottomright\", options = scaleBarOptions(imperial = FALSE))"},{"path":"operaciones-con-geometrías.html","id":"datos-raster-3","chapter":"16 Operaciones con geometrías","heading":"16.7 Datos raster","text":"Las operaciones con geometrías en datos raster incluyen:Intersecciones geométricas.Agregación y desagregación.","code":""},{"path":"operaciones-con-geometrías.html","id":"operaciones-con-geometrías-con-el-paquete-terra","chapter":"16 Operaciones con geometrías","heading":"16.8 Operaciones con geometrías con el paquete terra","text":"","code":""},{"path":"examen-corto-1.html","id":"examen-corto-1","chapter":"Examen corto 1","heading":"Examen corto 1","text":"","code":""},{"path":"examen-corto-1.html","id":"fecha","chapter":"Examen corto 1","heading":"Fecha","text":"Grupo 001: Miércoles 20 de abril de 2022Grupo 002: Jueves 21 de abril de 2022","code":""},{"path":"examen-corto-1.html","id":"temas-a-evaluar","chapter":"Examen corto 1","heading":"Temas a evaluar","text":"Pensamiento computacionalPensamiento computacionalArquitectura de computadoras y lenguajes de programaciónArquitectura de computadoras y lenguajes de programaciónInteracción humano-computadorInteracción humano-computadorEjemplo de interfaz de línea de comandos - GDAL/OGR: biblioteca para lectura y escritura de datos geoespacialesEjemplo de interfaz de línea de comandos - GDAL/OGR: biblioteca para lectura y escritura de datos geoespacialesPebesma, E., Wagner, W., Verbesselt, J., Goor, E., Briese, C., & Neteler, M. (2016). OpenEO: GDAL Earth Observation Analytics. https://r-spatial.org/2016/11/29/openeo.htmlPebesma, E., Wagner, W., Verbesselt, J., Goor, E., Briese, C., & Neteler, M. (2016). OpenEO: GDAL Earth Observation Analytics. https://r-spatial.org/2016/11/29/openeo.html","code":""},{"path":"examen-corto-2.html","id":"examen-corto-2","chapter":"Examen corto 2","heading":"Examen corto 2","text":"","code":""},{"path":"examen-corto-2.html","id":"fecha-1","chapter":"Examen corto 2","heading":"Fecha","text":"Grupo 001: Miércoles 25 de mayo de 2022Grupo 002: Jueves 26 de mayo de 2022","code":""},{"path":"examen-corto-2.html","id":"temas-a-evaluar-1","chapter":"Examen corto 2","heading":"Temas a evaluar","text":"R - Conceptos básicosR MarkdownTidyverse: colección de paquetes para ciencia de datosdplyr: gramática para manipulación de datos","code":""},{"path":"examen-corto-3.html","id":"examen-corto-3","chapter":"Examen corto 3","heading":"Examen corto 3","text":"","code":""},{"path":"examen-corto-3.html","id":"fecha-2","chapter":"Examen corto 3","heading":"Fecha","text":"Grupo 001: Miércoles 8 de junio de 2022Grupo 002: Jueves 9 de junio de 2022","code":""},{"path":"examen-corto-3.html","id":"temas-a-evaluar-2","chapter":"Examen corto 3","heading":"Temas a evaluar","text":"Paquetes de R para graficación estadísticaIMPORTANTE:Solamente se evaluará el paquete ggplot2","code":""},{"path":"examen-corto-4.html","id":"examen-corto-4","chapter":"Examen corto 4","heading":"Examen corto 4","text":"","code":""},{"path":"examen-corto-4.html","id":"fecha-3","chapter":"Examen corto 4","heading":"Fecha","text":"Grupo 001: Miércoles 29 de junio de 2022Grupo 002: Jueves 30 de junio de 2022","code":""},{"path":"examen-corto-4.html","id":"temas-a-evaluar-3","chapter":"Examen corto 4","heading":"Temas a evaluar","text":"Introducción al manejo de datos geoespaciales en ROperaciones con datos de atributos","code":""},{"path":"tarea-1.html","id":"tarea-1","chapter":"Tarea 1","heading":"Tarea 1","text":"","code":""},{"path":"tarea-1.html","id":"fecha-y-hora-límite-de-entrega","chapter":"Tarea 1","heading":"Fecha y hora límite de entrega","text":"Grupo 001: Lunes 9 de mayo de 2022. 07:59 .m.Grupo 002: Martes 10 de mayo de 2022. 10:59 .m.","code":""},{"path":"tarea-1.html","id":"entregables","chapter":"Tarea 1","heading":"Entregables","text":"Dirección de un repositorio en GitHub llamado notas-investigacion-reproducible con un documento escrito en Markdown llamado README.md (ej. https://github.com/mfvargas/notas-investigacion-reproducible), con el contenido especificado en la sección Desarrollo.Dirección de un sitio web publicado en GitHub Pages generado partir del repositorio especificado en el punto anterior (ej. https://mfvargas.github.io/notas-investigacion-reproducible/).La entrega debe realizarse través de la plataforma Mediación Virtual.","code":""},{"path":"tarea-1.html","id":"objetivos","chapter":"Tarea 1","heading":"Objetivos","text":"Cada estudiante debe mostrar que es capaz de:Escribir documentos en el lenguaje de marcado Markdown.Manejar repositorios en GitHub.Publicar repositorios en GitHub como sitios web en GitHub Pages.","code":""},{"path":"tarea-1.html","id":"consideraciones-adicionales","chapter":"Tarea 1","heading":"Consideraciones adicionales","text":"Esta tarea es estrictamente individual.","code":""},{"path":"tarea-1.html","id":"desarrollo","chapter":"Tarea 1","heading":"Desarrollo","text":"El sitio web debe tener los contenidos y formatos que se muestran en las siguientes imágenes. Deben reproducirse los encabezados, negritas, itálicas, citas textuales, imágenes e hipervínculos otros documentos.Los textos están disponibles en este enlace.","code":""},{"path":"tarea-1.html","id":"calificación","chapter":"Tarea 1","heading":"Calificación","text":"Entre paréntesis, se muestra el porcentaje correspondiente cada aspecto que se calificará:Revisión de las direcciones entregadas en Mediación Virtual:\n- (5%) Dirección del repositorio en GitHub.\n- (5%) Dirección del sitio web publicado en GitHub Pages.Revisión de los elementos del documento escrito en Markdown:\n- (10%) Encabezados.\n- (20%) Negritas e itálicas.\n- (20%) Citas textuales.\n- (20%) Imagen de la figura 1 (el archivo está en ZiemannEtAlFig1.png.\n- (20%) Hipervínculos (además de los dos de la bibliografía, incluya uno al sitio web de la FDA en https://www.fda.gov/, en donde se mencionan las siglas).","code":""},{"path":"tarea-2.html","id":"tarea-2","chapter":"Tarea 2","heading":"Tarea 2","text":"","code":""},{"path":"tarea-2.html","id":"fecha-y-hora-límite-de-entrega-1","chapter":"Tarea 2","heading":"Fecha y hora límite de entrega","text":"Grupo 001: Lunes 20 de junio de 2022. 07:59 .m.Grupo 002: Martes 21 de mayo de 2022. 10:59 .m.","code":""},{"path":"tarea-2.html","id":"entregables-1","chapter":"Tarea 2","heading":"Entregables","text":"Dirección de un repositorio en GitHub con el código fuente en R Markdown que produzca el contenido especificado en la sección Desarrollo. Este repositorio también debe contener el archivo de datos.Dirección de un sitio web publicado en GitHub Pages generado partir del repositorio especificado en el punto anterior.La entrega debe realizarse través de la plataforma Mediación Virtual.","code":""},{"path":"tarea-2.html","id":"objetivos-1","chapter":"Tarea 2","heading":"Objetivos","text":"Cada estudiante debe mostrar que es capaz de:Desarrollar tablas interactivas con el paquete DT de R.Desarrollar gráficos estadísticos interactivos con los paquetes ggplot2 y plotly de R.Desarrollar documentos en R Markdown que desplieguen tablas y gráficos en páginas web.","code":""},{"path":"tarea-2.html","id":"consideraciones-adicionales-1","chapter":"Tarea 2","heading":"Consideraciones adicionales","text":"Esta tarea es estrictamente individual.La entrega en Mediación Virtual finaliza la hora especificada para cada grupo.","code":""},{"path":"tarea-2.html","id":"desarrollo-1","chapter":"Tarea 2","heading":"Desarrollo","text":"Cada estudiante debe desarrollar un documento R Markdown, publicado como un sitio web en GitHub Pages, que muestre tablas y gráficos para el conjunto de datos estadisticaspoliciales2021.xls, procedente de la página web de datos abiertos del Organismo de Investigación Juficial (OIJ). Sugerencia: lea el archivo XLS con la función readxl::read_excel().Las tablas y gráficos que debe desarrollar son:Una tabla DT que con las columnas Delito, Fecha, Víctima, Edad, Género, Provincia y Cantón.\nLas columnas deben, si es necesario, convertirse al tipo de datos adecuado (ej. Date).\nLos encabezados de las columnas en la tabla deben estar correctamente escritos (ej. con tildes), pero deben alterarse los nombres de las columnas del conjunto de datos. Sugerencia: utilice el argumento colnames de la función DT::datatable().\nLos controles de la tabla deben estar en español.\nLas columnas deben, si es necesario, convertirse al tipo de datos adecuado (ej. Date).Los encabezados de las columnas en la tabla deben estar correctamente escritos (ej. con tildes), pero deben alterarse los nombres de las columnas del conjunto de datos. Sugerencia: utilice el argumento colnames de la función DT::datatable().Los controles de la tabla deben estar en español.Un gráfico de barras simples (sin apilar ni agrupar), generado con ggplot2 y traducido plotly con ggplotly(), que muestre la cantidad de delitos por tipo de delito (una barra por tipo de delito: Asalto, homicidio, hurto, etc).\nLas barras del gráfico deben estar ordenadas por longitud, de la más larga la más corta (ya sea de izquierda derecha o de arriba abajo).\nEl gráfico debe tener título, etiqueta para el eje X y etiqueta para el eje Y.\nTodo el contenido del gráfico debe ser legible.\nLas barras del gráfico deben estar ordenadas por longitud, de la más larga la más corta (ya sea de izquierda derecha o de arriba abajo).El gráfico debe tener título, etiqueta para el eje X y etiqueta para el eje Y.Todo el contenido del gráfico debe ser legible.Un gráfico de barras simples (sin apilar ni agrupar), generado con ggplot2 y traducido plotly con ggplotly(), que muestre la cantidad de delitos por mes del año (una barra por cada uno de los meses del año).\nLas barras del gráfico deben estar ordenadas por número de mes (1, 2, …) o nombre de mes (Enero, Febrero, …).\nEl gráfico debe tener título, etiqueta para el eje X y etiqueta para el eje Y.\nTodo el contenido del gráfico debe ser legible.\nSugerencia: para obtener el mes del año, considere la función lubridate::month().\nLas barras del gráfico deben estar ordenadas por número de mes (1, 2, …) o nombre de mes (Enero, Febrero, …).El gráfico debe tener título, etiqueta para el eje X y etiqueta para el eje Y.Todo el contenido del gráfico debe ser legible.Sugerencia: para obtener el mes del año, considere la función lubridate::month().Un gráfico de barras apiladas, generado con ggplot2 y traducido plotly con ggplotly(), que muestre una barra por cada tipo de delito (Asalto, homicidio, hurto, etc). Cada barra debe mostrar la proporción (la cantidad) de delitos por género (mujer, hombre, desconocido).\nEl gráfico debe tener título, etiqueta para el eje X y etiqueta para el eje Y.\nTodo el contenido del gráfico debe ser legible.\nEl gráfico debe tener título, etiqueta para el eje X y etiqueta para el eje Y.Todo el contenido del gráfico debe ser legible.Un gráfico de barras simples (sin apilar ni agrupar), generado con ggplot2 y traducido plotly con ggplotly(), que muestre la cantidad de delitos para los cantones de San José, Alajuela, Cartago y Heredia (una barra por cantón).\nLas barras del gráfico deben estar ordenadas por longitud, de la más larga la más corta (ya sea de izquierda derecha o de arriba abajo).\nEl gráfico debe tener título, etiqueta para el eje X y etiqueta para el eje Y.\nTodo el contenido del gráfico debe ser legible.\nLas barras del gráfico deben estar ordenadas por longitud, de la más larga la más corta (ya sea de izquierda derecha o de arriba abajo).El gráfico debe tener título, etiqueta para el eje X y etiqueta para el eje Y.Todo el contenido del gráfico debe ser legible.","code":""},{"path":"tarea-2.html","id":"calificación-1","chapter":"Tarea 2","heading":"Calificación","text":"Entre paréntesis, se muestra el porcentaje correspondiente cada aspecto que se calificará:Revisión de las direcciones entregadas en Mediación Virtual:\n- Dirección del repositorio en GitHub que contiene el código fuente y el archivo de datos: 5%.\n- Dirección del sitio web publicado en GitHub Pages: 5%.Revisión de las tablas y gráficos:\n- Tabla: 10%.\n- Cada uno de los cuatro gráficos: 20%.","code":""},{"path":"covid-19-en-costa-rica.html","id":"covid-19-en-costa-rica","chapter":"COVID-19 en Costa Rica","heading":"COVID-19 en Costa Rica","text":"Análisis de datos de COVID-19 en Costa Rica - Gráficos del paquete base","code":""},{"path":"felinos-de-costa-rica.html","id":"felinos-de-costa-rica","chapter":"Felinos de Costa Rica","heading":"Felinos de Costa Rica","text":"Felinos de Costa Rica - R Markdown","code":""},{"path":"conjuntos-de-datos.html","id":"conjuntos-de-datos","chapter":"Conjuntos de datos","heading":"Conjuntos de datos","text":"La siguiente es la lista de conjuntos de datos utilizados en el curso, ordenados por el nombre de la institución o iniciativa que los comparte.","code":""},{"path":"conjuntos-de-datos.html","id":"centro-de-coordinación-para-la-prevención-de-los-desastres-en-centroamérica-y-república-dominicana-cepredenac","chapter":"Conjuntos de datos","heading":"Centro de Coordinación para la Prevención de los Desastres en Centroamérica y República Dominicana (Cepredenac)","text":"COVID","code":""},{"path":"conjuntos-de-datos.html","id":"instituto-geográfico-nacional-ign","chapter":"Conjuntos de datos","heading":"Instituto Geográfico Nacional (IGN)","text":"Delimitación territorial administrativa","code":""},{"path":"conjuntos-de-datos.html","id":"ministerio-de-salud","chapter":"Conjuntos de datos","heading":"Ministerio de Salud","text":"COVID","code":""}]
